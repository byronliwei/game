var cc = cc || {};
cc._tmp = cc._tmp || {};
cc._LogInfos = {};
_p = window;
_p = Object.prototype;
delete window._p;
cc.newElement = function(a) {
    return document.createElement(a)
};
cc._addEventListener = function(a, b, d, e) {
    a.addEventListener(b, d, e)
};
cc._isNodeJs = "undefined" !== typeof require && require("fs");
cc.each = function(a, b, d) {
    if (a)
        if (a instanceof Array)
            for (var e = 0, f = a.length; e < f && !1 !== b.call(d, a[e], e); e++);
        else
            for (e in a)
                if (!1 === b.call(d, a[e], e)) break
};
cc.extend = function(a) {
    var b = 2 <= arguments.length ? Array.prototype.slice.call(arguments, 1) : [];
    cc.each(b, function(b) {
        for (var e in b) b.hasOwnProperty(e) && (a[e] = b[e])
    });
    return a
};
cc.isFunction = function(a) {
    return "function" === typeof a
};
cc.isNumber = function(a) {
    return "number" === typeof a || "[object Number]" === Object.prototype.toString.call(a)
};
cc.isString = function(a) {
    return "string" === typeof a || "[object String]" === Object.prototype.toString.call(a)
};
cc.isArray = function(a) {
    return Array.isArray(a) || "object" === typeof a && "[object Array]" === Object.prototype.toString.call(a)
};
cc.isUndefined = function(a) {
    return "undefined" === typeof a
};
cc.isObject = function(a) {
    return "object" === typeof a && "[object Object]" === Object.prototype.toString.call(a)
};
cc.isCrossOrigin = function(a) {
    if (!a) return cc.log("invalid URL"), !1;
    var b = a.indexOf("://");
    if (-1 === b) return !1;
    b = a.indexOf("/", b + 3);
    return (-1 === b ? a : a.substring(0, b)) !== location.origin
};
cc.AsyncPool = function(a, b, d, e, f) {
    var g = this;
    g._srcObj = a;
    g._limit = b;
    g._pool = [];
    g._iterator = d;
    g._iteratorTarget = f;
    g._onEnd = e;
    g._onEndTarget = f;
    g._results = a instanceof Array ? [] : {};
    cc.each(a, function(a, b) {
        g._pool.push({
            index: b,
            value: a
        })
    });
    g.size = g._pool.length;
    g.finishedSize = 0;
    g._workingSize = 0;
    g._limit = g._limit || g.size;
    g.onIterator = function(a, b) {
        g._iterator = a;
        g._iteratorTarget = b
    };
    g.onEnd = function(a, b) {
        g._onEnd = a;
        g._onEndTarget = b
    };
    g._handleItem = function() {
        var a = this;
        if (!(0 === a._pool.length || a._workingSize >=
            a._limit)) {
            var b = a._pool.shift(),
                d = b.value,
                e = b.index;
            a._workingSize++;
            a._iterator.call(a._iteratorTarget, d, e, function(b) {
                a.finishedSize++;
                a._workingSize--;
                var d = Array.prototype.slice.call(arguments, 1);
                a._results[this.index] = d[0];
                a.finishedSize === a.size ? a._onEnd && a._onEnd.call(a._onEndTarget, null, a._results) : a._handleItem()
            }.bind(b), a)
        }
    };
    g.flow = function() {
        if (0 === this._pool.length) this._onEnd && this._onEnd.call(this._onEndTarget, null, []);
        else
            for (var a = 0; a < this._limit; a++) this._handleItem()
    }
};
cc.async = {
    series: function(a, b, d) {
        a = new cc.AsyncPool(a, 1, function(a, b, g) {
            a.call(d, g)
        }, b, d);
        a.flow();
        return a
    },
    parallel: function(a, b, d) {
        a = new cc.AsyncPool(a, 0, function(a, b, g) {
            a.call(d, g)
        }, b, d);
        a.flow();
        return a
    },
    waterfall: function(a, b, d) {
        var e = [],
            f = [null],
            g = new cc.AsyncPool(a, 1, function(b, g, m) {
                e.push(function(b) {
                    e = Array.prototype.slice.call(arguments, 1);
                    a.length - 1 === g && (f = f.concat(e));
                    m.apply(null, arguments)
                });
                b.apply(d, e)
            }, function(a) {
                if (b) {
                    if (a) return b.call(d, a);
                    b.apply(d, f)
                }
            });
        g.flow();
        return g
    },
    map: function(a, b, d, e) {
        var f = b;
        "object" === typeof b && (d = b.cb, e = b.iteratorTarget, f = b.iterator);
        a = new cc.AsyncPool(a, 0, f, d, e);
        a.flow();
        return a
    },
    mapLimit: function(a, b, d, e, f) {
        a = new cc.AsyncPool(a, b, d, e, f);
        a.flow();
        return a
    }
};
cc.path = {
    join: function() {
        for (var a = arguments.length, b = "", d = 0; d < a; d++) b = (b + ("" === b ? "" : "/") + arguments[d]).replace(/(\/|\\\\)$/, "");
        return b
    },
    extname: function(a) {
        return (a = /(\.[^\.\/\?\\]*)(\?.*)?$/.exec(a)) ? a[1] : null
    },
    mainFileName: function(a) {
        if (a) {
            var b = a.lastIndexOf(".");
            if (-1 !== b) return a.substring(0, b)
        }
        return a
    },
    basename: function(a, b) {
        var d = a.indexOf("?");
        0 < d && (a = a.substring(0, d));
        d = /(\/|\\\\)([^(\/|\\\\)]+)$/g.exec(a.replace(/(\/|\\\\)$/, ""));
        if (!d) return null;
        d = d[2];
        return b && a.substring(a.length -
            b.length).toLowerCase() === b.toLowerCase() ? d.substring(0, d.length - b.length) : d
    },
    dirname: function(a) {
        return a.replace(/((.*)(\/|\\|\\\\))?(.*?\..*$)?/, "$2")
    },
    changeExtname: function(a, b) {
        b = b || "";
        var d = a.indexOf("?"),
            e = "";
        0 < d && (e = a.substring(d), a = a.substring(0, d));
        d = a.lastIndexOf(".");
        return 0 > d ? a + b + e : a.substring(0, d) + b + e
    },
    changeBasename: function(a, b, d) {
        if (0 === b.indexOf(".")) return this.changeExtname(a, b);
        var e = a.indexOf("?"),
            f = "";
        d = d ? this.extname(a) : "";
        0 < e && (f = a.substring(e), a = a.substring(0, e));
        e = a.lastIndexOf("/");
        return a.substring(0, 0 >= e ? 0 : e + 1) + b + d + f
    }
};
cc.loader = {
    _jsCache: {},
    _register: {},
    _langPathCache: {},
    _aliases: {},
    resPath: "",
    audioPath: "",
    cache: {},
    getXMLHttpRequest: function() {
        return window.XMLHttpRequest ? new window.XMLHttpRequest : new ActiveXObject("MSXML2.XMLHTTP")
    },
    _getArgs4Js: function(a) {
        var b = a[0],
            d = a[1],
            e = a[2],
            f = ["", null, null];
        if (1 === a.length) f[1] = b instanceof Array ? b : [b];
        else if (2 === a.length) "function" === typeof d ? (f[1] = b instanceof Array ? b : [b], f[2] = d) : (f[0] = b || "", f[1] = d instanceof Array ? d : [d]);
        else if (3 === a.length) f[0] = b || "", f[1] = d instanceof
        Array ? d : [d], f[2] = e;
        else throw Error("arguments error to load js!");
        return f
    },
    loadJs: function(a, b, d) {
        var e = this,
            f = e._jsCache,
            g = e._getArgs4Js(arguments),
            h = g[0],
            k = g[1],
            g = g[2]; - 1 < navigator.userAgent.indexOf("Trident/5") ? e._loadJs4Dependency(h, k, 0, g) : cc.async.map(k, function(a, b, d) {
            a = cc.path.join(h, a);
            if (f[a]) return d(null);
            e._createScript(a, !1, d)
        }, g)
    },
    loadJsWithImg: function(a, b, d) {
        var e = this._loadJsImg(),
            f = this._getArgs4Js(arguments);
        this.loadJs(f[0], f[1], function(a) {
            if (a) throw Error(a);
            e.parentNode.removeChild(e);
            if (f[2]) f[2]()
        })
    },
    _createScript: function(a, b, d) {
        var e = document,
            f = cc.newElement("script");
        f.async = b;
        this._jsCache[a] = !0;
        cc.game.config.noCache && "string" === typeof a ? this._noCacheRex.test(a) ? f.src = a + "\x26_t\x3d" + (new Date - 0) : f.src = a + "?_t\x3d" + (new Date - 0) : f.src = a;
        cc._addEventListener(f, "load", function() {
            f.parentNode.removeChild(f);
            this.removeEventListener("load", arguments.callee, !1);
            d()
        }, !1);
        cc._addEventListener(f, "error", function() {
            f.parentNode.removeChild(f);
            d("Load " + a + " failed!")
        }, !1);
        e.body.appendChild(f)
    },
    _loadJs4Dependency: function(a, b, d, e) {
        if (d >= b.length) e && e();
        else {
            var f = this;
            f._createScript(cc.path.join(a, b[d]), !1, function(g) {
                if (g) return e(g);
                f._loadJs4Dependency(a, b, d + 1, e)
            })
        }
    },
    _loadJsImg: function() {
        var a = document,
            b = a.getElementById("cocos2d_loadJsImg");
        if (!b) {
            b = cc.newElement("img");
            cc._loadingImage && (b.src = cc._loadingImage);
            a = a.getElementById(cc.game.config.id);
            a.style.backgroundColor = "transparent";
            a.parentNode.appendChild(b);
            var d = getComputedStyle ? getComputedStyle(a) : a.currentStyle;
            d || (d = {
                width: a.width,
                height: a.height
            });
            b.style.left = a.offsetLeft + (parseFloat(d.width) - b.width) / 2 + "px";
            b.style.top = a.offsetTop + (parseFloat(d.height) - b.height) / 2 + "px";
            b.style.position = "absolute"
        }
        return b
    },
    loadTxt: function(a, b) {
        if (cc._isNodeJs) require("fs").readFile(a, function(a, d) {
            a ? b(a) : b(null, d.toString())
        });
        else {
            var d = this.getXMLHttpRequest(),
                e = "load " + a + " failed!";
            d.open("GET", a, !0);
            /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) ? (d.setRequestHeader("Accept-Charset", "utf-8"), d.onreadystatechange =
                function() {
                    4 === d.readyState && (200 === d.status ? b(null, d.responseText) : b({
                        status: d.status,
                        errorMessage: e
                    }, null))
                }) : (d.overrideMimeType && d.overrideMimeType("text/plain; charset\x3dutf-8"), d.onload = function() {
                4 === d.readyState && (200 === d.status ? b(null, d.responseText) : b({
                    status: d.status,
                    errorMessage: e
                }, null))
            }, d.onerror = function() {
                b({
                    status: d.status,
                    errorMessage: e
                }, null)
            });
            d.send(null)
        }
    },
    _loadTxtSync: function(a) {
        if (cc._isNodeJs) return require("fs").readFileSync(a).toString();
        var b = this.getXMLHttpRequest();
        b.open("GET", a, !1);
        /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) ? b.setRequestHeader("Accept-Charset", "utf-8") : b.overrideMimeType && b.overrideMimeType("text/plain; charset\x3dutf-8");
        b.send(null);
        return 4 === !b.readyState || 200 !== b.status ? null : b.responseText
    },
    loadCsb: function(a, b) {
        var d = new XMLHttpRequest,
            e = "load " + a + " failed!";
        d.open("GET", a, !0);
        d.responseType = "arraybuffer";
        d.onload = function() {
            var a = d.response;
            a && (window.msg = a);
            4 === d.readyState && (200 === d.status ? b(null, d.response) :
                b({
                    status: d.status,
                    errorMessage: e
                }, null))
        };
        d.onerror = function() {
            b({
                status: d.status,
                errorMessage: e
            }, null)
        };
        d.send(null)
    },
    loadJson: function(a, b) {
        this.loadTxt(a, function(d, e) {
            if (d) b(d);
            else {
                try {
                    var f = JSON.parse(e)
                } catch (g) {
                    throw Error("parse json [" + a + "] failed : " + g);
                }
                b(null, f)
            }
        })
    },
    _checkIsImageURL: function(a) {
        return null != /(\.png)|(\.jpg)|(\.bmp)|(\.jpeg)|(\.gif)/.exec(a)
    },
    loadImg: function(a, b, d) {
        var e = {
            isCrossOrigin: !0
        };
        void 0 !== d ? e.isCrossOrigin = null === b.isCrossOrigin ? e.isCrossOrigin : b.isCrossOrigin :
            void 0 !== b && (d = b);
        var f = this.getRes(a);
        if (f) return d && d(null, f), f;
        f = new Image;
        e.isCrossOrigin && "file://" !== location.origin && (f.crossOrigin = "Anonymous");
        var g = function() {
                this.removeEventListener("load", g, !1);
                this.removeEventListener("error", k, !1);
                d && d(null, f)
            },
            h = this,
            k = function() {
                this.removeEventListener("error", k, !1);
                f.crossOrigin && "anonymous" === f.crossOrigin.toLowerCase() ? (e.isCrossOrigin = !1, h.release(a), cc.loader.loadImg(a, e, d)) : "function" === typeof d && d("load image failed")
            };
        cc._addEventListener(f,
            "load", g);
        cc._addEventListener(f, "error", k);
        f.src = a;
        return f
    },
    _loadResIterator: function(a, b, d) {
        var e = this,
            f = null,
            g = a.type;
        g ? (g = "." + g.toLowerCase(), f = a.src ? a.src : a.name + g) : (f = a, g = cc.path.extname(f));
        if (b = e.getRes(f)) return d(null, b);
        b = null;
        g && (b = e._register[g.toLowerCase()]);
        if (!b) return cc.error("loader for [" + g + "] not exists!"), d();
        g = f;
        cc._urlRegExp.test(f) || (g = b.getBasePath ? b.getBasePath() : e.resPath, g = e.getUrl(g, f));
        cc.game.config.noCache && "string" === typeof g && (g = e._noCacheRex.test(g) ? g + ("\x26_t\x3d" +
            (new Date - 0)) : g + ("?_t\x3d" + (new Date - 0)));
        b.load(g, f, a, function(a, b) {
            a ? (cc.log(a), e.cache[f] = null, delete e.cache[f], d({
                status: 520,
                errorMessage: a
            }, null)) : (e.cache[f] = b, d(null, b))
        })
    },
    _noCacheRex: /\?/,
    getUrl: function(a, b) {
        var d = this._langPathCache,
            e = cc.path;
        if (void 0 !== a && void 0 === b) {
            b = a;
            var f = e.extname(b),
                f = f ? f.toLowerCase() : "";
            a = (f = this._register[f]) ? f.getBasePath ? f.getBasePath() : this.resPath : this.resPath
        }
        b = cc.path.join(a || "", b);
        if (b.match(/[\/(\\\\)]lang[\/(\\\\)]/i)) {
            if (d[b]) return d[b];
            e = e.extname(b) ||
                "";
            b = d[b] = b.substring(0, b.length - e.length) + "_" + cc.sys.language + e
        }
        return b
    },
    load: function(a, b, d) {
        var e = this,
            f = arguments.length;
        if (0 === f) throw Error("arguments error!");
        3 === f ? "function" === typeof b && (b = "function" === typeof d ? {
            trigger: b,
            cb: d
        } : {
            cb: b,
            cbTarget: d
        }) : 2 === f ? "function" === typeof b && (b = {
            cb: b
        }) : 1 === f && (b = {});
        a instanceof Array || (a = [a]);
        f = new cc.AsyncPool(a, 0, function(a, d, f, m) {
            e._loadResIterator(a, d, function(a) {
                var d = Array.prototype.slice.call(arguments, 1);
                b.trigger && b.trigger.call(b.triggerTarget,
                    d[0], m.size, m.finishedSize);
                f(a, d[0])
            })
        }, b.cb, b.cbTarget);
        f.flow();
        return f
    },
    _handleAliases: function(a, b) {
        var d = this._aliases,
            e = [],
            f;
        for (f in a) {
            var g = a[f];
            d[f] = g;
            e.push(g)
        }
        this.load(e, b)
    },
    loadAliases: function(a, b) {
        var d = this,
            e = d.getRes(a);
        e ? d._handleAliases(e.filenames, b) : d.load(a, function(a, e) {
            d._handleAliases(e[0].filenames, b)
        })
    },
    register: function(a, b) {
        if (a && b) {
            if ("string" === typeof a) return this._register[a.trim().toLowerCase()] = b;
            for (var d = 0, e = a.length; d < e; d++) this._register["." + a[d].trim().toLowerCase()] =
                b
        }
    },
    getRes: function(a) {
        return this.cache[a] || this.cache[this._aliases[a]]
    },
    release: function(a) {
        var b = this.cache,
            d = this._aliases;
        delete b[a];
        delete b[d[a]];
        delete d[a]
    },
    releaseAll: function() {
        var a = this.cache,
            b = this._aliases,
            d;
        for (d in a) delete a[d];
        for (d in b) delete b[d]
    }
};
cc.formatStr = function() {
    var a = arguments,
        b = a.length;
    if (1 > b) return "";
    var d = a[0],
        e = !0;
    "object" === typeof d && (e = !1);
    for (var f = 1; f < b; ++f) {
        var g = a[f];
        if (e)
            for (;;) {
                var h = null;
                if ("number" === typeof g && (h = d.match(/(%d)|(%s)/))) {
                    d = d.replace(/(%d)|(%s)/, g);
                    break
                }
                d = (h = d.match(/%s/)) ? d.replace(/%s/, g) : d + ("    " + g);
                break
            } else d += "    " + g
    }
    return d
};
(function() {
    var a = window,
        b, d;
    cc.isUndefined(document.hidden) ? cc.isUndefined(document.mozHidden) ? cc.isUndefined(document.msHidden) ? cc.isUndefined(document.webkitHidden) || (b = "webkitHidden", d = "webkitvisibilitychange") : (b = "msHidden", d = "msvisibilitychange") : (b = "mozHidden", d = "mozvisibilitychange") : (b = "hidden", d = "visibilitychange");
    var e = function() {
            cc.eventManager && cc.game._eventHide && cc.eventManager.dispatchEvent(cc.game._eventHide)
        },
        f = function() {
            cc.eventManager && cc.game._eventShow && cc.eventManager.dispatchEvent(cc.game._eventShow);
            cc.game._intervalId && (window.cancelAnimationFrame(cc.game._intervalId), cc.game._runMainLoop())
        };
    b ? cc._addEventListener(document, d, function() {
        document[b] ? e() : f()
    }, !1) : (cc._addEventListener(a, "blur", e, !1), cc._addEventListener(a, "focus", f, !1)); - 1 < navigator.userAgent.indexOf("MicroMessenger") && (a.onfocus = function() {
        f()
    });
    "onpageshow" in window && "onpagehide" in window && (cc._addEventListener(a, "pagehide", e, !1), cc._addEventListener(a, "pageshow", f, !1));
    d = a = null
})();
cc.log = cc.warn = cc.error = cc.assert = function() {};
cc.create3DContext = function(a, b) {
    for (var d = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"], e = null, f = 0; f < d.length; ++f) {
        try {
            e = a.getContext(d[f], b)
        } catch (g) {}
        if (e) break
    }
    return e
};
cc._initSys = function(a, b) {
    cc._RENDER_TYPE_CANVAS = 0;
    cc._RENDER_TYPE_WEBGL = 1;
    cc.sys = {};
    var d = cc.sys;
    d.LANGUAGE_ENGLISH = "en";
    d.LANGUAGE_CHINESE = "zh";
    d.LANGUAGE_FRENCH = "fr";
    d.LANGUAGE_ITALIAN = "it";
    d.LANGUAGE_GERMAN = "de";
    d.LANGUAGE_SPANISH = "es";
    d.LANGUAGE_DUTCH = "du";
    d.LANGUAGE_RUSSIAN = "ru";
    d.LANGUAGE_KOREAN = "ko";
    d.LANGUAGE_JAPANESE = "ja";
    d.LANGUAGE_HUNGARIAN = "hu";
    d.LANGUAGE_PORTUGUESE = "pt";
    d.LANGUAGE_ARABIC = "ar";
    d.LANGUAGE_NORWEGIAN = "no";
    d.LANGUAGE_POLISH = "pl";
    d.OS_IOS = "iOS";
    d.OS_ANDROID = "Android";
    d.OS_WINDOWS =
        "Windows";
    d.OS_MARMALADE = "Marmalade";
    d.OS_LINUX = "Linux";
    d.OS_BADA = "Bada";
    d.OS_BLACKBERRY = "Blackberry";
    d.OS_OSX = "OS X";
    d.OS_WP8 = "WP8";
    d.OS_WINRT = "WINRT";
    d.OS_UNKNOWN = "Unknown";
    d.UNKNOWN = -1;
    d.WIN32 = 0;
    d.LINUX = 1;
    d.MACOS = 2;
    d.ANDROID = 3;
    d.IPHONE = 4;
    d.IPAD = 5;
    d.BLACKBERRY = 6;
    d.NACL = 7;
    d.EMSCRIPTEN = 8;
    d.TIZEN = 9;
    d.WINRT = 10;
    d.WP8 = 11;
    d.MOBILE_BROWSER = 100;
    d.DESKTOP_BROWSER = 101;
    d.BROWSER_TYPE_WECHAT = "wechat";
    d.BROWSER_TYPE_ANDROID = "androidbrowser";
    d.BROWSER_TYPE_IE = "ie";
    d.BROWSER_TYPE_QQ = "qqbrowser";
    d.BROWSER_TYPE_MOBILE_QQ =
        "mqqbrowser";
    d.BROWSER_TYPE_UC = "ucbrowser";
    d.BROWSER_TYPE_360 = "360browser";
    d.BROWSER_TYPE_BAIDU_APP = "baiduboxapp";
    d.BROWSER_TYPE_BAIDU = "baidubrowser";
    d.BROWSER_TYPE_MAXTHON = "maxthon";
    d.BROWSER_TYPE_OPERA = "opera";
    d.BROWSER_TYPE_OUPENG = "oupeng";
    d.BROWSER_TYPE_MIUI = "miuibrowser";
    d.BROWSER_TYPE_FIREFOX = "firefox";
    d.BROWSER_TYPE_SAFARI = "safari";
    d.BROWSER_TYPE_CHROME = "chrome";
    d.BROWSER_TYPE_LIEBAO = "liebao";
    d.BROWSER_TYPE_QZONE = "qzone";
    d.BROWSER_TYPE_SOUGOU = "sogou";
    d.BROWSER_TYPE_UNKNOWN = "unknown";
    d.isNative = !1;
    var e = window,
        f = e.navigator,
        g = document,
        h = g.documentElement,
        k = f.userAgent.toLowerCase();
    d.isMobile = -1 !== k.indexOf("mobile") || -1 !== k.indexOf("android");
    d.platform = d.isMobile ? d.MOBILE_BROWSER : d.DESKTOP_BROWSER;
    var m = f.language,
        m = (m = m ? m : f.browserLanguage) ? m.split("-")[0] : d.LANGUAGE_ENGLISH;
    d.language = m;
    var m = d.BROWSER_TYPE_UNKNOWN,
        n = k.match(/sogou|qzone|liebao|micromessenger|qqbrowser|ucbrowser|360 aphone|360browser|baiduboxapp|baidubrowser|maxthon|trident|oupeng|opera|miuibrowser|firefox/i) || k.match(/chrome|safari/i);
    n && 0 < n.length ? (m = n[0], "micromessenger" === m ? m = d.BROWSER_TYPE_WECHAT : "safari" === m && k.match(/android.*applewebkit/) ? m = d.BROWSER_TYPE_ANDROID : "trident" === m ? m = d.BROWSER_TYPE_IE : "360 aphone" === m && (m = d.BROWSER_TYPE_360)) : k.indexOf("iphone") && k.indexOf("mobile") && (m = "safari");
    d.browserType = m;
    m = k.match(/(iPad|iPhone|iPod)/i) ? !0 : !1;
    k = k.match(/android/i) || f.platform.match(/android/i) ? !0 : !1;
    n = d.OS_UNKNOWN; - 1 !== f.appVersion.indexOf("Win") ? n = d.OS_WINDOWS : m ? n = d.OS_IOS : -1 !== f.appVersion.indexOf("Mac") ? n = d.OS_OSX :
        -1 !== f.appVersion.indexOf("X11") && -1 === f.appVersion.indexOf("Linux") ? n = d.OS_UNIX : k ? n = d.OS_ANDROID : -1 !== f.appVersion.indexOf("Linux") && (n = d.OS_LINUX);
    d.os = n;
    d._supportMultipleAudio = -1 < [d.BROWSER_TYPE_BAIDU, d.BROWSER_TYPE_OPERA, d.BROWSER_TYPE_FIREFOX, d.BROWSER_TYPE_CHROME, d.BROWSER_TYPE_BAIDU_APP, d.BROWSER_TYPE_SAFARI, d.BROWSER_TYPE_UC, d.BROWSER_TYPE_QQ, d.BROWSER_TYPE_MOBILE_QQ, d.BROWSER_TYPE_IE].indexOf(d.browserType);
    (function(a, d) {
        var f = d[b.renderMode] - 0;
        if (isNaN(f) || 2 < f || 0 > f) f = 0;
        var g = [a.OS_ANDROID],
            h = [],
            k = cc.newElement("canvas");
        cc._renderType = cc._RENDER_TYPE_CANVAS;
        cc._supportRender = !1;
        var m = e.WebGLRenderingContext;
        if (2 === f || 0 === f && m && -1 === g.indexOf(a.os) && -1 === h.indexOf(a.browserType)) try {
            cc.create3DContext(k, {
                stencil: !0,
                preserveDrawingBuffer: !0
            }) && (cc._renderType = cc._RENDER_TYPE_WEBGL, cc._supportRender = !0)
        } catch (n) {}
        if (1 === f || 0 === f && !1 === cc._supportRender) try {
            k.getContext("2d"), cc._renderType = cc._RENDER_TYPE_CANVAS, cc._supportRender = !0
        } catch (p) {}
    })(d, a);
    d._canUseCanvasNewBlendModes = function() {
        var a =
            document.createElement("canvas");
        a.width = 1;
        a.height = 1;
        a = a.getContext("2d");
        a.fillStyle = "#000";
        a.fillRect(0, 0, 1, 1);
        a.globalCompositeOperation = "multiply";
        var b = document.createElement("canvas");
        b.width = 1;
        b.height = 1;
        var d = b.getContext("2d");
        d.fillStyle = "#fff";
        d.fillRect(0, 0, 1, 1);
        a.drawImage(b, 0, 0, 1, 1);
        return 0 === a.getImageData(0, 0, 1, 1).data[0]
    };
    d._supportCanvasNewBlendModes = d._canUseCanvasNewBlendModes();
    try {
        d._supportWebAudio = !(!e.AudioContext && !e.webkitAudioContext && !e.mozAudioContext)
    } catch (p) {
        d._supportWebAudio = !1
    }
    try {
        var r = d.localStorage = e.localStorage;
        r.setItem("storage", "");
        r.removeItem("storage");
        r = null
    } catch (s) {
        r = function() {
            cc.warn("Warning: localStorage isn't enabled. Please confirm browser cookie or privacy option")
        }, d.localStorage = {
            getItem: r,
            setItem: r,
            removeItem: r,
            clear: r
        }
    }
    r = d.capabilities = {
        canvas: !0
    };
    cc._renderType === cc._RENDER_TYPE_WEBGL && (r.opengl = !0);
    if (void 0 !== h.ontouchstart || void 0 !== g.ontouchstart || f.msPointerEnabled) r.touches = !0;
    void 0 !== h.onmouseup && (r.mouse = !0);
    void 0 !== h.onkeyup && (r.keyboard = !0);
    if (e.DeviceMotionEvent || e.DeviceOrientationEvent) r.accelerometer = !0;
    d.garbageCollect = function() {};
    d.dumpRoot = function() {};
    d.restartVM = function() {};
    d.cleanScript = function(a) {};
    d.isObjectValid = function(a) {
        return a ? !0 : !1
    };
    d.dump = function() {
        var a;
        a = "" + ("isMobile : " + this.isMobile + "\r\n");
        a += "language : " + this.language + "\r\n";
        a += "browserType : " + this.browserType + "\r\n";
        a += "capabilities : " + JSON.stringify(this.capabilities) + "\r\n";
        a += "os : " + this.os + "\r\n";
        a += "platform : " + this.platform + "\r\n";
        cc.log(a)
    };
    d.openURL = function(a) {
        // window.open(a)
    }
};
cc.ORIENTATION_PORTRAIT = 0;
cc.ORIENTATION_PORTRAIT_UPSIDE_DOWN = 1;
cc.ORIENTATION_LANDSCAPE_LEFT = 2;
cc.ORIENTATION_LANDSCAPE_RIGHT = 3;
cc._drawingUtil = null;
cc._renderContext = null;
cc._canvas = null;
cc._gameDiv = null;
cc._rendererInitialized = !1;
cc._setupCalled = !1;
cc._setup = function(a, b, d) {
    if (!cc._setupCalled) {
        cc._setupCalled = !0;
        var e = window,
            f = cc.$(a) || cc.$("#" + a),
            g;
        cc.game._setAnimFrame();
        "CANVAS" === f.tagName ? (b = b || f.width, d = d || f.height, g = cc.container = cc.newElement("DIV"), a = cc._canvas = f, a.parentNode.insertBefore(g, a), a.appendTo(g), g.setAttribute("id", "Cocos2dGameContainer")) : ("DIV" !== f.tagName && cc.log("Warning: target element is not a DIV or CANVAS"), b = b || f.clientWidth, d = d || f.clientHeight, g = cc.container = f, a = cc._canvas = cc.$(cc.newElement("CANVAS")), f.appendChild(a));
        a.addClass("gameCanvas");
        a.setAttribute("width", b || 480);
        a.setAttribute("height", d || 320);
        a.setAttribute("tabindex", 99);
        a.style.outline = "none";
        f = g.style;
        f.width = (b || 480) + "px";
        f.height = (d || 320) + "px";
        f.margin = "0 auto";
        f.position = "relative";
        f.overflow = "hidden";
        g.top = "100%";
        cc._renderType === cc._RENDER_TYPE_WEBGL && (cc._renderContext = cc.webglContext = cc.create3DContext(a, {
            stencil: !0,
            preserveDrawingBuffer: !0,
            antialias: !cc.sys.isMobile,
            alpha: !0
        }));
        cc._renderContext ? (e.gl = cc._renderContext, cc._drawingUtil = new cc.DrawingPrimitiveWebGL(cc._renderContext),
            cc._rendererInitialized = !0, cc.textureCache._initializingRenderer(), cc.shaderCache._init()) : (cc._renderContext = new cc.CanvasContextWrapper(a.getContext("2d")), cc._drawingUtil = cc.DrawingPrimitiveCanvas ? new cc.DrawingPrimitiveCanvas(cc._renderContext) : null);
        cc._gameDiv = g;
        cc.log(cc.ENGINE_VERSION);
        cc._setContextMenuEnable(!1);
        cc.sys.isMobile && (b = cc.newElement("style"), b.type = "text/css", document.body.appendChild(b), b.textContent = "body,canvas,div{ -moz-user-select: none;-webkit-user-select: none;-ms-user-select: none;-khtml-user-select: none;-webkit-tap-highlight-color:rgba(0,0,0,0);}");
        cc.view = cc.EGLView._getInstance();
        cc.inputManager.registerSystemEvent(cc._canvas);
        cc.director = cc.Director._getInstance();
        cc.director.setOpenGLView && cc.director.setOpenGLView(cc.view);
        cc.winSize = cc.director.getWinSize();
        cc.saxParser = new cc.SAXParser;
        cc.plistParser = new cc.PlistParser
    }
};
cc._checkWebGLRenderMode = function() {
    if (cc._renderType !== cc._RENDER_TYPE_WEBGL) throw Error("This feature supports WebGL render mode only.");
};
cc._isContextMenuEnable = !1;
cc._setContextMenuEnable = function(a) {
    cc._isContextMenuEnable = a;
    cc._canvas.oncontextmenu = function() {
        if (!cc._isContextMenuEnable) return !1
    }
};
cc.game = {
    DEBUG_MODE_NONE: 0,
    DEBUG_MODE_INFO: 1,
    DEBUG_MODE_WARN: 2,
    DEBUG_MODE_ERROR: 3,
    DEBUG_MODE_INFO_FOR_WEB_PAGE: 4,
    DEBUG_MODE_WARN_FOR_WEB_PAGE: 5,
    DEBUG_MODE_ERROR_FOR_WEB_PAGE: 6,
    EVENT_HIDE: "game_on_hide",
    EVENT_SHOW: "game_on_show",
    EVENT_RESIZE: "game_on_resize",
    _eventHide: null,
    _eventShow: null,
    _onBeforeStartArr: [],
    CONFIG_KEY: {
        engineDir: "engineDir",
        dependencies: "dependencies",
        debugMode: "debugMode",
        showFPS: "showFPS",
        frameRate: "frameRate",
        id: "id",
        renderMode: "renderMode",
        jsList: "jsList",
        classReleaseMode: "classReleaseMode"
    },
    _prepareCalled: !1,
    _prepared: !1,
    _paused: !0,
    _intervalId: null,
    _lastTime: null,
    _frameTime: null,
    config: null,
    onStart: null,
    onStop: null,
    setFrameRate: function(a) {
        this.config[this.CONFIG_KEY.frameRate] = a;
        this._intervalId && window.cancelAnimationFrame(this._intervalId);
        this._paused = !0;
        this._setAnimFrame();
        this._runMainLoop()
    },
    _setAnimFrame: function() {
        this._lastTime = new Date;
        this._frameTime = 1E3 / cc.game.config[cc.game.CONFIG_KEY.frameRate];
        cc.sys.os === cc.sys.OS_IOS && cc.sys.browserType === cc.sys.BROWSER_TYPE_WECHAT ||
            60 !== cc.game.config[cc.game.CONFIG_KEY.frameRate] ? (window.requestAnimFrame = this._stTime, window.cancelAnimationFrame = this._ctTime) : (window.requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || this._stTime, window.cancelAnimationFrame = window.cancelAnimationFrame || window.cancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame ||
                window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.oCancelAnimationFrame || this._ctTime)
    },
    _stTime: function(a) {
        var b = (new Date).getTime(),
            d = Math.max(0, cc.game._frameTime - (b - cc.game._lastTime)),
            e = window.setTimeout(function() {
                a()
            }, d);
        cc.game._lastTime = b + d;
        return e
    },
    _ctTime: function(a) {
        window.clearTimeout(a)
    },
    _runMainLoop: function() {
        var a = this,
            b, d = cc.director;
        d.setDisplayStats(a.config[a.CONFIG_KEY.showFPS]);
        b = function() {
            a._paused || (d.mainLoop(), a._intervalId && window.cancelAnimationFrame(a._intervalId), a._intervalId = window.requestAnimFrame(b))
        };
        window.requestAnimFrame(b);
        a._paused = !1
    },
    restart: function() {
        cc.director.popToSceneStackLevel(0);
        cc.audioEngine && cc.audioEngine.end();
        cc.game.onStart()
    },
    run: function(a) {
        var b = this,
            d = function() {
                a && (b.config[b.CONFIG_KEY.id] = a);
                b._prepareCalled || b.prepare(function() {
                    b._prepared = !0
                });
                cc._supportRender && (b._checkPrepare = setInterval(function() {
                    b._prepared && (cc._setup(b.config[b.CONFIG_KEY.id]),
                        b._runMainLoop(), b._eventHide = b._eventHide || new cc.EventCustom(b.EVENT_HIDE), b._eventHide.setUserData(b), b._eventShow = b._eventShow || new cc.EventCustom(b.EVENT_SHOW), b._eventShow.setUserData(b), b.onStart(), clearInterval(b._checkPrepare))
                }, 10))
            };
        document.body ? d() : cc._addEventListener(window, "load", function() {
            this.removeEventListener("load", arguments.callee, !1);
            d()
        }, !1)
    },
    _initConfig: function() {
        var a = this.CONFIG_KEY,
            b = function(b) {
                b[a.engineDir] = b[a.engineDir] || "frameworks/cocos2d-html5";
                null == b[a.debugMode] &&
                    (b[a.debugMode] = 0);
                b[a.frameRate] = b[a.frameRate] || 60;
                null == b[a.renderMode] && (b[a.renderMode] = 1);
                return b
            };
        if (document.ccConfig) this.config = b(document.ccConfig);
        else try {
            for (var d = document.getElementsByTagName("script"), e = 0; e < d.length; e++) {
                var f = d[e].getAttribute("cocos");
                if ("" === f || f) break
            }
            var g, h, k;
            if (e < d.length) {
                if (g = d[e].src) k = /(.*)\//.exec(g)[0], cc.loader.resPath = k, g = cc.path.join(k, "static/project.json");
                h = cc.loader._loadTxtSync(g)
            }
            h || (h = cc.loader._loadTxtSync("static/project.json"));
            var m = JSON.parse(h);
            this.config =
                b(m || {})
        } catch (n) {
            cc.log("Failed to read or parse project.json"), this.config = b({})
        }
        cc._initSys(this.config, a)
    },
    _jsAddedCache: {},
    _getJsListOfModule: function(a, b, d) {
        var e = this._jsAddedCache;
        if (e[b]) return null;
        d = d || "";
        var f = [],
            g = a[b];
        if (!g) throw Error("can not find module [" + b + "]");
        b = cc.path;
        for (var h = 0, k = g.length; h < k; h++) {
            var m = g[h];
            if (!e[m]) {
                var n = b.extname(m);
                n ? ".js" === n.toLowerCase() && f.push(b.join(d, m)) : (n = this._getJsListOfModule(a, m, d)) && (f = f.concat(n));
                e[m] = 1
            }
        }
        return f
    },
    prepare: function(a) {
        var b =
            this,
            d = b.config,
            e = b.CONFIG_KEY,
            f = d[e.engineDir],
            g = cc.loader;
        if (!cc._supportRender) throw Error("The renderer doesn't support the renderMode " + d[e.renderMode]);
        b._prepareCalled = !0;
        var h = d[e.jsList] || [];
        cc.Class ? g.loadJsWithImg("", h, function(d) {
            if (d) throw Error(d);
            b._prepared = !0;
            a && a()
        }) : (e = cc.path.join(f, "moduleConfig.json"), g.loadJson(e, function(e, g) {
            if (e) throw Error(e);
            var n = d.modules || [],
                p = g.module,
                r = [];
            cc._renderType === cc._RENDER_TYPE_WEBGL ? n.splice(0, 0, "shaders") : 0 > n.indexOf("core") && n.splice(0,
                0, "core");
            for (var s = 0, t = n.length; s < t; s++) {
                var u = b._getJsListOfModule(p, n[s], f);
                u && (r = r.concat(u))
            }
            r = r.concat(h);
            cc.loader.loadJsWithImg(r, function(d) {
                if (d) throw Error(d);
                b._prepared = !0;
                a && a()
            })
        }))
    }
};
cc.game._initConfig();
Function.prototype.bind = Function.prototype.bind || function(a) {
    if (!cc.isFunction(this)) throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
    var b = Array.prototype.slice.call(arguments, 1),
        d = this,
        e = function() {},
        f = function() {
            return d.apply(this instanceof e && a ? this : a, b.concat(Array.prototype.slice.call(arguments)))
        };
    e.prototype = this.prototype;
    f.prototype = new e;
    return f
};
cc._urlRegExp = RegExp("^(?:(?:https?|ftp)://)(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))|(?:localhost))(?::\\d{2,5})?(?:/\\S*)?$", "i");
cc._LogInfos = {
    ActionManager_addAction: "cc.ActionManager.addAction(): action must be non-null",
    ActionManager_removeAction: "cocos2d: removeAction: Target not found",
    ActionManager_removeActionByTag: "cc.ActionManager.removeActionByTag(): an invalid tag",
    ActionManager_removeActionByTag_2: "cc.ActionManager.removeActionByTag(): target must be non-null",
    ActionManager_getActionByTag: "cc.ActionManager.getActionByTag(): an invalid tag",
    ActionManager_getActionByTag_2: "cocos2d : getActionByTag(tag \x3d %s): Action not found",
    configuration_dumpInfo: "cocos2d: **** WARNING **** CC_ENABLE_PROFILERS is defined. Disable it when you finish profiling (from ccConfig.js)",
    configuration_loadConfigFile: "Expected 'data' dict, but not found. Config file: %s",
    configuration_loadConfigFile_2: "Please load the resource first : %s",
    Director_resume: "cocos2d: Director: Error in gettimeofday",
    Director_setProjection: "cocos2d: Director: unrecognized projection",
    Director_popToSceneStackLevel: "cocos2d: Director: unrecognized projection",
    Director_popToSceneStackLevel_2: "cocos2d: Director: Error in gettimeofday",
    Director_popScene: "running scene should not null",
    Director_pushScene: "the scene should not null",
    arrayVerifyType: "element type is wrong!",
    Scheduler_scheduleCallbackForTarget: "CCSheduler#scheduleCallback. Callback already scheduled. Updating interval from:%s to %s",
    Scheduler_scheduleCallbackForTarget_2: "cc.scheduler.scheduleCallbackForTarget(): callback_fn should be non-null.",
    Scheduler_scheduleCallbackForTarget_3: "cc.scheduler.scheduleCallbackForTarget(): target should be non-null.",
    Scheduler_pauseTarget: "cc.Scheduler.pauseTarget():target should be non-null",
    Scheduler_resumeTarget: "cc.Scheduler.resumeTarget():target should be non-null",
    Scheduler_isTargetPaused: "cc.Scheduler.isTargetPaused():target should be non-null",
    Node_getZOrder: "getZOrder is deprecated. Please use getLocalZOrder instead.",
    Node_setZOrder: "setZOrder is deprecated. Please use setLocalZOrder instead.",
    Node_getRotation: "RotationX !\x3d RotationY. Don't know which one to return",
    Node_getScale: "ScaleX !\x3d ScaleY. Don't know which one to return",
    Node_addChild: "An Node can't be added as a child of itself.",
    Node_addChild_2: "child already added. It can't be added again",
    Node_addChild_3: "child must be non-null",
    Node_removeFromParentAndCleanup: "removeFromParentAndCleanup is deprecated. Use removeFromParent instead",
    Node_boundingBox: "boundingBox is deprecated. Use getBoundingBox instead",
    Node_removeChildByTag: "argument tag is an invalid tag",
    Node_removeChildByTag_2: "cocos2d: removeChildByTag(tag \x3d %s): child not found!",
    Node_removeAllChildrenWithCleanup: "removeAllChildrenWithCleanup is deprecated. Use removeAllChildren instead",
    Node_stopActionByTag: "cc.Node.stopActionBy(): argument tag an invalid tag",
    Node_getActionByTag: "cc.Node.getActionByTag(): argument tag is an invalid tag",
    Node_resumeSchedulerAndActions: "resumeSchedulerAndActions is deprecated, please use resume instead.",
    Node_pauseSchedulerAndActions: "pauseSchedulerAndActions is deprecated, please use pause instead.",
    Node__arrayMakeObjectsPerformSelector: "Unknown callback function",
    Node_reorderChild: "child must be non-null",
    Node_runAction: "cc.Node.runAction(): action must be non-null",
    Node_schedule: "callback function must be non-null",
    Node_schedule_2: "interval must be positive",
    Node_initWithTexture: "cocos2d: Could not initialize cc.AtlasNode. Invalid Texture.",
    AtlasNode_updateAtlasValues: "cc.AtlasNode.updateAtlasValues(): Shall be overridden in subclasses",
    AtlasNode_initWithTileFile: "",
    AtlasNode__initWithTexture: "cocos2d: Could not initialize cc.AtlasNode. Invalid Texture.",
    _EventListenerKeyboard_checkAvailable: "cc._EventListenerKeyboard.checkAvailable(): Invalid EventListenerKeyboard!",
    _EventListenerTouchOneByOne_checkAvailable: "cc._EventListenerTouchOneByOne.checkAvailable(): Invalid EventListenerTouchOneByOne!",
    _EventListenerTouchAllAtOnce_checkAvailable: "cc._EventListenerTouchAllAtOnce.checkAvailable(): Invalid EventListenerTouchAllAtOnce!",
    _EventListenerAcceleration_checkAvailable: "cc._EventListenerAcceleration.checkAvailable(): _onAccelerationEvent must be non-nil",
    EventListener_create: "Invalid parameter.",
    __getListenerID: "Don't call this method if the event is for touch.",
    eventManager__forceAddEventListener: "Invalid scene graph priority!",
    eventManager_addListener: "0 priority is forbidden for fixed priority since it's used for scene graph based priority.",
    eventManager_removeListeners: "Invalid listener type!",
    eventManager_setPriority: "Can't set fixed priority with scene graph based listener.",
    eventManager_addListener_2: "Invalid parameters.",
    eventManager_addListener_3: "listener must be a cc.EventListener object when adding a fixed priority listener",
    eventManager_addListener_4: "The listener has been registered, please don't register it again.",
    LayerMultiplex_initWithLayers: "parameters should not be ending with null in Javascript",
    LayerMultiplex_switchTo: "Invalid index in MultiplexLayer switchTo message",
    LayerMultiplex_switchToAndReleaseMe: "Invalid index in MultiplexLayer switchTo message",
    LayerMultiplex_addLayer: "cc.Layer.addLayer(): layer should be non-null",
    EGLView_setDesignResolutionSize: "Resolution not valid",
    EGLView_setDesignResolutionSize_2: "should set resolutionPolicy",
    inputManager_handleTouchesBegin: "The touches is more than MAX_TOUCHES, nUnusedIndex \x3d %s",
    swap: "cc.swap is being modified from original macro, please check usage",
    checkGLErrorDebug: "WebGL error %s",
    animationCache__addAnimationsWithDictionary: "cocos2d: cc.AnimationCache: No animations were found in provided dictionary.",
    animationCache__addAnimationsWithDictionary_2: "cc.AnimationCache. Invalid animation format",
    animationCache_addAnimations: "cc.AnimationCache.addAnimations(): File could not be found",
    animationCache__parseVersion1: "cocos2d: cc.AnimationCache: Animation '%s' found in dictionary without any frames - cannot add to animation cache.",
    animationCache__parseVersion1_2: "cocos2d: cc.AnimationCache: Animation '%s' refers to frame '%s' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.",
    animationCache__parseVersion1_3: "cocos2d: cc.AnimationCache: None of the frames for animation '%s' were found in the cc.SpriteFrameCache. Animation is not being added to the Animation Cache.",
    animationCache__parseVersion1_4: "cocos2d: cc.AnimationCache: An animation in your dictionary refers to a frame which is not in the cc.SpriteFrameCache. Some or all of the frames for the animation '%s' may be missing.",
    animationCache__parseVersion2: "cocos2d: CCAnimationCache: Animation '%s' found in dictionary without any frames - cannot add to animation cache.",
    animationCache__parseVersion2_2: "cocos2d: cc.AnimationCache: Animation '%s' refers to frame '%s' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.",
    animationCache_addAnimations_2: "cc.AnimationCache.addAnimations(): Invalid texture file name",
    Sprite_reorderChild: "cc.Sprite.reorderChild(): this child is not in children list",
    Sprite_ignoreAnchorPointForPosition: "cc.Sprite.ignoreAnchorPointForPosition(): it is invalid in cc.Sprite when using SpriteBatchNode",
    Sprite_setDisplayFrameWithAnimationName: "cc.Sprite.setDisplayFrameWithAnimationName(): Frame not found",
    Sprite_setDisplayFrameWithAnimationName_2: "cc.Sprite.setDisplayFrameWithAnimationName(): Invalid frame index",
    Sprite_setDisplayFrame: "setDisplayFrame is deprecated, please use setSpriteFrame instead.",
    Sprite__updateBlendFunc: "cc.Sprite._updateBlendFunc(): _updateBlendFunc doesn't work when the sprite is rendered using a cc.CCSpriteBatchNode",
    Sprite_initWithSpriteFrame: "cc.Sprite.initWithSpriteFrame(): spriteFrame should be non-null",
    Sprite_initWithSpriteFrameName: "cc.Sprite.initWithSpriteFrameName(): spriteFrameName should be non-null",
    Sprite_initWithSpriteFrameName1: " is null, please check.",
    Sprite_initWithFile: "cc.Sprite.initWithFile(): filename should be non-null",
    Sprite_setDisplayFrameWithAnimationName_3: "cc.Sprite.setDisplayFrameWithAnimationName(): animationName must be non-null",
    Sprite_reorderChild_2: "cc.Sprite.reorderChild(): child should be non-null",
    Sprite_addChild: "cc.Sprite.addChild(): cc.Sprite only supports cc.Sprites as children when using cc.SpriteBatchNode",
    Sprite_addChild_2: "cc.Sprite.addChild(): cc.Sprite only supports a sprite using same texture as children when using cc.SpriteBatchNode",
    Sprite_addChild_3: "cc.Sprite.addChild(): child should be non-null",
    Sprite_setTexture: "cc.Sprite.texture setter: Batched sprites should use the same texture as the batchnode",
    Sprite_updateQuadFromSprite: "cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
    Sprite_insertQuadFromSprite: "cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
    Sprite_addChild_4: "cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children",
    Sprite_addChild_5: "cc.SpriteBatchNode.addChild(): cc.Sprite is not using the same texture",
    Sprite_initWithTexture: "Sprite.initWithTexture(): Argument must be non-nil ",
    Sprite_setSpriteFrame: "Invalid spriteFrameName",
    Sprite_setTexture_2: "Invalid argument: cc.Sprite.texture setter expects a CCTexture2D.",
    Sprite_updateQuadFromSprite_2: "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null",
    Sprite_insertQuadFromSprite_2: "cc.SpriteBatchNode.insertQuadFromSprite(): sprite should be non-null",
    SpriteBatchNode_addSpriteWithoutQuad: "cc.SpriteBatchNode.addQuadFromSprite(): SpriteBatchNode only supports cc.Sprites as children",
    SpriteBatchNode_increaseAtlasCapacity: "cocos2d: CCSpriteBatchNode: resizing TextureAtlas capacity from %s to %s.",
    SpriteBatchNode_increaseAtlasCapacity_2: "cocos2d: WARNING: Not enough memory to resize the atlas",
    SpriteBatchNode_reorderChild: "cc.SpriteBatchNode.addChild(): Child doesn't belong to Sprite",
    SpriteBatchNode_removeChild: "cc.SpriteBatchNode.addChild(): sprite batch node should contain the child",
    SpriteBatchNode_addSpriteWithoutQuad_2: "cc.SpriteBatchNode.addQuadFromSprite(): child should be non-null",
    SpriteBatchNode_reorderChild_2: "cc.SpriteBatchNode.addChild(): child should be non-null",
    spriteFrameCache__getFrameConfig: "cocos2d: WARNING: originalWidth/Height not found on the cc.SpriteFrame. AnchorPoint won't work as expected. Regenrate the .plist",
    spriteFrameCache_addSpriteFrames: "cocos2d: WARNING: an alias with name %s already exists",
    spriteFrameCache__checkConflict: "cocos2d: WARNING: Sprite frame: %s has already been added by another source, please fix name conflit",
    spriteFrameCache_getSpriteFrame: "cocos2d: cc.SpriteFrameCahce: Frame %s not found",
    spriteFrameCache__getFrameConfig_2: "Please load the resource first : %s",
    spriteFrameCache_addSpriteFrames_2: "cc.SpriteFrameCache.addSpriteFrames(): plist should be non-null",
    spriteFrameCache_addSpriteFrames_3: "Argument must be non-nil",
    CCSpriteBatchNode_updateQuadFromSprite: "cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
    CCSpriteBatchNode_insertQuadFromSprite: "cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
    CCSpriteBatchNode_addChild: "cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children",
    CCSpriteBatchNode_initWithTexture: "Sprite.initWithTexture(): Argument must be non-nil ",
    CCSpriteBatchNode_addChild_2: "cc.Sprite.addChild(): child should be non-null",
    CCSpriteBatchNode_setSpriteFrame: "Invalid spriteFrameName",
    CCSpriteBatchNode_setTexture: "Invalid argument: cc.Sprite texture setter expects a CCTexture2D.",
    CCSpriteBatchNode_updateQuadFromSprite_2: "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null",
    CCSpriteBatchNode_insertQuadFromSprite_2: "cc.SpriteBatchNode.insertQuadFromSprite(): sprite should be non-null",
    CCSpriteBatchNode_addChild_3: "cc.SpriteBatchNode.addChild(): child should be non-null",
    TextureAtlas_initWithFile: "cocos2d: Could not open file: %s",
    TextureAtlas_insertQuad: "cc.TextureAtlas.insertQuad(): invalid totalQuads",
    TextureAtlas_initWithTexture: "cc.TextureAtlas.initWithTexture():texture should be non-null",
    TextureAtlas_updateQuad: "cc.TextureAtlas.updateQuad(): quad should be non-null",
    TextureAtlas_updateQuad_2: "cc.TextureAtlas.updateQuad(): Invalid index",
    TextureAtlas_insertQuad_2: "cc.TextureAtlas.insertQuad(): Invalid index",
    TextureAtlas_insertQuads: "cc.TextureAtlas.insertQuad(): Invalid index + amount",
    TextureAtlas_insertQuadFromIndex: "cc.TextureAtlas.insertQuadFromIndex(): Invalid newIndex",
    TextureAtlas_insertQuadFromIndex_2: "cc.TextureAtlas.insertQuadFromIndex(): Invalid fromIndex",
    TextureAtlas_removeQuadAtIndex: "cc.TextureAtlas.removeQuadAtIndex(): Invalid index",
    TextureAtlas_removeQuadsAtIndex: "cc.TextureAtlas.removeQuadsAtIndex(): index + amount out of bounds",
    TextureAtlas_moveQuadsFromIndex: "cc.TextureAtlas.moveQuadsFromIndex(): move is out of bounds",
    TextureAtlas_moveQuadsFromIndex_2: "cc.TextureAtlas.moveQuadsFromIndex(): Invalid newIndex",
    TextureAtlas_moveQuadsFromIndex_3: "cc.TextureAtlas.moveQuadsFromIndex(): Invalid oldIndex",
    textureCache_addPVRTCImage: "TextureCache:addPVRTCImage does not support on HTML5",
    textureCache_addETCImage: "TextureCache:addPVRTCImage does not support on HTML5",
    textureCache_textureForKey: "textureForKey is deprecated. Please use getTextureForKey instead.",
    textureCache_addPVRImage: "addPVRImage does not support on HTML5",
    textureCache_addUIImage: "cocos2d: Couldn't add UIImage in TextureCache",
    textureCache_dumpCachedTextureInfo: "cocos2d: '%s' id\x3d%s %s x %s",
    textureCache_dumpCachedTextureInfo_2: "cocos2d: '%s' id\x3d HTMLCanvasElement %s x %s",
    textureCache_dumpCachedTextureInfo_3: "cocos2d: TextureCache dumpDebugInfo: %s textures, HTMLCanvasElement for %s KB (%s MB)",
    textureCache_addUIImage_2: "cc.Texture.addUIImage(): image should be non-null",
    Texture2D_initWithETCFile: "initWithETCFile does not support on HTML5",
    Texture2D_initWithPVRFile: "initWithPVRFile does not support on HTML5",
    Texture2D_initWithPVRTCData: "initWithPVRTCData does not support on HTML5",
    Texture2D_addImage: "cc.Texture.addImage(): path should be non-null",
    Texture2D_initWithImage: "cocos2d: cc.Texture2D. Can't create Texture. UIImage is nil",
    Texture2D_initWithImage_2: "cocos2d: WARNING: Image (%s x %s) is bigger than the supported %s x %s",
    Texture2D_initWithString: "initWithString isn't supported on cocos2d-html5",
    Texture2D_initWithETCFile_2: "initWithETCFile does not support on HTML5",
    Texture2D_initWithPVRFile_2: "initWithPVRFile does not support on HTML5",
    Texture2D_initWithPVRTCData_2: "initWithPVRTCData does not support on HTML5",
    Texture2D_bitsPerPixelForFormat: "bitsPerPixelForFormat: %s, cannot give useful result, it's a illegal pixel format",
    Texture2D__initPremultipliedATextureWithImage: "cocos2d: cc.Texture2D: Using RGB565 texture since image has no alpha",
    Texture2D_addImage_2: "cc.Texture.addImage(): path should be non-null",
    Texture2D_initWithData: "NSInternalInconsistencyException",
    MissingFile: "Missing file: %s",
    radiansToDegress: "cc.radiansToDegress() should be called cc.radiansToDegrees()",
    RectWidth: "Rect width exceeds maximum margin: %s",
    RectHeight: "Rect height exceeds maximum margin: %s",
    EventManager__updateListeners: "If program goes here, there should be event in dispatch.",
    EventManager__updateListeners_2: "_inDispatch should be 1 here."
};
cc._logToWebPage = function(a) {
    if (cc._canvas) {
        var b = cc._logList,
            d = document;
        if (!b) {
            var e = d.createElement("Div"),
                b = e.style;
            e.setAttribute("id", "logInfoDiv");
            cc._canvas.parentNode.appendChild(e);
            e.setAttribute("width", "200");
            e.setAttribute("height", cc._canvas.height);
            b.zIndex = "99999";
            b.position = "absolute";
            b.top = "0";
            b.left = "0";
            b = cc._logList = d.createElement("textarea");
            d = b.style;
            b.setAttribute("rows", "20");
            b.setAttribute("cols", "30");
            b.setAttribute("disabled", !0);
            e.appendChild(b);
            d.backgroundColor = "transparent";
            d.borderBottom = "1px solid #cccccc";
            d.borderRightWidth = "0px";
            d.borderLeftWidth = "0px";
            d.borderTopWidth = "0px";
            d.borderTopStyle = "none";
            d.borderRightStyle = "none";
            d.borderLeftStyle = "none";
            d.padding = "0px";
            d.margin = 0
        }
        b.value = b.value + a + "\r\n";
        b.scrollTop = b.scrollHeight
    }
};
cc._formatString = function(a) {
    if (cc.isObject(a)) try {
        return JSON.stringify(a)
    } catch (b) {
        return ""
    } else return a
};
cc._initDebugSetting = function(a) {
    var b = cc.game;
    if (a !== b.DEBUG_MODE_NONE) {
        var d;
        a > b.DEBUG_MODE_ERROR ? (d = cc._logToWebPage.bind(cc), cc.error = function() {
            d("ERROR :  " + cc.formatStr.apply(cc, arguments))
        }, cc.assert = function(a, b) {
            if (!a && b) {
                for (var g = 2; g < arguments.length; g++) b = b.replace(/(%s)|(%d)/, cc._formatString(arguments[g]));
                d("Assert: " + b)
            }
        }, a !== b.DEBUG_MODE_ERROR_FOR_WEB_PAGE && (cc.warn = function() {
            d("WARN :  " + cc.formatStr.apply(cc, arguments))
        }), a === b.DEBUG_MODE_INFO_FOR_WEB_PAGE && (cc.log = function() {
            d(cc.formatStr.apply(cc,
                arguments))
        })) : console && console.log.apply && (cc.error = function() {
            return console.error.apply(console, arguments)
        }, cc.assert = function(a, b) {
            if (!a && b) {
                for (var d = 2; d < arguments.length; d++) b = b.replace(/(%s)|(%d)/, cc._formatString(arguments[d]));
                throw Error(b);
            }
        }, a !== b.DEBUG_MODE_ERROR && (cc.warn = function() {
            return console.warn.apply(console, arguments)
        }), a === b.DEBUG_MODE_INFO && (cc.log = function() {
            return console.log.apply(console, arguments)
        }))
    }
};
cc._initDebugSetting(cc.game.config[cc.game.CONFIG_KEY.debugMode]);
cc.loader.loadBinary = function(a, b) {
    var d = this,
        e = this.getXMLHttpRequest(),
        f = "load " + a + " failed!";
    e.open("GET", a, !0);
    cc.loader.loadBinary._IEFilter ? (e.setRequestHeader("Accept-Charset", "x-user-defined"), e.onreadystatechange = function() {
        if (4 === e.readyState && 200 === e.status) {
            var a = cc._convertResponseBodyToText(e.responseBody);
            b(null, d._str2Uint8Array(a))
        } else b(f)
    }) : (e.overrideMimeType && e.overrideMimeType("text/plain; charset\x3dx-user-defined"), e.onload = function() {
        4 === e.readyState && 200 === e.status ? b(null,
            d._str2Uint8Array(e.responseText)) : b(f)
    });
    e.send(null)
};
cc.loader.loadBinary._IEFilter = /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) && window.IEBinaryToArray_ByteStr && window.IEBinaryToArray_ByteStr_Last;
cc.loader._str2Uint8Array = function(a) {
    if (!a) return null;
    for (var b = new Uint8Array(a.length), d = 0; d < a.length; d++) b[d] = a.charCodeAt(d) & 255;
    return b
};
cc.loader.loadBinarySync = function(a) {
    var b = this.getXMLHttpRequest(),
        d = "load " + a + " failed!";
    b.open("GET", a, !1);
    a = null;
    if (cc.loader.loadBinary._IEFilter) {
        b.setRequestHeader("Accept-Charset", "x-user-defined");
        b.send(null);
        if (200 !== b.status) return cc.log(d), null;
        (b = cc._convertResponseBodyToText(b.responseBody)) && (a = this._str2Uint8Array(b))
    } else {
        b.overrideMimeType && b.overrideMimeType("text/plain; charset\x3dx-user-defined");
        b.send(null);
        if (200 !== b.status) return cc.log(d), null;
        a = this._str2Uint8Array(b.responseText)
    }
    return a
};
window.Uint8Array = window.Uint8Array || window.Array;
if (cc.loader.loadBinary._IEFilter) {
    var IEBinaryToArray_ByteStr_Script = '\x3c!-- IEBinaryToArray_ByteStr --\x3e\r\nFunction IEBinaryToArray_ByteStr(Binary)\r\n   IEBinaryToArray_ByteStr \x3d CStr(Binary)\r\nEnd Function\r\nFunction IEBinaryToArray_ByteStr_Last(Binary)\r\n   Dim lastIndex\r\n   lastIndex \x3d LenB(Binary)\r\n   if lastIndex mod 2 Then\r\n       IEBinaryToArray_ByteStr_Last \x3d Chr( AscB( MidB( Binary, lastIndex, 1 ) ) )\r\n   Else\r\n       IEBinaryToArray_ByteStr_Last \x3d ""\r\n   End If\r\nEnd Function\r\n',
        myVBScript =
        cc.newElement("script");
    myVBScript.type = "text/vbscript";
    myVBScript.textContent = IEBinaryToArray_ByteStr_Script;
    document.body.appendChild(myVBScript);
    cc._convertResponseBodyToText = function(a) {
        for (var b = {}, d = 0; 256 > d; d++)
            for (var e = 0; 256 > e; e++) b[String.fromCharCode(d + 256 * e)] = String.fromCharCode(d) + String.fromCharCode(e);
        d = IEBinaryToArray_ByteStr(a);
        a = IEBinaryToArray_ByteStr_Last(a);
        return d.replace(/[\s\S]/g, function(a) {
            return b[a]
        }) + a
    }
};
cc = cc || {};
cc._loadingImage = "data:image/gif;base64,R0lGODlhEAAQALMNAD8/P7+/vyoqKlVVVX9/fxUVFUBAQGBgYMDAwC8vL5CQkP///wAAAP///wAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFAAANACwAAAAAEAAQAAAEO5DJSau9OOvNex0IMnDIsiCkiW6g6BmKYlBFkhSUEgQKlQCARG6nEBwOgl+QApMdCIRD7YZ5RjlGpCUCACH5BAUAAA0ALAAAAgAOAA4AAAQ6kLGB0JA4M7QW0hrngRllkYyhKAYqKUGguAws0ypLS8JxCLQDgXAIDg+FRKIA6v0SAECCBpXSkstMBAAh+QQFAAANACwAAAAACgAQAAAEOJDJORAac6K1kDSKYmydpASBUl0mqmRfaGTCcQgwcxDEke+9XO2WkxQSiUIuAQAkls0n7JgsWq8RACH5BAUAAA0ALAAAAAAOAA4AAAQ6kMlplDIzTxWC0oxwHALnDQgySAdBHNWFLAvCukc215JIZihVIZEogDIJACBxnCSXTcmwGK1ar1hrBAAh+QQFAAANACwAAAAAEAAKAAAEN5DJKc4RM+tDyNFTkSQF5xmKYmQJACTVpQSBwrpJNteZSGYoFWjIGCAQA2IGsVgglBOmEyoxIiMAIfkEBQAADQAsAgAAAA4ADgAABDmQSVZSKjPPBEDSGucJxyGA1XUQxAFma/tOpDlnhqIYN6MEAUXvF+zldrMBAjHoIRYLhBMqvSmZkggAIfkEBQAADQAsBgAAAAoAEAAABDeQyUmrnSWlYhMASfeFVbZdjHAcgnUQxOHCcqWylKEohqUEAYVkgEAMfkEJYrFA6HhKJsJCNFoiACH5BAUAAA0ALAIAAgAOAA4AAAQ3kMlJq704611SKloCAEk4lln3DQgyUMJxCBKyLAh1EMRR3wiDQmHY9SQslyIQUMRmlmVTIyRaIgA7";
cc._fpsImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAAgCAYAAAD9qabkAAAKQ2lDQ1BJQ0MgcHJvZmlsZQAAeNqdU3dYk/cWPt/3ZQ9WQtjwsZdsgQAiI6wIyBBZohCSAGGEEBJAxYWIClYUFRGcSFXEgtUKSJ2I4qAouGdBiohai1VcOO4f3Ke1fXrv7e371/u855zn/M55zw+AERImkeaiagA5UoU8Otgfj09IxMm9gAIVSOAEIBDmy8JnBcUAAPADeXh+dLA//AGvbwACAHDVLiQSx+H/g7pQJlcAIJEA4CIS5wsBkFIAyC5UyBQAyBgAsFOzZAoAlAAAbHl8QiIAqg0A7PRJPgUA2KmT3BcA2KIcqQgAjQEAmShHJAJAuwBgVYFSLALAwgCgrEAiLgTArgGAWbYyRwKAvQUAdo5YkA9AYACAmUIszAAgOAIAQx4TzQMgTAOgMNK/4KlfcIW4SAEAwMuVzZdL0jMUuJXQGnfy8ODiIeLCbLFCYRcpEGYJ5CKcl5sjE0jnA0zODAAAGvnRwf44P5Dn5uTh5mbnbO/0xaL+a/BvIj4h8d/+vIwCBAAQTs/v2l/l5dYDcMcBsHW/a6lbANpWAGjf+V0z2wmgWgrQevmLeTj8QB6eoVDIPB0cCgsL7SViob0w44s+/zPhb+CLfvb8QB7+23rwAHGaQJmtwKOD/XFhbnauUo7nywRCMW735yP+x4V//Y4p0eI0sVwsFYrxWIm4UCJNx3m5UpFEIcmV4hLpfzLxH5b9CZN3DQCshk/ATrYHtctswH7uAQKLDljSdgBAfvMtjBoLkQAQZzQyefcAAJO/+Y9AKwEAzZek4wAAvOgYXKiUF0zGCAAARKCBKrBBBwzBFKzADpzBHbzAFwJhBkRADCTAPBBCBuSAHAqhGJZBGVTAOtgEtbADGqARmuEQtMExOA3n4BJcgetwFwZgGJ7CGLyGCQRByAgTYSE6iBFijtgizggXmY4EImFINJKApCDpiBRRIsXIcqQCqUJqkV1II/ItchQ5jVxA+pDbyCAyivyKvEcxlIGyUQPUAnVAuagfGorGoHPRdDQPXYCWomvRGrQePYC2oqfRS+h1dAB9io5jgNExDmaM2WFcjIdFYIlYGibHFmPlWDVWjzVjHVg3dhUbwJ5h7wgkAouAE+wIXoQQwmyCkJBHWExYQ6gl7CO0EroIVwmDhDHCJyKTqE+0JXoS+cR4YjqxkFhGrCbuIR4hniVeJw4TX5NIJA7JkuROCiElkDJJC0lrSNtILaRTpD7SEGmcTCbrkG3J3uQIsoCsIJeRt5APkE+S+8nD5LcUOsWI4kwJoiRSpJQSSjVlP+UEpZ8yQpmgqlHNqZ7UCKqIOp9aSW2gdlAvU4epEzR1miXNmxZDy6Qto9XQmmlnafdoL+l0ugndgx5Fl9CX0mvoB+nn6YP0dwwNhg2Dx0hiKBlrGXsZpxi3GS+ZTKYF05eZyFQw1zIbmWeYD5hvVVgq9ip8FZHKEpU6lVaVfpXnqlRVc1U/1XmqC1SrVQ+rXlZ9pkZVs1DjqQnUFqvVqR1Vu6k2rs5Sd1KPUM9RX6O+X/2C+mMNsoaFRqCGSKNUY7fGGY0hFsYyZfFYQtZyVgPrLGuYTWJbsvnsTHYF+xt2L3tMU0NzqmasZpFmneZxzQEOxrHg8DnZnErOIc4NznstAy0/LbHWaq1mrX6tN9p62r7aYu1y7Rbt69rvdXCdQJ0snfU6bTr3dQm6NrpRuoW623XP6j7TY+t56Qn1yvUO6d3RR/Vt9KP1F+rv1u/RHzcwNAg2kBlsMThj8MyQY+hrmGm40fCE4agRy2i6kcRoo9FJoye4Ju6HZ+M1eBc+ZqxvHGKsNN5l3Gs8YWJpMtukxKTF5L4pzZRrmma60bTTdMzMyCzcrNisyeyOOdWca55hvtm82/yNhaVFnMVKizaLx5balnzLBZZNlvesmFY+VnlW9VbXrEnWXOss623WV2xQG1ebDJs6m8u2qK2brcR2m23fFOIUjynSKfVTbtox7PzsCuya7AbtOfZh9iX2bfbPHcwcEh3WO3Q7fHJ0dcx2bHC866ThNMOpxKnD6VdnG2ehc53zNRemS5DLEpd2lxdTbaeKp26fesuV5RruutK10/Wjm7ub3K3ZbdTdzD3Ffav7TS6bG8ldwz3vQfTw91jicczjnaebp8LzkOcvXnZeWV77vR5Ps5wmntYwbcjbxFvgvct7YDo+PWX6zukDPsY+Ap96n4e+pr4i3z2+I37Wfpl+B/ye+zv6y/2P+L/hefIW8U4FYAHBAeUBvYEagbMDawMfBJkEpQc1BY0FuwYvDD4VQgwJDVkfcpNvwBfyG/ljM9xnLJrRFcoInRVaG/owzCZMHtYRjobPCN8Qfm+m+UzpzLYIiOBHbIi4H2kZmRf5fRQpKjKqLupRtFN0cXT3LNas5Fn7Z72O8Y+pjLk722q2cnZnrGpsUmxj7Ju4gLiquIF4h/hF8ZcSdBMkCe2J5MTYxD2J43MC52yaM5zkmlSWdGOu5dyiuRfm6c7Lnnc8WTVZkHw4hZgSl7I/5YMgQlAvGE/lp25NHRPyhJuFT0W+oo2iUbG3uEo8kuadVpX2ON07fUP6aIZPRnXGMwlPUit5kRmSuSPzTVZE1t6sz9lx2S05lJyUnKNSDWmWtCvXMLcot09mKyuTDeR55m3KG5OHyvfkI/lz89sVbIVM0aO0Uq5QDhZML6greFsYW3i4SL1IWtQz32b+6vkjC4IWfL2QsFC4sLPYuHhZ8eAiv0W7FiOLUxd3LjFdUrpkeGnw0n3LaMuylv1Q4lhSVfJqedzyjlKD0qWlQyuCVzSVqZTJy26u9Fq5YxVhlWRV72qX1VtWfyoXlV+scKyorviwRrjm4ldOX9V89Xlt2treSrfK7etI66Trbqz3Wb+vSr1qQdXQhvANrRvxjeUbX21K3nShemr1js20zcrNAzVhNe1bzLas2/KhNqP2ep1/XctW/a2rt77ZJtrWv913e/MOgx0VO97vlOy8tSt4V2u9RX31btLugt2PGmIbur/mft24R3dPxZ6Pe6V7B/ZF7+tqdG9s3K+/v7IJbVI2jR5IOnDlm4Bv2pvtmne1cFoqDsJB5cEn36Z8e+NQ6KHOw9zDzd+Zf7f1COtIeSvSOr91rC2jbaA9ob3v6IyjnR1eHUe+t/9+7zHjY3XHNY9XnqCdKD3x+eSCk+OnZKeenU4/PdSZ3Hn3TPyZa11RXb1nQ8+ePxd07ky3X/fJ897nj13wvHD0Ivdi2yW3S609rj1HfnD94UivW2/rZffL7Vc8rnT0Tes70e/Tf/pqwNVz1/jXLl2feb3vxuwbt24m3Ry4Jbr1+Hb27Rd3Cu5M3F16j3iv/L7a/eoH+g/qf7T+sWXAbeD4YMBgz8NZD+8OCYee/pT/04fh0kfMR9UjRiONj50fHxsNGr3yZM6T4aeypxPPyn5W/3nrc6vn3/3i+0vPWPzY8Av5i8+/rnmp83Lvq6mvOscjxx+8znk98ab8rc7bfe+477rfx70fmSj8QP5Q89H6Y8en0E/3Pud8/vwv94Tz+4A5JREAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfcAgcQLxxUBNp/AAAQZ0lEQVR42u2be3QVVZbGv1N17829eRLyIKAEOiISEtPhJTJAYuyBDmhWjAEx4iAGBhxA4wABbVAMWUAeykMCM+HRTcBRWkNH2l5moS0LCCrQTkYeQWBQSCAIgYRXEpKbW/XNH5zS4noR7faPEeu31l0h4dSpvc+t/Z199jkFWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhY/H9D/MR9qfKnLj/00U71aqfJn9+HCkCR/Wk36ddsgyJ/1wF4fkDfqqm9/gPsUeTnVr6a2xlQfnxdI7zs0W7irzD17Ytb2WT7EeNv/r4ox1O3Quf2QP2pgt9utwfout4FQE8AVBSlnaRmfvAURQkg2RlAbwB9AThlW5L0GaiKojhJhgOIBqDa7XaPrusdPtr5kQwF0BVAAoBIABRCKDd5aFUhRDAAw57eAOwAhKIoupft3zoqhB1AqLwuHIBut9uFt02qqvqRDJR2dAEQJj/BAOjn56dqmma+xiaECAEQAWAggLsB6A6HQ2iaZggBhBAqgEAAnQB0kzaEmT4hAITT6VQ8Ho/HJAKKECJQtr8LwD1y/A1/vcdfEUIEyfZ9AcQbYvZ942Px88L2UwlJR0dH0EMPPbRj5syZPUeNGrXR7Xb/641xIwJ1XY9NSUlZm52dfW+XLl1w8uRJzJ8//+OGhoYJqqqe1TSt1Wsm9NN1PSIqKmr12rVrR5WUlHy1bdu2AQCumWc3IYRD1/UwVVXnFRQUTIuNjUVzczN2797dWFJSkq8oymZd15sAGAEnFEUJ1nX9nzIzM1dnZmZGh4SE4OTJk5g5c+Zf29vbp9pstrMej6fVOyhIhgAYU1hY+B+hoaGoqKg4XVlZea+XTULTNFdCQsLGiRMnPuR2u3UhBOV9eeDAAWXTpk095DUe6WsoyRE5OTlr0tLSAux2O/bs2cO5c+e+pijKUpIXSHaQVAGkvPLKK++6XK4OksJLCFlXV2cvKSlJBFAjhU+x2WwhHo9nUHp6+urMzMy7wsLCUF9fjxdffPHjxsbGiTab7WuPx9NiEutOuq4PyMjI+M+srKyYqKgoHD58GDNmzNjq8XhyVFU9b/q+LH7hBAEYu3PnTlZVVRFAGgCX6f/tAHoOHDjwa0p27txp/JO9e/f+QM7cipw9nfL3kQBKt2zZQpJ87rnn6mQmoHilw2EACs+cOUOSrK+vZ1NTE0nyo48+IoBpxswoBcMJ4Ndjx471kOTFixe5d+9ekqTH42H//v13A4jyzpAURfEH0H/OnDnthu1z5sw558MmFUCPWbNmnaMP3nrrLZoyDmP8Hl68eDFJ8siRI9/Yc+zYMQKYKdtAztrTrl27xptRXV1NAKMAOAyBBBA/Y8aMdpLs6Ojgxx9//E37+++//29yvFXppwvAwMcee8xjtDHsuXLlCqOjo//ia3wsfpkoALqFhoZuIckJEyackimm3dQmEMDUmpoakmRISMhhAHOHDx/eQJIbN24kgKEyMAHAFRMTs2XXrl1saWkhSZ0kp0+ffhrAr3wEW/S8efOukORLL72kA1gKYMPWrVtJkk899dRJAHeYrgsEsIQkjx8/TgDvAPjd448/3kaSb7zxBmUa7vC6z53BwcFbSHL9+vU6Sc6aNes8gF5ewWAH0PfVV18lSQL4DMBGIcQ6AKtcLleBFC2jXtFt8ODBe0iyoqKCAJYByC8qKmJDQwOzsrK+MAmqo1OnTveHhoa+GRkZ+XZkZOSWiIiIvzgcjk9mzpypkWRmZuZpmbYbGV4AgPnNzc1sa2sjgN0A5iQmJtaSZHl5OQHcb/K3s81mW0uSTU1NBFAFYFbfvn1Pk+Tbb79NAA8IIVzW42/hByA+Pz/fLR/2ZXIda05NI/z9/TeR5J49ewhgqlxTrtI0jY2NjQQw3zTLuWJiYjaUlJToS5Ys6fjkk080kwDEeAmADcA9GzZsIElGRUW9CyAWwLApU6Y0kOSKFSsog9QICGdERMTGsrIyZmVlEcC9AB4IDw/fTpLbtm0jgN94CUAnAJmVlZVcs2aNZ/LkyRdJcvbs2b4EwAkgZfPmzTxw4AABFAN4BkC6vFeUSewcAO5duXIlSTIhIaEawGMAxgKYAmAGgCS73e5vrKVk/yGythANYEhCQsIhkly+fDkBpKqqGmL6DgIALDKN/3yZpVWQZGVlJQE8aPI3KiMjo5okV61aRQAjAPQBMPfIkSN0u90EUCBtsPiFEwpgbn19PdetW2fM5N4zQ9ekpKQqkty0aRMBpMjiWM6JEydIkoqirJUFJ6iq6pAPVy8A6cZMehMBUACEuVyuFwG8HBwcPEIWx367ZMkSjSQXLVrUJouTRorrkAHdA8BdQogsAOsKCwtJkmPGjDkvMw2bDDo/ADEjRoz4XylyFbm5uY0mAbjLyyZ/AOOrq6tZVlbWsWDBgo69e/eyoqKCgwcPPg4gSQaoIRbp27dvN7KF+tLSUr28vJwFBQXtMpvpYRIM7+wrAkDeqVOnePbsWQIoNKfzpiXPg8uXLydJJicnNwF4f+nSpW6STEtLq5fjYwhk1wkTJtSQ5Ouvv04AqTKj+N2xY8dIkgEBAW/Ie1v8wncRegwZMmQvSfbr12+3Ua33WqPfOWbMmP0kWVpaSgCDZAqcfejQIWNZsEGKgvnh9gfQb9myZd8nAEJVVZtMkUNk8CcNHTq0liR1XWdYWNhmH1mJIme80OnTp18x1rp5eXkEsNJms92Fb7e/IgEsvHz5Mp999tkmAI/l5uZeMC0B7vEqqAYAyL106RJJsra2lpWVld+sucePH38ZQG+5NncBeOrgwYMkqbe3t/Po0aOsra011wAWyl0H7x0JJ4DE+fPnu0kyPT29DsDdUrBuyNKEEAkAdpw/f/6GeoEM8GUmfwEgPCIiopwkGxsbabPZPgOw6L777vvm4p49e26VGYjFLxUhhD+ApLKyMp44ccIoVnXybgbgzkcfffRzklyzZg0BDJYCMMmoCwQFBXkLgLGWvvcWAgBToSsKwNPTp09vMR7UuLi4rwH0lgU8c/Db5ezbeeTIkRWzZ8++aMxu+fn5BPCADBwHgP4LFy701NXVEUAJgAnPP/98kyxMNgHo53A4zH77BQQETMvPz7+Um5vbBuAlAFMSExPPmdbVL0qh8Acw8fDhw5SCchVAEYAVb775JknyhRdeaJYztHfxMwLAaqNwCGC2FArv8x0hAHKNLGPKlCme5OTk/Zs3bzb7O0wKiiG8KXl5ed8IxenTp0mSR48e1UmyW7duWywBuD2xyQcgFECgoih+8H1gyJgZV5Lkyy+/3CbTRIePtl2HDBmyw1QBHyGDdXZdXR1JUghRKkXBjOMHCoBdpr0L3nvvPZLkF198wejo6O0A4lVVDTb74HQ6AwD8Wq7Jh8rgGgDgQ13XjVR8qaxJuADMbmlpYXl5uV5UVNRWUFDgfv/993Vj/ZydnU1c37eHXML4S3viAcQqitJD2l104cIFY8lTKsXSBWBMVVWVcd9yed2A1NTUQ6Zl00CvLMMOoHdubm6zFIlWOf5+PsY/Kj09vdrU11QAwwGsv3jxIk21m2DZr10I0RXAuAcffPBgaWkpV69eTYfDcdiwUxY0w6xw+flX8L1xApjevXv3lREREaW6rofB93aPDUDQpEmTMgHgtddeqwBwEd/utZvpqK6uPgEAcXFxkA94NwB9unfvjrNnz4LklwDcf08iIqv66Zs2bXrl4YcfxooVKxAbG7uqrq5uAYA2TdOEqqpGYIi2tjbl6aeffu/YsWPv5uTk7JaC1wHg4Pnz542MwoVvTx+21dbWYvjw4WLixIl+2dnZ9lGjRgmSTE1NRUpKCkwFTGiaxtTU1OXTpk3707Bhw/6g67pDipnT4biuj7qut+Lbk3Vf1tTUXI9qu91Pjq1QFEUBgJaWFgBo8yGOQ8eNGxcAAOvXr/8QwBUfYygAKL169eoCABcuXACAWtn2hOGv0+kMNO1KiPDw8F4A4rZv3/7R1KlTR0+bNu1ht9u9r1+/fqitrQXJgwDarRC6/QjPzs4+QJIffPCB9/aQmSAA43ft2mW0e1QGoi8CAPyLsZccExNTC2BlRkbGRdOyYJCP2csBIN6UAZzCd7cBbQCijYp/dXU1ExMTz6SmptaMHj36f9LS0vYlJCRsl6mxIWSdu3fv/g5J7t+/nwC2AShMTk6+SJKff/45AWRLYbD7+fndAeDf5BJnLoCCyZMnt5JkdnZ2C4B/F0KEm1Pu+Pj4rST55ZdfEsBWAK+mpaVdMo3raDn7KwDuSEpK+m+S3LBhAwG8DuCtHTt2UBbpjgC408vvcFVV15HkuXPnjMp+p5uMf0RcXNyHJNnQ0EBVVfcCWBQXF3fG+Jv0yxABPwB5LS0tRmFxN4BlTzzxxGWSXLx4sS5F3GGFy+1Hp5SUlJq6ujoWFxdTpsZ2H+0iIyMj/0iSWVlZX5mr5jfJFroPGzasxlhTnjp1iiTZ3NxMl8tlrCd9pfa9SkpKSJI5OTmnZOageLUZZqxvfVFWVkZcPwdgNwnSCKPqb17jkmR8fPzfZMDZ5CRsFBmNI7h95s2b1yhT7/MAYmStwCx4vy0uLqa3v5qmEcCfvSr1QQAeXb16NY3Cm3HQ55133iGAp+SxZTNhKSkpfzUddkrFjYevzAQCeGjp0qXfsYckY2NjTwD4leGDLCL2HTdunNtoY+zWSHFcIHdsFCtcfuZ1vO9Eqs3m7/F47sb1k2qX/f3997W2tl7BjWfpBYDOzzzzzIVJkyZh0KBBCwEsB3AJvl9AETabLcDj8dwRFRW1ctasWb8JCgpSzp07d62wsPC/Wltb8xRFadR1/ZqPXYbgAQMGbI2Pjw/+6quv9ldVVT0r01ezuPRJSUn5Y9euXXVd11WzDaqq6kePHm3+7LPPRgO4KlNuxWazhXo8nuTk5OSXMjIyEl0uFxoaGtqKior+dPXq1VdUVT0jj7r68ieoT58+vx8yZMjdx48fP1JVVTVF9m20VW02WyfZf97YsWPjXS4X6urqWvPy8jYCWCyEuEDS8FdVFKWzruv//OSTTy5OTk7uqWkaPv3007qysrJ8RVH+LI8ym8/rB3Tu3HnRI488knLo0KG2ffv2ZQI4C98vP6mqqoZqmpaclpa2cOTIkX39/f3R0NDQUVxc/G5TU9PLqqrWa5rWLH1QVFUN0TStX1JSUvH48eP7BwYG4uDBg1cKCgpeBbBe2u+2Qug2EwD5N5sMPuNtMe8XP4TT6Qxoa2sbIGeXvUKIK7d4IISiKC5d1wPljOfA9bPwzYqiXNV13dd6Uqiq6qdpml2mpe02m63d4/G4vcTF5fF47LJf71nJA6BZVVW3pmntuPHlmAD5wk6Q9NnbHp9vHaqq6tA0zU/64PZhk1FfCZB9G/23ALiqKEqzD39tpvbGUqoFwFUhRLP3yzpCCDtJpxyXDulfG27+pqRR3DXsUWVd4Yq0x/taVQjhIhksC8L+ABpM9ljBf5sKwI8pIBr75L5E4vvu+UNeG/a+hv+AL7yFH8qPtOfHjtOP6V/Bja8D6z/B2Nys/1u9Xv33tLf4GfF/LC4GCJwByWIAAAAASUVORK5CYII\x3d";
cc._loaderImage = "data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAAAlAAD/4QMpaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjAtYzA2MCA2MS4xMzQ3NzcsIDIwMTAvMDIvMTItMTc6MzI6MDAgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjM4MDBEMDY2QTU1MjExRTFBQTAzQjEzMUNFNzMxRkQwIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjM4MDBEMDY1QTU1MjExRTFBQTAzQjEzMUNFNzMxRkQwIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDUzUgV2luZG93cyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkU2RTk0OEM4OERCNDExRTE5NEUyRkE3M0M3QkE1NTlEIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkU2RTk0OEM5OERCNDExRTE5NEUyRkE3M0M3QkE1NTlEIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+/+4ADkFkb2JlAGTAAAAAAf/bAIQADQkJCQoJDQoKDRMMCwwTFhENDREWGhUVFhUVGhkUFhUVFhQZGR0fIB8dGScnKionJzk4ODg5QEBAQEBAQEBAQAEODAwOEA4RDw8RFA4RDhQVERISERUfFRUXFRUfKB0ZGRkZHSgjJiAgICYjLCwoKCwsNzc1NzdAQEBAQEBAQEBA/8AAEQgAyACgAwEiAAIRAQMRAf/EALAAAAEFAQEAAAAAAAAAAAAAAAQAAgMFBgcBAQEAAwEBAAAAAAAAAAAAAAAAAQMEAgUQAAIBAgIEBwoLBgQGAwAAAAECAwAEEQUhMRIGQVFxsTITFGGBwdEiQlKSMzWRoeFicqKyI1NzFYJjJDQWB9KjVCbxwkNkJWXik3QRAAIBAgMFBQcDBQEAAAAAAAABAhEDIRIEMUFRcTJhwVIUBZGhsSJyEzOB0ULhYpIjUxX/2gAMAwEAAhEDEQA/AMJSpUqAVKlXuFAeUq9wpUB5XuFe4V6ooDzZHDox0CnGMinzwl7Z8NajaHeoO3vmTBZBtp9YUIqTEV5ROxHKnWRnaU8VRMhFBUjpV7hSoSeUq9pUB5Sr2lhQHlKvcK8oBV7hSFSRrtaKAZs07YNPM1pG2xJIAw1jSeandry/8X4m8VCKkWwaWwam7Xl/4v1W8VLtmX/i/VbxUoKkWwakSM407tmX/i/VbxUmzGwjQsjdY41IARie/U0IbZO0kNtCXnOCkEBeFu4KI3Bs7DNb27ya+jDx3kJeEnpJJEcQVbWDsk17u5urd591ucZkWhym2Vnd9RkCDEpFxDRpbw0bunu5mlp2De2FMLYXOD2wB2xbOeraUcYGJ72mlSUiqzzdzMd3Z3mixltA2yzcK/NlHM1DQyRXce1HocdNOEfJXZ88y9ZojOqhiBszIRiHQ8Y4cK5TvHuzLljHNMqxNoDjLFraHHnjPxcNCGVbxEUzYNTx5jZSxhpW6qTzlwJ+DCvO2Zf+L9VvFSgqyHYNLYNTdssPxfibxUu15f8Ai/VPiqCakOwa82DU/a8v/F+JvFTDdWPBL8R8VKCvYRYV5UzoMAy6QdIIqI0B4KJtxiRQwou16QoGUkntH5Tz0RbZbmF2hktraSVBo2lUkY8tDye0flPPXTslVUyiyVRsjqUOA4yMT8dW2ram2m6UVTNq9S7EIyUVJydMTn/6DnP+im9Wl+g5z/opvVrpteEhQWY4AaSTwAVf5WPiZh/9S5/zj7zltzlmYWkfWXNvJDGTgGcYDHirR7i7mSbwXParsFMrgb7w6jKw/wCmnc9I14kF3vpvCljbMyWMOJL4aEiB8qU/ObUK7HYWVrl1pFZWiCOCBQqKOLjPGTrNZZqKbUXVHq2nNwTuJRk1VpbgXN8s7Rk5ym0UQQzhIG2NAjhxHWbI+gCBVjBBFbwxwQqEiiUJGg1BVGAFe7dV28WYLYZFmF2Th1UD7JGjymGyn1iK5OyzIBGB1HgrLZhamzumQAGJwSqnSCh1q3GOCodxt4cxurdcpzuN4cyhiWaF5Bg09udUmnWw1H/jV9nFuJ7Quo+8h8peThFA+047vduyMtk7fYqTl07YFdfUufMPzT5p71UdtlmYXaGS2t3mQHAsgxANdadYJopLe4QS2867EsZ4QfCNYrCFbjdDPmgkYyWFxgVf04ifJf6ScNdRUW1XBb6FU5TjF5EpSSrGu/s5lN+g5z/opvVpfoOc/wCim9WtdHnatvObJXDW7xLGhB8nrPaY9/HCr+tEdPCVaSeDoYLnqF63lzW4/PFSW3ecxbI84VSzWUwUaSdg0DXXK5nvAipnd6qgKvWnQO7pri9ZUEmm3Vl2j1kr8pRlFRyquBNZjGxQ/S56Y1S2fu9OVueon11Szahoou06QoQUXadIVCD2FJJ7R+U89dMydv8Axdn+TH9muZye0flPPXQstlK5Tbka1gUjlC1q0vVLkeb6r+O3Tx9xcY1nt8c0NrZCyiOE1108NYjGv1joo7Js1jzKyScYLIvkzL6LDwHXVJksH9Sb49dKNq0tj1jA6uriOCL+02FWX7iVtZX1/AzaHTyeoauKn2MX9W79zebiZCuR5MjSrhfXuEtwTrUeZH+yNfdrRNcxI6IzhXlJEak6WIGJ2Rw4ChWnChndtlVBLMdQA0k1gbXNMzzDfDLs6mjaPKppJbWwJ1bOwwxw43OnHh71YT3DpfWUJmFlb5jHHDdeXBHIsrRea5TSqvxqG04cNN62vetoCS4tre5mgnkGE9q+3DKOkuI2WX6LDQRRHWDh1UCtwj7QRg2wdl8Djgw1qe7XvW0BQ3kfZ7mSLgU+T9E6RVbnuVrnWVSWqj+Lt8ZbRuHEdKPkYVcZ2MJY5fSGyeVar45+rkWQHAqccalPE5km1htWK5nK4Wnt5FuUBUwOMG4nGkA/BXUrW4S6torlOjMgcd/xVn7rLo7zKs0uEjCNeSvdwoBhgsZxX1l2j36k3Lu+uyprdj5Vs5A+i/lD48a0aaVJOPi7jB6lbzWozpjB48pf1NDXNN4vfl7+Z4BXS65pvF78vfzPAK71XTHmZ/S/yT+jvJ7L3fHytz1E+upbL+Qj5W56jfXWRnsIYKLtekKEFGWvSFQgyjk9o/Keet3YthlMP/5x9msJJ7R+U89biyb/AMXEv7gD6tadL1T+kwepRrC39ZkLDMbiwMvUHRPG0bjlGg8ore/23sxBldxfMPLupNhT8yL/AORNZbdzJ484scytxgLqJY5LZj6Q2sV5G1Vud1mjjyG0ij0NEGSZToKyhjtqw4waztuiXA3qKTbSxltfGhbZlE95ZtZqxVbgiOZhrER9ph3Svk9+pJILZ4Y4DGBFCUMKjRsGPobPFhUfW0NJmljE2xJcIrcI2vFUEln1lRXd6lrazXT9GCNpD+yNqoI7mOVduNw6nzlOIoPOUa6yye1XXcbMR5GdQ3xY0BSbj31/FcTQZirJ+q431q7anbHCTZ72Bw7lbPrKBMcBWNNgbMBBh+bsjBdni0VJ1lARZs6yWiupxCuMDy6KpS2IwOo6DTr3Mre3e5tZZVUM4ZBjqOOJoWO4jkXajcOOMHGgDISvWIrdAkKR80+TzVl908bPPL3LzxOuHdifxVfiTAg92qI/w+/8gGgSyN/mR7XPVlp0lF/3L3mbVKtu5Hjbk/8AHE2Fc03i9+Xv5ngFdKNc13i9+Xv5ngFaNV0x5nn+l/kn9HeEWXu+PlbnqJ9dS2Xu9OVueon11kZ7CGCjLXpCgxRlr0hUIPYUcntH5Tz1s8vb+Bt1/dqPirGSe0flPPWusG/g4Py15q06XqlyMWvVYQ+ruI9xJOqzO9hOto/sP8tbGOFIrmWeM7IuMDMnAXXQJOUjQeOsJk0nY96ip0CYunrjaHx1t+srPJUbXBm2LrFPikwTOb+T+VhbZxGMrDXp83x1QSy2tucJpUjPETp+Cn5/ftaRvKvtp3Kx48HG3erHMzOxZiWZtLMdJNQSbbL71Vk6yynViOkqnEEfOWtPbXi3EQkGg6mXiNckjeSJxJGxR10qw0GtxuxmvbImD4CZMFlA4fRfv0BqesqqzTMZNMEDbIHtHH2QeCiZJSqMQdOGiue53mz3czQwsRbIcNHnkec3c4qAMuriz68gTIToxwOOnlp0MjxMJYW741Gs3RVldtbygE/dMcHX/moDaxTiWNZB53B3arb8/wC+4SOF4sf/AKxU9kcBsfOGHfoUHtG/RbzY5Die5HHhXdvavqiZ9Q8Jdlq4/gbKua7xe/L38zwCuhpf2Uk/Zo50kmwJKIdogDjw1VzzeL35e/meAVp1LTgqY4nn+mRauzqmqwrjzCLL3fHytz1E+upLL+Qj5W56jfXWRnroYKLtekKEFF2vSFQg9hSSe0flPPWosm/hIfoLzVl5PaPynnrRWb/w0X0F5q06XqlyM2sVYx5gmbFre/t71NY2T+0h8VbSO5SWNJUOKSAMp7jDGspmMPaLRlXS6eWve1/FRO7WYdbZm1Y/eW/R7qHxHRXGojlm3ulid6aVbaW+OALvgCLq2Hm9WxHKWqjhj6xsK1e8dm15l4niG1LZkswGsxtrPeOmsvayBJA1VItlWjptLuTdPMo7LtjRDq9naK4+WF9IrUW7BaHOljGqVHB7w2hzVoZt87d8vaNYSLl02CcRsDEbJbj71Uu7UBkvJ7/D7q2QoDxySaAO8MTXdxRVMpRp5XZOWdF/ms7R5XdyKfKWJsO/5PhrG5XlNxmEywW6bTnTxAAcJNbGSMXkM1pjgbiNo1PziPJ+Os7u7m/6ReM00ZOgxSpqYYHT3wRXMKN4ll9zUG4bQfNshu8sZVuEA2hirA4qe/VOwwrVbzbww5mI44UKRRYkbWG0S3JWctbd7u5WFfOOLHiUdJqmaipfLsIsObhWe001lMkMVvJNjhghIALMcBxCs7fxXQmkupx1bXDswGPlaTidVaEyKNXkoo4eBV+Sq7L7Vs9zcBgeyQ4GQ/MB1crmoim2orezqcowTuSeEY48jQ7oZX2PLzdyLhNd6RjrEY6I7+uspvH78vfzPAK6UAAAFGAGgAcArmu8Xvy9/M8ArTfio24RW5nnaG67uou3H/KPuqT2X8hHytz1G+upLL3enK3PUb66ys9RDBRdr0hQgou06QqEGUkntH5Tz1e238vF9BeaqKT2j8p56vbb+Xi+gvNWjTdUuRn1XTHmTh8KrJTJlt8t1CPIY44cGnpJVjTJYkmjaN9Ib4u7V923njTethRauZJV3PaW1rfLIiXEDYg6R4VYc9CXW7thfOZbKdbGZtLW8uPVY/u3GrkNUkM9zlcxUjbhfWOA90cRq4gv4LhdqN+VToNYWmnRm9NNVWNTyHc6VWBv8wt4YeHqm6xyPmroq1Z7WGFLSxTq7WLSuPSdjrkfumq5yHXDUeA92oO2SKpVumNAaoJLMXH3myp0rpJ4uKhc3tbDM5BMri1zAj79j7KTiY8TcdBpcsith0286o+sPCagEX9Pzg4zXUCp6QYse8oouCG3tk6m1BYv05W6T+IdyolxbHDAAa2OgDlNCz3ryN2WxBd5PJMg1t81eId2ukqnLlTBbfcuY+9uJLiRcvtPvHdsHK+cfRHcHDWsyawjyy0WBcDI3lTP6TeIcFV+S5OmXx9bJg1048o8Cj0V8Jq2DVu09nL80up7OxHi+oal3P8AXB/IsZS8T/YOV65zvCcc7vfzPAK3ivWCz445zeH954BXOr6I8yfSfyz+jvCLP3fHytz1G+upLP3fHytz1E+usbPaQ0UXadIUIKLtekKhB7Ckk9o/Keer22/l4/oLzVRSe0flPPV7b/y8X0F5q0abqlyM+q6Y8yQsBTDMor1o8aiaE1pbluMqS3sbLLHIhSRQyngqukhaJ9uBjo+H5aOa3ao2t34qouRlLajTalGP8v0IY8ylXQ+PKPFU/bYXOLPge6CKia0LaxTOxHu1Q7cuBd9yPEJ7TbjXKO8CajbMIF6CNIeNvJHjqIWJ7tSpYkalqVblwIdyG+RGXur0hXYJFxal+Dhq5y3slkv3Y2pD0pTr+QUClpJRUdo9XW4OLrTHtM16cZLLWkeC7y4jvlNEpcRtw1Ux27Ci448NZrTFy3nn3IQWxlgGrDZ3pza7/M8ArZo+ArF5171uvp+CqdV0R5l/psUrs2vB3hdl7vTlbnqJ9dS2Xu+PlbnqJ9dY2eshooq16QoQUXa9IVCD2FLJ7RuU89WNtmUSQqkgYMgw0accKrpPaPynnrZWG4Vi+VWmY5tnMWXG+XrIYnA0rhj0mdcTgdNdwnKDqjmduM1SRR/qlr8/4KX6pa8T/BVzDuLZXudRZblmbxXcPUNPc3KqCIwrbOzgrHEnHjoyD+3eSXkht7DeKG4umDGOJVUklfouThXfmbnZ7Cvy1vt9pmv1W1+d8FL9VteJvgq5yrcOGfLmzHN80iyyETPbptAEFo2ZG8pmUa1OFNn3Ky6W/sbDKM5hv5bx2WTZA+7RF2y52WOPJTzE+z2Dy1vt9pT/AKpacTerS/U7Tib1a04/t7kDXPY03jhN0W6sQ7K7W3q2dnrMccaDy/8At80kuZfqWYxWNtlcvUPPhiGYhWDeUy7IwYU8xPs9g8tb7faUn6pacTerTxm9oOBvVq3v9z927aynuId44LiWKNnjhAXF2UYhRg516qpsryjLr21665zFLSTaK9U2GOA87SwqY37knRU+BzOzags0s1Oyr+BKM6sxwP6tSDPLMen6vy0rvdm3Sxlu7K/S7WDDrFUDUTxgnTU826eXW7KlxmqQuwDBXUKcD+1Xee/wXuKX5XDGWLapSVcOyhEM/seJ/V+WnjeGx4pPV+Wkm6kKZlFay3Jlt7iFpYZY8ASVK6DjtDDA0f8A0Tl340/1f8Ndx8xJVWXB0KbktFFpNzdVXAC/qOwA0CQni2flrO3Vwbm5lnI2TKxbDirX/wBE5d+NcfV/wVR7xZPa5U9utvI8nWhmbbw0YEAYYAVxfhfy5rlKR4Fulu6X7mW1mzT8S4Yis/5CPlbnqJ9dSWfu9OVueon11mZvQ2i7XpChKKtekKhBlNJ7R+U89bDfGTb3a3ZX0Lcj6kdY+T2j8p560288m1kWQr6MJ+ylSAr+2cnV5renjs3H1loX+3j9XvbbtxLN9lqW4UnV5jdnjtXHxihtyZNjeSBu5J9k1BJe7xy7W5CJ/wCzuD/mTVTf2+fq97LJuLrPsNRueS7W6aJ/38x+vLVXuY+xvHaNxbf2GoCezf8A36j/APsSf8w1sLnqczTefJluYoLm5uo5F61sBshItP1cNFYe1f8A3ir/APfE/wCZUe9bB94r5jwuPsrQFhmG4l/Z2M17HdW90tuu3IkTHaCjWdIw0VVZdks9/C06yJFEp2dp+E1bbqybGTZ8vpQD7L1XRv8A7blT96Oda7tpNuuNE37Cq9KSisjyuUoxrStKllHbLlWTXsMs8chuSuwEPDqwoLe5y+YRE/gLzmqRekvKKtd4327yM/ulHxmrHJStySWVRyrjxKI2XC/CTlnlPPKTpTdFbP0L1bgrf5Lp0G3dPhQHwV0S1lzBsns3sESR8Crh9WAJGjSOKuU3E+zdZQ3oJh8IArdZXFDmOTpHa3i2+YrI2KtKy4ricBsBuHHgFXSo440+Wa2qqxjvM9uMoy+WvzWpLCWWWE28HxL6e43ojgkeSCBY1Ri5BGIUDT51cl3vm276BBqSEH4WbxV0tlkyXJcxTMb+OW6uY9mGHrCzDQwwAbTp2uKuTZ9N1uYsfRRR8WPhrm419mSSjRyiqxVK7y23B/ftuTm2oSdJyzNVw3BFn7vTlbnqF9dS2fu9OVueon11lZuQ2iLdsGFD05H2dNQGV0ntG5Tz1dWm9N1b2kVq8EVwsI2UaQaQOKhmitZGLOmk68DhSFvY+gfWNSAg7z3Qvo7yKCKIohiaNR5LKxx8qpxvjcqS0VpbxvwOAcRQPZ7D0G9Y0uz2HoH1jUCpLY7zXlpbm3eKO5QuzjrBqZji3x17PvNcyT288VvDBJbMWUovS2hslW7mFQ9nsPQPrGl2ew9A+saCod/WNxtbYsrfb17WBxx5ddD2281xC88klvDcSXEnWuzrqOGGC9zRUPZ7D0G9Y0uzWHoH1jQVCLreq6ntZbaO3it1mGy7RjTs1X2mYy20ZiCq8ZOODcdEdmsPQb1jS7PYegfWNdJuLqnQiSUlRqpFLmryxtH1Ma7Qw2gNNPOdSt0oI27p007s9h6B9Y0uz2HoH1jXX3Z+I4+1b8IJdX89xLHKQFMXQUahpxoiPN5P+onfU+A0/s9h6DesaXZ7D0D6xpG7OLbUtu0StW5JJx2bBsmbtiSiEk+cxoCWWSaVpZOk2vDVo0VYdnsPQb1jSNvZcCH1jSd2c+p1XAmFqEOmOPEfaH+BQd1ueo211IzrgFUYKNAAqI1WztCpUqVCRUqVKgFSpUqAVKlSoBUqVKgFSpUqAVKlSoBUqVKgFSpUqAVKlSoD/9k\x3d";
var cc = cc || {},
    ClassManager = {
        id: 0 | 998 * Math.random(),
        instanceId: 0 | 998 * Math.random(),
        compileSuper: function(a, b, d) {
            a = a.toString();
            var e = a.indexOf("("),
                f = a.indexOf(")"),
                e = a.substring(e + 1, f),
                e = e.trim(),
                f = a.indexOf("{"),
                g = a.lastIndexOf("}");
            for (a = a.substring(f + 1, g); - 1 !== a.indexOf("this._super");) {
                var f = a.indexOf("this._super"),
                    g = a.indexOf("(", f),
                    h = a.indexOf(")", g),
                    h = a.substring(g + 1, h),
                    h = (h = h.trim()) ? "," : "";
                a = a.substring(0, f) + "ClassManager[" + d + "]." + b + ".call(this" + h + a.substring(g + 1)
            }
            return Function(e, a)
        },
        getNewID: function() {
            return this.id++
        },
        getNewInstanceId: function() {
            return this.instanceId++
        }
    };
ClassManager.compileSuper.ClassManager = ClassManager;
(function() {
    var a = /\b_super\b/,
        b = cc.game.config[cc.game.CONFIG_KEY.classReleaseMode];
    b && console.log("release Mode");
    cc.Class = function() {};
    cc.Class.extend = function(d) {
        function e() {
            this.__instanceId = ClassManager.getNewInstanceId();
            this.ctor && this.ctor.apply(this, arguments)
        }
        var f = this.prototype,
            g = Object.create(f),
            h = ClassManager.getNewID();
        ClassManager[h] = f;
        var k = {
            writable: !0,
            enumerable: !1,
            configurable: !0
        };
        g.__instanceId = null;
        e.id = h;
        k.value = h;
        Object.defineProperty(g, "__pid", k);
        e.prototype = g;
        k.value = e;
        Object.defineProperty(e.prototype, "constructor", k);
        this.__getters__ && (e.__getters__ = cc.clone(this.__getters__));
        this.__setters__ && (e.__setters__ = cc.clone(this.__setters__));
        for (var m = 0, n = arguments.length; m < n; ++m) {
            var p = arguments[m],
                r;
            for (r in p) {
                var s = "function" === typeof p[r],
                    t = "function" === typeof f[r],
                    u = a.test(p[r]);
                b && s && t && u ? (k.value = ClassManager.compileSuper(p[r], r, h), Object.defineProperty(g, r, k)) : s && t && u ? (k.value = function(a, b) {
                    return function() {
                        var d = this._super;
                        this._super = f[a];
                        var e = b.apply(this,
                            arguments);
                        this._super = d;
                        return e
                    }
                }(r, p[r]), Object.defineProperty(g, r, k)) : s ? (k.value = p[r], Object.defineProperty(g, r, k)) : g[r] = p[r];
                if (s) {
                    var v, w;
                    if (this.__getters__ && this.__getters__[r]) {
                        var s = this.__getters__[r],
                            x;
                        for (x in this.__setters__)
                            if (this.__setters__[x] === s) {
                                w = x;
                                break
                            }
                        cc.defineGetterSetter(g, s, p[r], p[w] ? p[w] : g[w], r, w)
                    }
                    if (this.__setters__ && this.__setters__[r]) {
                        s = this.__setters__[r];
                        for (x in this.__getters__)
                            if (this.__getters__[x] === s) {
                                v = x;
                                break
                            }
                        cc.defineGetterSetter(g, s, p[v] ? p[v] : g[v], p[r],
                            v, r)
                    }
                }
            }
        }
        e.extend = cc.Class.extend;
        e.implement = function(a) {
            for (var b in a) g[b] = a[b]
        };
        return e
    }
})();
cc.defineGetterSetter = function(a, b, d, e, f, g) {
    if (a.__defineGetter__) d && a.__defineGetter__(b, d), e && a.__defineSetter__(b, e);
    else if (Object.defineProperty) {
        var h = {
            enumerable: !1,
            configurable: !0
        };
        d && (h.get = d);
        e && (h.set = e);
        Object.defineProperty(a, b, h)
    } else throw Error("browser does not support getters"); if (!f && !g)
        for (var h = null != d, k = void 0 != e, m = Object.getOwnPropertyNames(a), n = 0; n < m.length; n++) {
            var p = m[n];
            if (!((a.__lookupGetter__ ? a.__lookupGetter__(p) : Object.getOwnPropertyDescriptor(a, p)) || "function" !== typeof a[p])) {
                var r =
                    a[p];
                if (h && r === d && (f = p, !k || g)) break;
                if (k && r === e && (g = p, !h || f)) break
            }
        }
    a = a.constructor;
    f && (a.__getters__ || (a.__getters__ = {}), a.__getters__[f] = b);
    g && (a.__setters__ || (a.__setters__ = {}), a.__setters__[g] = b)
};
cc.clone = function(a) {
    var b = a.constructor ? new a.constructor : {},
        d;
    for (d in a) {
        var e = a[d];
        b[d] = "object" === typeof e && e && !(e instanceof cc.Node) && !(e instanceof HTMLElement) ? cc.clone(e) : e
    }
    return b
};
cc.inject = function(a, b) {
    for (var d in a) b[d] = a[d]
};
cc = cc || {};
cc._tmp = cc._tmp || {};
cc.associateWithNative = function(a, b) {};
cc.KEY = {
    none: 0,
    back: 6,
    menu: 18,
    backspace: 8,
    tab: 9,
    enter: 13,
    shift: 16,
    ctrl: 17,
    alt: 18,
    pause: 19,
    capslock: 20,
    escape: 27,
    space: 32,
    pageup: 33,
    pagedown: 34,
    end: 35,
    home: 36,
    left: 37,
    up: 38,
    right: 39,
    down: 40,
    select: 41,
    insert: 45,
    Delete: 46,
    "0": 48,
    1: 49,
    2: 50,
    3: 51,
    4: 52,
    5: 53,
    6: 54,
    7: 55,
    8: 56,
    9: 57,
    a: 65,
    b: 66,
    c: 67,
    d: 68,
    e: 69,
    f: 70,
    g: 71,
    h: 72,
    i: 73,
    j: 74,
    k: 75,
    l: 76,
    m: 77,
    n: 78,
    o: 79,
    p: 80,
    q: 81,
    r: 82,
    s: 83,
    t: 84,
    u: 85,
    v: 86,
    w: 87,
    x: 88,
    y: 89,
    z: 90,
    num0: 96,
    num1: 97,
    num2: 98,
    num3: 99,
    num4: 100,
    num5: 101,
    num6: 102,
    num7: 103,
    num8: 104,
    num9: 105,
    "*": 106,
    "+": 107,
    "-": 109,
    numdel: 110,
    "/": 111,
    f1: 112,
    f2: 113,
    f3: 114,
    f4: 115,
    f5: 116,
    f6: 117,
    f7: 118,
    f8: 119,
    f9: 120,
    f10: 121,
    f11: 122,
    f12: 123,
    numlock: 144,
    scrolllock: 145,
    ";": 186,
    semicolon: 186,
    equal: 187,
    "\x3d": 187,
    ",": 188,
    comma: 188,
    dash: 189,
    ".": 190,
    period: 190,
    forwardslash: 191,
    grave: 192,
    "[": 219,
    openbracket: 219,
    backslash: 220,
    "]": 221,
    closebracket: 221,
    quote: 222,
    dpadLeft: 1E3,
    dpadRight: 1001,
    dpadUp: 1003,
    dpadDown: 1004,
    dpadCenter: 1005
};
cc.FMT_JPG = 0;
cc.FMT_PNG = 1;
cc.FMT_TIFF = 2;
cc.FMT_RAWDATA = 3;
cc.FMT_WEBP = 4;
cc.FMT_UNKNOWN = 5;
cc.getImageFormatByData = function(a) {
    return 8 < a.length && 137 === a[0] && 80 === a[1] && 78 === a[2] && 71 === a[3] && 13 === a[4] && 10 === a[5] && 26 === a[6] && 10 === a[7] ? cc.FMT_PNG : 2 < a.length && (73 === a[0] && 73 === a[1] || 77 === a[0] && 77 === a[1] || 255 === a[0] && 216 === a[1]) ? cc.FMT_TIFF : cc.FMT_UNKNOWN
};
cc.inherits = function(a, b) {
    function d() {}
    d.prototype = b.prototype;
    a.superClass_ = b.prototype;
    a.prototype = new d;
    a.prototype.constructor = a
};
cc.base = function(a, b, d) {
    var e = arguments.callee.caller;
    if (e.superClass_) return ret = e.superClass_.constructor.apply(a, Array.prototype.slice.call(arguments, 1));
    for (var f = Array.prototype.slice.call(arguments, 2), g = !1, h = a.constructor; h; h = h.superClass_ && h.superClass_.constructor)
        if (h.prototype[b] === e) g = !0;
        else if (g) return h.prototype[b].apply(a, f);
    if (a[b] === e) return a.constructor.prototype[b].apply(a, f);
    throw Error("cc.base called from a method of one name to a method of a different name");
};
cc.Point = function(a, b) {
    this.x = a || 0;
    this.y = b || 0
};
cc.p = function(a, b) {
    return void 0 === a ? {
        x: 0,
        y: 0
    } : void 0 === b ? {
        x: a.x,
        y: a.y
    } : {
        x: a,
        y: b
    }
};
cc.pointEqualToPoint = function(a, b) {
    return a && b && a.x === b.x && a.y === b.y
};
cc.Size = function(a, b) {
    this.width = a || 0;
    this.height = b || 0
};
cc.size = function(a, b) {
    return void 0 === a ? {
        width: 0,
        height: 0
    } : void 0 === b ? {
        width: a.width,
        height: a.height
    } : {
        width: a,
        height: b
    }
};
cc.sizeEqualToSize = function(a, b) {
    return a && b && a.width === b.width && a.height === b.height
};
cc.Rect = function(a, b, d, e) {
    this.x = a || 0;
    this.y = b || 0;
    this.width = d || 0;
    this.height = e || 0
};
cc.rect = function(a, b, d, e) {
    return void 0 === a ? {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    } : void 0 === b ? {
        x: a.x,
        y: a.y,
        width: a.width,
        height: a.height
    } : {
        x: a,
        y: b,
        width: d,
        height: e
    }
};
cc.rectEqualToRect = function(a, b) {
    return a && b && a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height
};
cc._rectEqualToZero = function(a) {
    return a && 0 === a.x && 0 === a.y && 0 === a.width && 0 === a.height
};
cc.rectContainsRect = function(a, b) {
    return !a || !b ? !1 : !(a.x >= b.x || a.y >= b.y || a.x + a.width <= b.x + b.width || a.y + a.height <= b.y + b.height)
};
cc.rectGetMaxX = function(a) {
    return a.x + a.width
};
cc.rectGetMidX = function(a) {
    return a.x + a.width / 2
};
cc.rectGetMinX = function(a) {
    return a.x
};
cc.rectGetMaxY = function(a) {
    return a.y + a.height
};
cc.rectGetMidY = function(a) {
    return a.y + a.height / 2
};
cc.rectGetMinY = function(a) {
    return a.y
};
cc.rectContainsPoint = function(a, b) {
    return b.x >= cc.rectGetMinX(a) && b.x <= cc.rectGetMaxX(a) && b.y >= cc.rectGetMinY(a) && b.y <= cc.rectGetMaxY(a)
};
cc.rectIntersectsRect = function(a, b) {
    var d = a.y + a.height,
        e = b.x + b.width,
        f = b.y + b.height;
    return !(a.x + a.width < b.x || e < a.x || d < b.y || f < a.y)
};
cc.rectOverlapsRect = function(a, b) {
    return !(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y)
};
cc.rectUnion = function(a, b) {
    var d = cc.rect(0, 0, 0, 0);
    d.x = Math.min(a.x, b.x);
    d.y = Math.min(a.y, b.y);
    d.width = Math.max(a.x + a.width, b.x + b.width) - d.x;
    d.height = Math.max(a.y + a.height, b.y + b.height) - d.y;
    return d
};
cc.rectIntersection = function(a, b) {
    var d = cc.rect(Math.max(cc.rectGetMinX(a), cc.rectGetMinX(b)), Math.max(cc.rectGetMinY(a), cc.rectGetMinY(b)), 0, 0);
    d.width = Math.min(cc.rectGetMaxX(a), cc.rectGetMaxX(b)) - cc.rectGetMinX(d);
    d.height = Math.min(cc.rectGetMaxY(a), cc.rectGetMaxY(b)) - cc.rectGetMinY(d);
    return d
};
cc.SAXParser = cc.Class.extend({
    _parser: null,
    _isSupportDOMParser: null,
    ctor: function() {
        window.DOMParser ? (this._isSupportDOMParser = !0, this._parser = new DOMParser) : this._isSupportDOMParser = !1
    },
    parse: function(a) {
        return this._parseXML(a)
    },
    _parseXML: function(a) {
        var b;
        this._isSupportDOMParser ? b = this._parser.parseFromString(a, "text/xml") : (b = new ActiveXObject("Microsoft.XMLDOM"), b.async = "false", b.loadXML(a));
        return b
    }
});
cc.PlistParser = cc.SAXParser.extend({
    parse: function(a) {
        a = this._parseXML(a).documentElement;
        if ("plist" !== a.tagName) throw Error("Not a plist file!");
        for (var b = null, d = 0, e = a.childNodes.length; d < e && !(b = a.childNodes[d], 1 === b.nodeType); d++);
        return this._parseNode(b)
    },
    _parseNode: function(a) {
        var b = null,
            d = a.tagName;
        if ("dict" === d) b = this._parseDict(a);
        else if ("array" === d) b = this._parseArray(a);
        else if ("string" === d)
            if (1 === a.childNodes.length) b = a.firstChild.nodeValue;
            else {
                b = "";
                for (d = 0; d < a.childNodes.length; d++) b +=
                    a.childNodes[d].nodeValue
            } else "false" === d ? b = !1 : "true" === d ? b = !0 : "real" === d ? b = parseFloat(a.firstChild.nodeValue) : "integer" === d && (b = parseInt(a.firstChild.nodeValue, 10));
        return b
    },
    _parseArray: function(a) {
        for (var b = [], d = 0, e = a.childNodes.length; d < e; d++) {
            var f = a.childNodes[d];
            1 === f.nodeType && b.push(this._parseNode(f))
        }
        return b
    },
    _parseDict: function(a) {
        for (var b = {}, d = null, e = 0, f = a.childNodes.length; e < f; e++) {
            var g = a.childNodes[e];
            1 === g.nodeType && ("key" === g.tagName ? d = g.firstChild.nodeValue : b[d] = this._parseNode(g))
        }
        return b
    }
});
cc._txtLoader = {
    load: function(a, b, d, e) {
        cc.loader.loadTxt(a, e)
    }
};
cc.loader.register(["txt", "xml", "vsh", "fsh", "atlas"], cc._txtLoader);
cc._jsonLoader = {
    load: function(a, b, d, e) {
        cc.loader.loadJson(a, e)
    }
};
cc.loader.register(["json", "ExportJson"], cc._jsonLoader);
cc._jsLoader = {
    load: function(a, b, d, e) {
        cc.loader.loadJs(a, e)
    }
};
cc.loader.register(["js"], cc._jsLoader);
cc._imgLoader = {
    load: function(a, b, d, e) {
        cc.loader.cache[b] = cc.loader.loadImg(a, function(a, d) {
            if (a) return e(a);
            cc.textureCache.handleLoadedTexture(b);
            e(null, d)
        })
    }
};
cc.loader.register("png jpg bmp jpeg gif ico tiff".split(" "), cc._imgLoader);
cc._serverImgLoader = {
    load: function(a, b, d, e) {
        cc.loader.cache[b] = cc.loader.loadImg(d.src, function(a, d) {
            if (a) return e(a);
            cc.textureCache.handleLoadedTexture(b);
            e(null, d)
        })
    }
};
cc.loader.register(["serverImg"], cc._serverImgLoader);
cc._plistLoader = {
    load: function(a, b, d, e) {
        cc.loader.loadTxt(a, function(a, b) {
            if (a) return e(a);
            e(null, cc.plistParser.parse(b))
        })
    }
};
cc.loader.register(["plist"], cc._plistLoader);
cc._fontLoader = {
    TYPE: {
        ".eot": "embedded-opentype",
        ".ttf": "truetype",
        ".ttc": "truetype",
        ".woff": "woff",
        ".svg": "svg"
    },
    _loadFont: function(a, b, d) {
        var e = document,
            f = cc.path,
            g = this.TYPE,
            h = cc.newElement("style");
        h.type = "text/css";
        e.body.appendChild(h);
        var k = "",
            k = isNaN(a - 0) ? k + ("@font-face { font-family:" + a + "; src:") : k + ("@font-face { font-family:'" + a + "'; src:");
        if (b instanceof Array)
            for (var m = 0, n = b.length; m < n; m++) d = f.extname(b[m]).toLowerCase(), k += "url('" + b[m] + "') format('" + g[d] + "')", k += m === n - 1 ? ";" : ",";
        else d =
            d.toLowerCase(), k += "url('" + b + "') format('" + g[d] + "');";
        h.textContent += k + "}";
        b = cc.newElement("div");
        d = b.style;
        d.fontFamily = a;
        b.innerHTML = ".";
        d.position = "absolute";
        d.left = "-100px";
        d.top = "-100px";
        e.body.appendChild(b)
    },
    load: function(a, b, d, e) {
        b = d.type;
        a = d.name;
        b = d.srcs;
        cc.isString(d) ? (b = cc.path.extname(d), a = cc.path.basename(d, b), this._loadFont(a, d, b)) : this._loadFont(a, b);
        e(null, !0)
    }
};
cc.loader.register("font eot ttf woff svg ttc".split(" "), cc._fontLoader);
cc._binaryLoader = {
    load: function(a, b, d, e) {
        cc.loader.loadBinary(a, e)
    }
};
cc._csbLoader = {
    load: function(a, b, d, e) {
        cc.loader.loadCsb(a, e)
    }
};
cc.loader.register(["csb"], cc._csbLoader);
window.CocosEngine = cc.ENGINE_VERSION = "Cocos2d-JS v3.7.1";
cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL = 0;
cc.DIRECTOR_STATS_POSITION = cc.p(0, 0);
cc.DIRECTOR_FPS_INTERVAL = 0.5;
cc.COCOSNODE_RENDER_SUBPIXEL = 1;
cc.SPRITEBATCHNODE_RENDER_SUBPIXEL = 1;
cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA = 1;
cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP = 0;
cc.TEXTURE_ATLAS_USE_VAO = 0;
cc.TEXTURE_NPOT_SUPPORT = 0;
cc.RETINA_DISPLAY_SUPPORT = 1;
cc.RETINA_DISPLAY_FILENAME_SUFFIX = "-hd";
cc.USE_LA88_LABELS = 1;
cc.SPRITE_DEBUG_DRAW = 0;
cc.SPRITEBATCHNODE_DEBUG_DRAW = 0;
cc.LABELBMFONT_DEBUG_DRAW = 0;
cc.LABELATLAS_DEBUG_DRAW = 0;
cc.IS_RETINA_DISPLAY_SUPPORTED = 1;
cc.DEFAULT_ENGINE = cc.ENGINE_VERSION + "-canvas";
cc.ENABLE_STACKABLE_ACTIONS = 1;
cc.ENABLE_GL_STATE_CACHE = 1;
cc.$ = function(a) {
    var b = this === cc ? document : this;
    if (a = a instanceof HTMLElement ? a : b.querySelector(a)) a.find = a.find || cc.$, a.hasClass = a.hasClass || function(a) {
            return this.className.match(RegExp("(\\s|^)" + a + "(\\s|$)"))
        }, a.addClass = a.addClass || function(a) {
            this.hasClass(a) || (this.className && (this.className += " "), this.className += a);
            return this
        }, a.removeClass = a.removeClass || function(a) {
            this.hasClass(a) && (this.className = this.className.replace(a, ""));
            return this
        }, a.remove = a.remove || function() {
            this.parentNode &&
                this.parentNode.removeChild(this);
            return this
        }, a.appendTo = a.appendTo || function(a) {
            a.appendChild(this);
            return this
        }, a.prependTo = a.prependTo || function(a) {
            a.childNodes[0] ? a.insertBefore(this, a.childNodes[0]) : a.appendChild(this);
            return this
        }, a.transforms = a.transforms || function() {
            this.style[cc.$.trans] = cc.$.translate(this.position) + cc.$.rotate(this.rotation) + cc.$.scale(this.scale) + cc.$.skew(this.skew);
            return this
        }, a.position = a.position || {
            x: 0,
            y: 0
        }, a.rotation = a.rotation || 0, a.scale = a.scale || {
            x: 1,
            y: 1
        }, a.skew =
        a.skew || {
            x: 0,
            y: 0
        }, a.translates = function(a, b) {
            this.position.x = a;
            this.position.y = b;
            this.transforms();
            return this
        }, a.rotate = function(a) {
            this.rotation = a;
            this.transforms();
            return this
        }, a.resize = function(a, b) {
            this.scale.x = a;
            this.scale.y = b;
            this.transforms();
            return this
        }, a.setSkew = function(a, b) {
            this.skew.x = a;
            this.skew.y = b;
            this.transforms();
            return this
        };
    return a
};
switch (cc.sys.browserType) {
    case cc.sys.BROWSER_TYPE_FIREFOX:
        cc.$.pfx = "Moz";
        cc.$.hd = !0;
        break;
    case cc.sys.BROWSER_TYPE_CHROME:
    case cc.sys.BROWSER_TYPE_SAFARI:
        cc.$.pfx = "webkit";
        cc.$.hd = !0;
        break;
    case cc.sys.BROWSER_TYPE_OPERA:
        cc.$.pfx = "O";
        cc.$.hd = !1;
        break;
    case cc.sys.BROWSER_TYPE_IE:
        cc.$.pfx = "ms";
        cc.$.hd = !1;
        break;
    default:
        cc.$.pfx = "webkit", cc.$.hd = !0
}
cc.$.trans = cc.$.pfx + "Transform";
cc.$.translate = cc.$.hd ? function(a) {
    return "translate3d(" + a.x + "px, " + a.y + "px, 0) "
} : function(a) {
    return "translate(" + a.x + "px, " + a.y + "px) "
};
cc.$.rotate = cc.$.hd ? function(a) {
    return "rotateZ(" + a + "deg) "
} : function(a) {
    return "rotate(" + a + "deg) "
};
cc.$.scale = function(a) {
    return "scale(" + a.x + ", " + a.y + ") "
};
cc.$.skew = function(a) {
    return "skewX(" + -a.x + "deg) skewY(" + a.y + "deg)"
};
cc.$new = function(a) {
    return cc.$(document.createElement(a))
};
cc.$.findpos = function(a) {
    var b = 0,
        d = 0;
    do b += a.offsetLeft, d += a.offsetTop; while (a = a.offsetParent);
    return {
        x: b,
        y: d
    }
};
cc.INVALID_INDEX = -1;
cc.PI = Math.PI;
cc.FLT_MAX = parseFloat("3.402823466e+38F");
cc.FLT_MIN = parseFloat("1.175494351e-38F");
cc.RAD = cc.PI / 180;
cc.DEG = 180 / cc.PI;
cc.UINT_MAX = 4294967295;
cc.swap = function(a, b, d) {
    if (cc.isObject(d) && !cc.isUndefined(d.x) && !cc.isUndefined(d.y)) {
        var e = d[a];
        d[a] = d[b];
        d[b] = e
    } else cc.log(cc._LogInfos.swap)
};
cc.lerp = function(a, b, d) {
    return a + (b - a) * d
};
cc.rand = function() {
    return 16777215 * Math.random()
};
cc.randomMinus1To1 = function() {
    return 2 * (Math.random() - 0.5)
};
cc.random0To1 = Math.random;
cc.degreesToRadians = function(a) {
    return a * cc.RAD
};
cc.radiansToDegrees = function(a) {
    return a * cc.DEG
};
cc.radiansToDegress = function(a) {
    cc.log(cc._LogInfos.radiansToDegress);
    return a * cc.DEG
};
cc.REPEAT_FOREVER = Number.MAX_VALUE - 1;
cc.nodeDrawSetup = function(a) {
    a._shaderProgram && (a._shaderProgram.use(), a._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4())
};
cc.enableDefaultGLStates = function() {};
cc.disableDefaultGLStates = function() {};
cc.incrementGLDraws = function(a) {
    cc.g_NumberOfDraws += a
};
cc.FLT_EPSILON = 1.192092896E-7;
cc.contentScaleFactor = cc.IS_RETINA_DISPLAY_SUPPORTED ? function() {
    return cc.director.getContentScaleFactor()
} : function() {
    return 1
};
cc.pointPointsToPixels = function(a) {
    var b = cc.contentScaleFactor();
    return cc.p(a.x * b, a.y * b)
};
cc.pointPixelsToPoints = function(a) {
    var b = cc.contentScaleFactor();
    return cc.p(a.x / b, a.y / b)
};
cc._pointPixelsToPointsOut = function(a, b) {
    var d = cc.contentScaleFactor();
    b.x = a.x / d;
    b.y = a.y / d
};
cc.sizePointsToPixels = function(a) {
    var b = cc.contentScaleFactor();
    return cc.size(a.width * b, a.height * b)
};
cc.sizePixelsToPoints = function(a) {
    var b = cc.contentScaleFactor();
    return cc.size(a.width / b, a.height / b)
};
cc._sizePixelsToPointsOut = function(a, b) {
    var d = cc.contentScaleFactor();
    b.width = a.width / d;
    b.height = a.height / d
};
cc.rectPixelsToPoints = cc.IS_RETINA_DISPLAY_SUPPORTED ? function(a) {
    var b = cc.contentScaleFactor();
    return cc.rect(a.x / b, a.y / b, a.width / b, a.height / b)
} : function(a) {
    return a
};
cc.rectPointsToPixels = cc.IS_RETINA_DISPLAY_SUPPORTED ? function(a) {
    var b = cc.contentScaleFactor();
    return cc.rect(a.x * b, a.y * b, a.width * b, a.height * b)
} : function(a) {
    return a
};
cc.ONE = 1;
cc.ZERO = 0;
cc.SRC_ALPHA = 770;
cc.SRC_ALPHA_SATURATE = 776;
cc.SRC_COLOR = 768;
cc.DST_ALPHA = 772;
cc.DST_COLOR = 774;
cc.ONE_MINUS_SRC_ALPHA = 771;
cc.ONE_MINUS_SRC_COLOR = 769;
cc.ONE_MINUS_DST_ALPHA = 773;
cc.ONE_MINUS_DST_COLOR = 775;
cc.ONE_MINUS_CONSTANT_ALPHA = 32772;
cc.ONE_MINUS_CONSTANT_COLOR = 32770;
cc.LINEAR = 9729;
cc.REPEAT = 10497;
cc.CLAMP_TO_EDGE = 33071;
cc.MIRRORED_REPEAT = 33648;
cc.BLEND_SRC = cc._renderType === cc._RENDER_TYPE_WEBGL && cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA ? cc.ONE : cc.SRC_ALPHA;
cc.BLEND_DST = 771;
cc.checkGLErrorDebug = function() {
    if (cc.renderMode === cc._RENDER_TYPE_WEBGL) {
        var a = cc._renderContext.getError();
        a && cc.log(cc._LogInfos.checkGLErrorDebug, a)
    }
};
cc.DEVICE_ORIENTATION_PORTRAIT = 0;
cc.DEVICE_ORIENTATION_LANDSCAPE_LEFT = 1;
cc.DEVICE_ORIENTATION_PORTRAIT_UPSIDE_DOWN = 2;
cc.DEVICE_ORIENTATION_LANDSCAPE_RIGHT = 3;
cc.DEVICE_MAX_ORIENTATIONS = 2;
cc.VERTEX_ATTRIB_FLAG_NONE = 0;
cc.VERTEX_ATTRIB_FLAG_POSITION = 1;
cc.VERTEX_ATTRIB_FLAG_COLOR = 2;
cc.VERTEX_ATTRIB_FLAG_TEX_COORDS = 4;
cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX = cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS;
cc.GL_ALL = 0;
cc.VERTEX_ATTRIB_POSITION = 0;
cc.VERTEX_ATTRIB_COLOR = 1;
cc.VERTEX_ATTRIB_TEX_COORDS = 2;
cc.VERTEX_ATTRIB_MAX = 3;
cc.UNIFORM_PMATRIX = 0;
cc.UNIFORM_MVMATRIX = 1;
cc.UNIFORM_MVPMATRIX = 2;
cc.UNIFORM_TIME = 3;
cc.UNIFORM_SINTIME = 4;
cc.UNIFORM_COSTIME = 5;
cc.UNIFORM_RANDOM01 = 6;
cc.UNIFORM_SAMPLER = 7;
cc.UNIFORM_MAX = 8;
cc.SHADER_POSITION_TEXTURECOLOR = "ShaderPositionTextureColor";
cc.SHADER_POSITION_TEXTURECOLORALPHATEST = "ShaderPositionTextureColorAlphaTest";
cc.SHADER_POSITION_COLOR = "ShaderPositionColor";
cc.SHADER_POSITION_TEXTURE = "ShaderPositionTexture";
cc.SHADER_POSITION_TEXTURE_UCOLOR = "ShaderPositionTexture_uColor";
cc.SHADER_POSITION_TEXTUREA8COLOR = "ShaderPositionTextureA8Color";
cc.SHADER_POSITION_UCOLOR = "ShaderPosition_uColor";
cc.SHADER_POSITION_LENGTHTEXTURECOLOR = "ShaderPositionLengthTextureColor";
cc.UNIFORM_PMATRIX_S = "CC_PMatrix";
cc.UNIFORM_MVMATRIX_S = "CC_MVMatrix";
cc.UNIFORM_MVPMATRIX_S = "CC_MVPMatrix";
cc.UNIFORM_TIME_S = "CC_Time";
cc.UNIFORM_SINTIME_S = "CC_SinTime";
cc.UNIFORM_COSTIME_S = "CC_CosTime";
cc.UNIFORM_RANDOM01_S = "CC_Random01";
cc.UNIFORM_SAMPLER_S = "CC_Texture0";
cc.UNIFORM_ALPHA_TEST_VALUE_S = "CC_alpha_value";
cc.ATTRIBUTE_NAME_COLOR = "a_color";
cc.ATTRIBUTE_NAME_POSITION = "a_position";
cc.ATTRIBUTE_NAME_TEX_COORD = "a_texCoord";
cc.ITEM_SIZE = 32;
cc.CURRENT_ITEM = 3233828865;
cc.ZOOM_ACTION_TAG = 3233828866;
cc.NORMAL_TAG = 8801;
cc.SELECTED_TAG = 8802;
cc.DISABLE_TAG = 8803;
cc.arrayVerifyType = function(a, b) {
    if (a && 0 < a.length)
        for (var d = 0; d < a.length; d++)
            if (!(a[d] instanceof b)) return cc.log("element type is wrong!"), !1;
    return !0
};
cc.arrayRemoveObject = function(a, b) {
    for (var d = 0, e = a.length; d < e; d++)
        if (a[d] === b) {
            a.splice(d, 1);
            break
        }
};
cc.arrayRemoveArray = function(a, b) {
    for (var d = 0, e = b.length; d < e; d++) cc.arrayRemoveObject(a, b[d])
};
cc.arrayAppendObjectsToIndex = function(a, b, d) {
    a.splice.apply(a, [d, 0].concat(b));
    return a
};
cc.copyArray = function(a) {
    var b, d = a.length,
        e = Array(d);
    for (b = 0; b < d; b += 1) e[b] = a[b];
    return e
};
cc = cc || {};
cc._tmp = cc._tmp || {};
cc._tmp.WebGLColor = function() {
    cc.color = function(a, d, e, f, g, h) {
        return void 0 === a ? new cc.Color(0, 0, 0, 255, g, h) : cc.isString(a) ? (a = cc.hexToColor(a), new cc.Color(a.r, a.g, a.b, a.a)) : cc.isObject(a) ? new cc.Color(a.r, a.g, a.b, a.a, a.arrayBuffer, a.offset) : new cc.Color(a, d, e, f, g, h)
    };
    cc.Color = function(a, d, e, f, g, h) {
        this._arrayBuffer = g || new ArrayBuffer(cc.Color.BYTES_PER_ELEMENT);
        this._offset = h || 0;
        g = this._arrayBuffer;
        h = this._offset;
        var k = Uint8Array.BYTES_PER_ELEMENT;
        this._rU8 = new Uint8Array(g, h, 1);
        this._gU8 = new Uint8Array(g,
            h + k, 1);
        this._bU8 = new Uint8Array(g, h + 2 * k, 1);
        this._aU8 = new Uint8Array(g, h + 3 * k, 1);
        this._rU8[0] = a || 0;
        this._gU8[0] = d || 0;
        this._bU8[0] = e || 0;
        this._aU8[0] = null == f ? 255 : f;
        void 0 === f && (this.a_undefined = !0)
    };
    cc.Color.BYTES_PER_ELEMENT = 4;
    var a = cc.Color.prototype;
    a._getR = function() {
        return this._rU8[0]
    };
    a._setR = function(a) {
        this._rU8[0] = 0 > a ? 0 : a
    };
    a._getG = function() {
        return this._gU8[0]
    };
    a._setG = function(a) {
        this._gU8[0] = 0 > a ? 0 : a
    };
    a._getB = function() {
        return this._bU8[0]
    };
    a._setB = function(a) {
        this._bU8[0] = 0 > a ? 0 : a
    };
    a._getA =
        function() {
            return this._aU8[0]
        };
    a._setA = function(a) {
        this._aU8[0] = 0 > a ? 0 : a
    };
    cc.defineGetterSetter(a, "r", a._getR, a._setR);
    cc.defineGetterSetter(a, "g", a._getG, a._setG);
    cc.defineGetterSetter(a, "b", a._getB, a._setB);
    cc.defineGetterSetter(a, "a", a._getA, a._setA);
    cc.Vertex2F = function(a, d, e, f) {
        this._arrayBuffer = e || new ArrayBuffer(cc.Vertex2F.BYTES_PER_ELEMENT);
        this._offset = f || 0;
        this._xF32 = new Float32Array(this._arrayBuffer, this._offset, 1);
        this._yF32 = new Float32Array(this._arrayBuffer, this._offset + 4, 1);
        this._xF32[0] =
            a || 0;
        this._yF32[0] = d || 0
    };
    cc.Vertex2F.BYTES_PER_ELEMENT = 8;
    a = cc.Vertex2F.prototype;
    a._getX = function() {
        return this._xF32[0]
    };
    a._setX = function(a) {
        this._xF32[0] = a
    };
    a._getY = function() {
        return this._yF32[0]
    };
    a._setY = function(a) {
        this._yF32[0] = a
    };
    cc.defineGetterSetter(a, "x", a._getX, a._setX);
    cc.defineGetterSetter(a, "y", a._getY, a._setY);
    cc.Vertex3F = function(a, d, e, f, g) {
        this._arrayBuffer = f || new ArrayBuffer(cc.Vertex3F.BYTES_PER_ELEMENT);
        this._offset = g || 0;
        f = this._arrayBuffer;
        g = this._offset;
        this._xF32 = new Float32Array(f,
            g, 1);
        this._xF32[0] = a || 0;
        this._yF32 = new Float32Array(f, g + Float32Array.BYTES_PER_ELEMENT, 1);
        this._yF32[0] = d || 0;
        this._zF32 = new Float32Array(f, g + 2 * Float32Array.BYTES_PER_ELEMENT, 1);
        this._zF32[0] = e || 0
    };
    cc.Vertex3F.BYTES_PER_ELEMENT = 12;
    a = cc.Vertex3F.prototype;
    a._getX = function() {
        return this._xF32[0]
    };
    a._setX = function(a) {
        this._xF32[0] = a
    };
    a._getY = function() {
        return this._yF32[0]
    };
    a._setY = function(a) {
        this._yF32[0] = a
    };
    a._getZ = function() {
        return this._zF32[0]
    };
    a._setZ = function(a) {
        this._zF32[0] = a
    };
    cc.defineGetterSetter(a,
        "x", a._getX, a._setX);
    cc.defineGetterSetter(a, "y", a._getY, a._setY);
    cc.defineGetterSetter(a, "z", a._getZ, a._setZ);
    cc.Tex2F = function(a, d, e, f) {
        this._arrayBuffer = e || new ArrayBuffer(cc.Tex2F.BYTES_PER_ELEMENT);
        this._offset = f || 0;
        this._uF32 = new Float32Array(this._arrayBuffer, this._offset, 1);
        this._vF32 = new Float32Array(this._arrayBuffer, this._offset + 4, 1);
        this._uF32[0] = a || 0;
        this._vF32[0] = d || 0
    };
    cc.Tex2F.BYTES_PER_ELEMENT = 8;
    a = cc.Tex2F.prototype;
    a._getU = function() {
        return this._uF32[0]
    };
    a._setU = function(a) {
        this._uF32[0] =
            a
    };
    a._getV = function() {
        return this._vF32[0]
    };
    a._setV = function(a) {
        this._vF32[0] = a
    };
    cc.defineGetterSetter(a, "u", a._getU, a._setU);
    cc.defineGetterSetter(a, "v", a._getV, a._setV);
    cc.Quad2 = function(a, d, e, f, g, h) {
        this._arrayBuffer = g || new ArrayBuffer(cc.Quad2.BYTES_PER_ELEMENT);
        this._offset = h || 0;
        g = this._arrayBuffer;
        h = cc.Vertex2F.BYTES_PER_ELEMENT;
        this._tl = a ? new cc.Vertex2F(a.x, a.y, g, 0) : new cc.Vertex2F(0, 0, g, 0);
        this._tr = d ? new cc.Vertex2F(d.x, d.y, g, h) : new cc.Vertex2F(0, 0, g, h);
        this._bl = e ? new cc.Vertex2F(e.x, e.y,
            g, 2 * h) : new cc.Vertex2F(0, 0, g, 2 * h);
        this._br = f ? new cc.Vertex2F(f.x, f.y, g, 3 * h) : new cc.Vertex2F(0, 0, g, 3 * h)
    };
    cc.Quad2.BYTES_PER_ELEMENT = 32;
    a = cc.Quad2.prototype;
    a._getTL = function() {
        return this._tl
    };
    a._setTL = function(a) {
        this._tl.x = a.x;
        this._tl.y = a.y
    };
    a._getTR = function() {
        return this._tr
    };
    a._setTR = function(a) {
        this._tr.x = a.x;
        this._tr.y = a.y
    };
    a._getBL = function() {
        return this._bl
    };
    a._setBL = function(a) {
        this._bl.x = a.x;
        this._bl.y = a.y
    };
    a._getBR = function() {
        return this._br
    };
    a._setBR = function(a) {
        this._br.x = a.x;
        this._br.y =
            a.y
    };
    cc.defineGetterSetter(a, "tl", a._getTL, a._setTL);
    cc.defineGetterSetter(a, "tr", a._getTR, a._setTR);
    cc.defineGetterSetter(a, "bl", a._getBL, a._setBL);
    cc.defineGetterSetter(a, "br", a._getBR, a._setBR);
    cc.Quad3 = function(a, d, e, f) {
        this.bl = a || new cc.Vertex3F(0, 0, 0);
        this.br = d || new cc.Vertex3F(0, 0, 0);
        this.tl = e || new cc.Vertex3F(0, 0, 0);
        this.tr = f || new cc.Vertex3F(0, 0, 0)
    };
    cc.V3F_C4B_T2F = function(a, d, e, f, g) {
        this._arrayBuffer = f || new ArrayBuffer(cc.V3F_C4B_T2F.BYTES_PER_ELEMENT);
        this._offset = g || 0;
        f = this._arrayBuffer;
        g = this._offset;
        var h = cc.Vertex3F.BYTES_PER_ELEMENT;
        this._vertices = a ? new cc.Vertex3F(a.x, a.y, a.z, f, g) : new cc.Vertex3F(0, 0, 0, f, g);
        this._colors = d ? cc.color(d.r, d.g, d.b, d.a, f, g + h) : cc.color(0, 0, 0, 0, f, g + h);
        this._texCoords = e ? new cc.Tex2F(e.u, e.v, f, g + h + cc.Color.BYTES_PER_ELEMENT) : new cc.Tex2F(0, 0, f, g + h + cc.Color.BYTES_PER_ELEMENT)
    };
    cc.V3F_C4B_T2F.BYTES_PER_ELEMENT = 24;
    a = cc.V3F_C4B_T2F.prototype;
    a._getVertices = function() {
        return this._vertices
    };
    a._setVertices = function(a) {
        var d = this._vertices;
        d.x = a.x;
        d.y = a.y;
        d.z =
            a.z
    };
    a._getColor = function() {
        return this._colors
    };
    a._setColor = function(a) {
        var d = this._colors;
        d.r = a.r;
        d.g = a.g;
        d.b = a.b;
        d.a = a.a
    };
    a._getTexCoords = function() {
        return this._texCoords
    };
    a._setTexCoords = function(a) {
        this._texCoords.u = a.u;
        this._texCoords.v = a.v
    };
    cc.defineGetterSetter(a, "vertices", a._getVertices, a._setVertices);
    cc.defineGetterSetter(a, "colors", a._getColor, a._setColor);
    cc.defineGetterSetter(a, "texCoords", a._getTexCoords, a._setTexCoords);
    cc.V3F_C4B_T2F_Quad = function(a, d, e, f, g, h) {
        this._arrayBuffer =
            g || new ArrayBuffer(cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT);
        this._offset = h || 0;
        g = this._arrayBuffer;
        h = this._offset;
        var k = cc.V3F_C4B_T2F.BYTES_PER_ELEMENT;
        this._tl = a ? new cc.V3F_C4B_T2F(a.vertices, a.colors, a.texCoords, g, h) : new cc.V3F_C4B_T2F(null, null, null, g, h);
        this._bl = d ? new cc.V3F_C4B_T2F(d.vertices, d.colors, d.texCoords, g, h + k) : new cc.V3F_C4B_T2F(null, null, null, g, h + k);
        this._tr = e ? new cc.V3F_C4B_T2F(e.vertices, e.colors, e.texCoords, g, h + 2 * k) : new cc.V3F_C4B_T2F(null, null, null, g, h + 2 * k);
        this._br = f ? new cc.V3F_C4B_T2F(f.vertices,
            f.colors, f.texCoords, g, h + 3 * k) : new cc.V3F_C4B_T2F(null, null, null, g, h + 3 * k)
    };
    cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT = 96;
    a = cc.V3F_C4B_T2F_Quad.prototype;
    a._getTL = function() {
        return this._tl
    };
    a._setTL = function(a) {
        var d = this._tl;
        d.vertices = a.vertices;
        d.colors = a.colors;
        d.texCoords = a.texCoords
    };
    a._getBL = function() {
        return this._bl
    };
    a._setBL = function(a) {
        var d = this._bl;
        d.vertices = a.vertices;
        d.colors = a.colors;
        d.texCoords = a.texCoords
    };
    a._getTR = function() {
        return this._tr
    };
    a._setTR = function(a) {
        var d = this._tr;
        d.vertices =
            a.vertices;
        d.colors = a.colors;
        d.texCoords = a.texCoords
    };
    a._getBR = function() {
        return this._br
    };
    a._setBR = function(a) {
        var d = this._br;
        d.vertices = a.vertices;
        d.colors = a.colors;
        d.texCoords = a.texCoords
    };
    a._getArrayBuffer = function() {
        return this._arrayBuffer
    };
    cc.defineGetterSetter(a, "tl", a._getTL, a._setTL);
    cc.defineGetterSetter(a, "tr", a._getTR, a._setTR);
    cc.defineGetterSetter(a, "bl", a._getBL, a._setBL);
    cc.defineGetterSetter(a, "br", a._getBR, a._setBR);
    cc.defineGetterSetter(a, "arrayBuffer", a._getArrayBuffer, null);
    cc.V3F_C4B_T2F_QuadZero = function() {
        return new cc.V3F_C4B_T2F_Quad
    };
    cc.V3F_C4B_T2F_QuadCopy = function(a) {
        if (!a) return cc.V3F_C4B_T2F_QuadZero();
        var d = a.tl,
            e = a.bl,
            f = a.tr;
        a = a.br;
        return {
            tl: {
                vertices: {
                    x: d.vertices.x,
                    y: d.vertices.y,
                    z: d.vertices.z
                },
                colors: {
                    r: d.colors.r,
                    g: d.colors.g,
                    b: d.colors.b,
                    a: d.colors.a
                },
                texCoords: {
                    u: d.texCoords.u,
                    v: d.texCoords.v
                }
            },
            bl: {
                vertices: {
                    x: e.vertices.x,
                    y: e.vertices.y,
                    z: e.vertices.z
                },
                colors: {
                    r: e.colors.r,
                    g: e.colors.g,
                    b: e.colors.b,
                    a: e.colors.a
                },
                texCoords: {
                    u: e.texCoords.u,
                    v: e.texCoords.v
                }
            },
            tr: {
                vertices: {
                    x: f.vertices.x,
                    y: f.vertices.y,
                    z: f.vertices.z
                },
                colors: {
                    r: f.colors.r,
                    g: f.colors.g,
                    b: f.colors.b,
                    a: f.colors.a
                },
                texCoords: {
                    u: f.texCoords.u,
                    v: f.texCoords.v
                }
            },
            br: {
                vertices: {
                    x: a.vertices.x,
                    y: a.vertices.y,
                    z: a.vertices.z
                },
                colors: {
                    r: a.colors.r,
                    g: a.colors.g,
                    b: a.colors.b,
                    a: a.colors.a
                },
                texCoords: {
                    u: a.texCoords.u,
                    v: a.texCoords.v
                }
            }
        }
    };
    cc.V3F_C4B_T2F_QuadsCopy = function(a) {
        if (!a) return [];
        for (var d = [], e = 0; e < a.length; e++) d.push(cc.V3F_C4B_T2F_QuadCopy(a[e]));
        return d
    };
    cc.V2F_C4B_T2F = function(a, d, e, f, g) {
        this._arrayBuffer =
            f || new ArrayBuffer(cc.V2F_C4B_T2F.BYTES_PER_ELEMENT);
        this._offset = g || 0;
        f = this._arrayBuffer;
        g = this._offset;
        var h = cc.Vertex2F.BYTES_PER_ELEMENT;
        this._vertices = a ? new cc.Vertex2F(a.x, a.y, f, g) : new cc.Vertex2F(0, 0, f, g);
        this._colors = d ? cc.color(d.r, d.g, d.b, d.a, f, g + h) : cc.color(0, 0, 0, 0, f, g + h);
        this._texCoords = e ? new cc.Tex2F(e.u, e.v, f, g + h + cc.Color.BYTES_PER_ELEMENT) : new cc.Tex2F(0, 0, f, g + h + cc.Color.BYTES_PER_ELEMENT)
    };
    cc.V2F_C4B_T2F.BYTES_PER_ELEMENT = 20;
    a = cc.V2F_C4B_T2F.prototype;
    a._getVertices = function() {
        return this._vertices
    };
    a._setVertices = function(a) {
        this._vertices.x = a.x;
        this._vertices.y = a.y
    };
    a._getColor = function() {
        return this._colors
    };
    a._setColor = function(a) {
        var d = this._colors;
        d.r = a.r;
        d.g = a.g;
        d.b = a.b;
        d.a = a.a
    };
    a._getTexCoords = function() {
        return this._texCoords
    };
    a._setTexCoords = function(a) {
        this._texCoords.u = a.u;
        this._texCoords.v = a.v
    };
    cc.defineGetterSetter(a, "vertices", a._getVertices, a._setVertices);
    cc.defineGetterSetter(a, "colors", a._getColor, a._setColor);
    cc.defineGetterSetter(a, "texCoords", a._getTexCoords, a._setTexCoords);
    cc.V2F_C4B_T2F_Triangle = function(a, d, e, f, g) {
        this._arrayBuffer = f || new ArrayBuffer(cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT);
        this._offset = g || 0;
        f = this._arrayBuffer;
        g = this._offset;
        var h = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
        this._a = a ? new cc.V2F_C4B_T2F(a.vertices, a.colors, a.texCoords, f, g) : new cc.V2F_C4B_T2F(null, null, null, f, g);
        this._b = d ? new cc.V2F_C4B_T2F(d.vertices, d.colors, d.texCoords, f, g + h) : new cc.V2F_C4B_T2F(null, null, null, f, g + h);
        this._c = e ? new cc.V2F_C4B_T2F(e.vertices, e.colors, e.texCoords, f, g + 2 * h) : new cc.V2F_C4B_T2F(null,
            null, null, f, g + 2 * h)
    };
    cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT = 60;
    a = cc.V2F_C4B_T2F_Triangle.prototype;
    a._getA = function() {
        return this._a
    };
    a._setA = function(a) {
        var d = this._a;
        d.vertices = a.vertices;
        d.colors = a.colors;
        d.texCoords = a.texCoords
    };
    a._getB = function() {
        return this._b
    };
    a._setB = function(a) {
        var d = this._b;
        d.vertices = a.vertices;
        d.colors = a.colors;
        d.texCoords = a.texCoords
    };
    a._getC = function() {
        return this._c
    };
    a._setC = function(a) {
        var d = this._c;
        d.vertices = a.vertices;
        d.colors = a.colors;
        d.texCoords = a.texCoords
    };
    cc.defineGetterSetter(a, "a", a._getA, a._setA);
    cc.defineGetterSetter(a, "b", a._getB, a._setB);
    cc.defineGetterSetter(a, "c", a._getC, a._setC)
};
cc._tmp.PrototypeColor = function() {
    var a = cc.color;
    a._getWhite = function() {
        return a(255, 255, 255)
    };
    a._getYellow = function() {
        return a(255, 255, 0)
    };
    a._getBlue = function() {
        return a(0, 0, 255)
    };
    a._getGreen = function() {
        return a(0, 255, 0)
    };
    a._getRed = function() {
        return a(255, 0, 0)
    };
    a._getMagenta = function() {
        return a(255, 0, 255)
    };
    a._getBlack = function() {
        return a(0, 0, 0)
    };
    a._getOrange = function() {
        return a(255, 127, 0)
    };
    a._getGray = function() {
        return a(166, 166, 166)
    };
    cc.defineGetterSetter(a, "WHITE", a._getWhite);
    cc.defineGetterSetter(a,
        "YELLOW", a._getYellow);
    cc.defineGetterSetter(a, "BLUE", a._getBlue);
    cc.defineGetterSetter(a, "GREEN", a._getGreen);
    cc.defineGetterSetter(a, "RED", a._getRed);
    cc.defineGetterSetter(a, "MAGENTA", a._getMagenta);
    cc.defineGetterSetter(a, "BLACK", a._getBlack);
    cc.defineGetterSetter(a, "ORANGE", a._getOrange);
    cc.defineGetterSetter(a, "GRAY", a._getGray);
    cc.BlendFunc._disable = function() {
        return new cc.BlendFunc(cc.ONE, cc.ZERO)
    };
    cc.BlendFunc._alphaPremultiplied = function() {
        return new cc.BlendFunc(cc.ONE, cc.ONE_MINUS_SRC_ALPHA)
    };
    cc.BlendFunc._alphaNonPremultiplied = function() {
        return new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA)
    };
    cc.BlendFunc._additive = function() {
        return new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE)
    };
    cc.defineGetterSetter(cc.BlendFunc, "DISABLE", cc.BlendFunc._disable);
    cc.defineGetterSetter(cc.BlendFunc, "ALPHA_PREMULTIPLIED", cc.BlendFunc._alphaPremultiplied);
    cc.defineGetterSetter(cc.BlendFunc, "ALPHA_NON_PREMULTIPLIED", cc.BlendFunc._alphaNonPremultiplied);
    cc.defineGetterSetter(cc.BlendFunc, "ADDITIVE", cc.BlendFunc._additive)
};
cc.Color = function(a, b, d, e) {
    this.r = a || 0;
    this.g = b || 0;
    this.b = d || 0;
    this.a = null == e ? 255 : e
};
cc.color = function(a, b, d, e) {
    return void 0 === a ? {
        r: 0,
        g: 0,
        b: 0,
        a: 255
    } : cc.isString(a) ? cc.hexToColor(a) : cc.isObject(a) ? {
        r: a.r,
        g: a.g,
        b: a.b,
        a: null == a.a ? 255 : a.a
    } : {
        r: a,
        g: b,
        b: d,
        a: null == e ? 255 : e
    }
};
cc.colorEqual = function(a, b) {
    return a.r === b.r && a.g === b.g && a.b === b.b
};
cc.Acceleration = function(a, b, d, e) {
    this.x = a || 0;
    this.y = b || 0;
    this.z = d || 0;
    this.timestamp = e || 0
};
cc.Vertex2F = function(a, b) {
    this.x = a || 0;
    this.y = b || 0
};
cc.vertex2 = function(a, b) {
    return new cc.Vertex2F(a, b)
};
cc.Vertex3F = function(a, b, d) {
    this.x = a || 0;
    this.y = b || 0;
    this.z = d || 0
};
cc.vertex3 = function(a, b, d) {
    return new cc.Vertex3F(a, b, d)
};
cc.Tex2F = function(a, b) {
    this.u = a || 0;
    this.v = b || 0
};
cc.tex2 = function(a, b) {
    return new cc.Tex2F(a, b)
};
cc.BlendFunc = function(a, b) {
    this.src = a;
    this.dst = b
};
cc.blendFuncDisable = function() {
    return new cc.BlendFunc(cc.ONE, cc.ZERO)
};
cc.hexToColor = function(a) {
    a = a.replace(/^#?/, "0x");
    a = parseInt(a);
    return cc.color(a >> 16, (a >> 8) % 256, a % 256)
};
cc.colorToHex = function(a) {
    var b = a.r.toString(16),
        d = a.g.toString(16),
        e = a.b.toString(16);
    return "#" + (16 > a.r ? "0" + b : b) + (16 > a.g ? "0" + d : d) + (16 > a.b ? "0" + e : e)
};
cc.TEXT_ALIGNMENT_LEFT = 0;
cc.TEXT_ALIGNMENT_CENTER = 1;
cc.TEXT_ALIGNMENT_RIGHT = 2;
cc.VERTICAL_TEXT_ALIGNMENT_TOP = 0;
cc.VERTICAL_TEXT_ALIGNMENT_CENTER = 1;
cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM = 2;
cc._Dictionary = cc.Class.extend({
    _keyMapTb: null,
    _valueMapTb: null,
    __currId: 0,
    ctor: function() {
        this._keyMapTb = {};
        this._valueMapTb = {};
        this.__currId = 2 << (0 | 10 * Math.random())
    },
    __getKey: function() {
        this.__currId++;
        return "key_" + this.__currId
    },
    setObject: function(a, b) {
        if (null != b) {
            var d = this.__getKey();
            this._keyMapTb[d] = b;
            this._valueMapTb[d] = a
        }
    },
    objectForKey: function(a) {
        if (null == a) return null;
        var b = this._keyMapTb,
            d;
        for (d in b)
            if (b[d] === a) return this._valueMapTb[d];
        return null
    },
    valueForKey: function(a) {
        return this.objectForKey(a)
    },
    removeObjectForKey: function(a) {
        if (null != a) {
            var b = this._keyMapTb,
                d;
            for (d in b)
                if (b[d] === a) {
                    delete this._valueMapTb[d];
                    delete b[d];
                    break
                }
        }
    },
    removeObjectsForKeys: function(a) {
        if (null != a)
            for (var b = 0; b < a.length; b++) this.removeObjectForKey(a[b])
    },
    allKeys: function() {
        var a = [],
            b = this._keyMapTb,
            d;
        for (d in b) a.push(b[d]);
        return a
    },
    removeAllObjects: function() {
        this._keyMapTb = {};
        this._valueMapTb = {}
    },
    count: function() {
        return this.allKeys().length
    }
});
cc.FontDefinition = function(a) {
    this.fontName = "Arial";
    this.fontSize = 12;
    this.textAlign = cc.TEXT_ALIGNMENT_CENTER;
    this.verticalAlign = cc.VERTICAL_TEXT_ALIGNMENT_TOP;
    this.fillStyle = cc.color(255, 255, 255, 255);
    this.boundingHeight = this.boundingWidth = 0;
    this.strokeEnabled = !1;
    this.strokeStyle = cc.color(255, 255, 255, 255);
    this.lineWidth = 1;
    this.fontWeight = this.fontStyle = this.lineHeight = "normal";
    this.shadowEnabled = !1;
    this.shadowBlur = this.shadowOffsetY = this.shadowOffsetX = 0;
    this.shadowOpacity = 1;
    if (a && a instanceof Object)
        for (var b in a) this[b] =
            a[b]
};
cc.FontDefinition.prototype._getCanvasFontStr = function() {
    return this.fontStyle + " " + this.fontWeight + " " + this.fontSize + "px/" + (!this.lineHeight.charAt ? this.lineHeight + "px" : this.lineHeight) + " '" + this.fontName + "'"
};
cc._renderType === cc._RENDER_TYPE_WEBGL && (cc.assert(cc.isFunction(cc._tmp.WebGLColor), cc._LogInfos.MissingFile, "CCTypesWebGL.js"), cc._tmp.WebGLColor(), delete cc._tmp.WebGLColor);
cc.assert(cc.isFunction(cc._tmp.PrototypeColor), cc._LogInfos.MissingFile, "CCTypesPropertyDefine.js");
cc._tmp.PrototypeColor();
delete cc._tmp.PrototypeColor;
cc.Touches = [];
cc.TouchesIntergerDict = {};
cc.DENSITYDPI_DEVICE = "device-dpi";
cc.DENSITYDPI_HIGH = "high-dpi";
cc.DENSITYDPI_MEDIUM = "medium-dpi";
cc.DENSITYDPI_LOW = "low-dpi";
cc.__BrowserGetter = {
    init: function() {
        this.html = document.getElementsByTagName("html")[0]
    },
    availWidth: function(a) {
        return !a || a === this.html ? window.innerWidth : a.clientWidth
    },
    availHeight: function(a) {
        return !a || a === this.html ? window.innerHeight : a.clientHeight
    },
    meta: {
        width: "device-width",
        "user-scalable": "no"
    },
    adaptationType: cc.sys.browserType
}; - 1 < window.navigator.userAgent.indexOf("OS 8_1_") && (cc.__BrowserGetter.adaptationType = cc.sys.BROWSER_TYPE_MIUI);
cc.sys.os === cc.sys.OS_IOS && (cc.__BrowserGetter.adaptationType = cc.sys.BROWSER_TYPE_SAFARI);
switch (cc.__BrowserGetter.adaptationType) {
    case cc.sys.BROWSER_TYPE_SAFARI:
        cc.__BrowserGetter.meta["minimal-ui"] = "true";
        cc.__BrowserGetter.availWidth = function(a) {
            return a.clientWidth
        };
        cc.__BrowserGetter.availHeight = function(a) {
            return a.clientHeight
        };
        break;
    case cc.sys.BROWSER_TYPE_CHROME:
        cc.__BrowserGetter.__defineGetter__("target-densitydpi", function() {
            return cc.view._targetDensityDPI
        });
    case cc.sys.BROWSER_TYPE_SOUGOU:
    case cc.sys.BROWSER_TYPE_UC:
        cc.__BrowserGetter.availWidth = function(a) {
            return a.clientWidth
        };
        cc.__BrowserGetter.availHeight = function(a) {
            return a.clientHeight
        };
        break;
    case cc.sys.BROWSER_TYPE_MIUI:
        cc.__BrowserGetter.init = function(a) {
            if (!a.__resizeWithBrowserSize) {
                var b = function() {
                    a.setDesignResolutionSize(a._designResolutionSize.width, a._designResolutionSize.height, a._resolutionPolicy);
                    window.removeEventListener("resize", b, !1)
                };
                window.addEventListener("resize", b, !1)
            }
        }
}
cc.EGLView = cc.Class.extend({
    _delegate: null,
    _frameSize: null,
    _designResolutionSize: null,
    _originalDesignResolutionSize: null,
    _viewPortRect: null,
    _visibleRect: null,
    _retinaEnabled: !1,
    _autoFullScreen: !0,
    _devicePixelRatio: 1,
    _viewName: "",
    _resizeCallback: null,
    _scaleX: 1,
    _originalScaleX: 1,
    _scaleY: 1,
    _originalScaleY: 1,
    _indexBitsUsed: 0,
    _maxTouches: 5,
    _resolutionPolicy: null,
    _rpExactFit: null,
    _rpShowAll: null,
    _rpNoBorder: null,
    _rpFixedHeight: null,
    _rpFixedWidth: null,
    _initialized: !1,
    _captured: !1,
    _wnd: null,
    _hDC: null,
    _hRC: null,
    _supportTouch: !1,
    _contentTranslateLeftTop: null,
    _frame: null,
    _frameZoomFactor: 1,
    __resizeWithBrowserSize: !1,
    _isAdjustViewPort: !0,
    _targetDensityDPI: null,
    ctor: function() {
        var a = document,
            b = cc.ContainerStrategy,
            d = cc.ContentStrategy;
        cc.__BrowserGetter.init(this);
        this._frame = cc.container.parentNode === a.body ? a.documentElement : cc.container.parentNode;
        this._frameSize = cc.size(0, 0);
        this._initFrameSize();
        var a = cc._canvas.width,
            e = cc._canvas.height;
        this._designResolutionSize = cc.size(a, e);
        this._originalDesignResolutionSize =
            cc.size(a, e);
        this._viewPortRect = cc.rect(0, 0, a, e);
        this._visibleRect = cc.rect(0, 0, a, e);
        this._contentTranslateLeftTop = {
            left: 0,
            top: 0
        };
        this._viewName = "Cocos2dHTML5";
        a = cc.sys;
        this.enableRetina(a.os === a.OS_IOS || a.os === a.OS_OSX);
        cc.visibleRect && cc.visibleRect.init(this._visibleRect);
        this._rpExactFit = new cc.ResolutionPolicy(b.EQUAL_TO_FRAME, d.EXACT_FIT);
        this._rpShowAll = new cc.ResolutionPolicy(b.PROPORTION_TO_FRAME, d.SHOW_ALL);
        this._rpNoBorder = new cc.ResolutionPolicy(b.EQUAL_TO_FRAME, d.NO_BORDER);
        this._rpFixedHeight =
            new cc.ResolutionPolicy(b.EQUAL_TO_FRAME, d.FIXED_HEIGHT);
        this._rpFixedWidth = new cc.ResolutionPolicy(b.EQUAL_TO_FRAME, d.FIXED_WIDTH);
        this._hDC = cc._canvas;
        this._hRC = cc._renderContext;
        this._targetDensityDPI = cc.DENSITYDPI_HIGH
    },
    _resizeEvent: function() {
        var a;
        a = this.setDesignResolutionSize ? this : cc.view;
        var b = a._frameSize.width,
            d = a._frameSize.height;
        a._initFrameSize();
        a._frameSize.width === b && a._frameSize.height === d || (a._resizeCallback && a._resizeCallback.call(), b = a._originalDesignResolutionSize.width, d = a._originalDesignResolutionSize.height,
            0 < b && a.setDesignResolutionSize(b, d, a._resolutionPolicy))
    },
    setTargetDensityDPI: function(a) {
        this._targetDensityDPI = a;
        this._setViewPortMeta()
    },
    getTargetDensityDPI: function() {
        return this._targetDensityDPI
    },
    resizeWithBrowserSize: function(a) {
        a ? this.__resizeWithBrowserSize || (this.__resizeWithBrowserSize = !0, cc._addEventListener(window, "resize", this._resizeEvent), cc._addEventListener(window, "orientationchange", this._resizeEvent)) : this.__resizeWithBrowserSize && (this.__resizeWithBrowserSize = !1, window.removeEventListener("resize",
            this._resizeEvent), window.removeEventListener("orientationchange", this._resizeEvent))
    },
    setResizeCallback: function(a) {
        if (cc.isFunction(a) || null == a) this._resizeCallback = a
    },
    _initFrameSize: function() {
        var a = this._frameSize;
        a.width = cc.__BrowserGetter.availWidth(this._frame);
        a.height = cc.__BrowserGetter.availHeight(this._frame)
    },
    _adjustSizeKeepCanvasSize: function() {
        var a = this._originalDesignResolutionSize.width,
            b = this._originalDesignResolutionSize.height;
        0 < a && this.setDesignResolutionSize(a, b, this._resolutionPolicy)
    },
    _setViewPortMeta: function() {
        if (this._isAdjustViewPort) {
            var a = document.getElementById("cocosMetaElement");
            a && document.head.removeChild(a);
            var b, d = (a = document.getElementsByName("viewport")) ? a[0] : null,
                e, a = cc.newElement("meta");
            a.id = "cocosMetaElement";
            a.name = "viewport";
            a.content = "";
            b = cc.__BrowserGetter.meta;
            e = d ? d.content : "";
            for (var f in b) RegExp(f).test(e) || (e += "," + f + "\x3d" + b[f]);
            /^,/.test(e) && (e = e.substr(1));
            a.content = e;
            d && (d.content = e);
            document.head.appendChild(a)
        }
    },
    _setScaleXYForRenderTexture: function() {
        var a =
            cc.contentScaleFactor();
        this._scaleY = this._scaleX = a
    },
    _resetScale: function() {
        this._scaleX = this._originalScaleX;
        this._scaleY = this._originalScaleY
    },
    _adjustSizeToBrowser: function() {},
    initialize: function() {
        this._initialized = !0
    },
    adjustViewPort: function(a) {
        this._isAdjustViewPort = a
    },
    enableRetina: function(a) {
        this._retinaEnabled = a ? !0 : !1
    },
    isRetinaEnabled: function() {
        return this._retinaEnabled
    },
    enableAutoFullScreen: function(a) {
        this._autoFullScreen = a ? !0 : !1
    },
    isAutoFullScreenEnabled: function() {
        return this._autoFullScreen
    },
    end: function() {},
    isOpenGLReady: function() {
        return null !== this._hDC && null !== this._hRC
    },
    setFrameZoomFactor: function(a) {
        this._frameZoomFactor = a;
        this.centerWindow();
        cc.director.setProjection(cc.director.getProjection())
    },
    swapBuffers: function() {},
    setIMEKeyboardState: function(a) {},
    setContentTranslateLeftTop: function(a, b) {
        this._contentTranslateLeftTop = {
            left: a,
            top: b
        }
    },
    getContentTranslateLeftTop: function() {
        return this._contentTranslateLeftTop
    },
    getFrameSize: function() {
        return cc.size(this._frameSize.width, this._frameSize.height)
    },
    setFrameSize: function(a, b) {
        this._frameSize.width = a;
        this._frameSize.height = b;
        this._frame.style.width = a + "px";
        this._frame.style.height = b + "px";
        this._resizeEvent();
        cc.director.setProjection(cc.director.getProjection())
    },
    centerWindow: function() {},
    getVisibleSize: function() {
        return cc.size(this._visibleRect.width, this._visibleRect.height)
    },
    getVisibleOrigin: function() {
        return cc.p(this._visibleRect.x, this._visibleRect.y)
    },
    canSetContentScaleFactor: function() {
        return !0
    },
    getResolutionPolicy: function() {
        return this._resolutionPolicy
    },
    setResolutionPolicy: function(a) {
        if (a instanceof cc.ResolutionPolicy) this._resolutionPolicy = a;
        else {
            var b = cc.ResolutionPolicy;
            a === b.EXACT_FIT && (this._resolutionPolicy = this._rpExactFit);
            a === b.SHOW_ALL && (this._resolutionPolicy = this._rpShowAll);
            a === b.NO_BORDER && (this._resolutionPolicy = this._rpNoBorder);
            a === b.FIXED_HEIGHT && (this._resolutionPolicy = this._rpFixedHeight);
            a === b.FIXED_WIDTH && (this._resolutionPolicy = this._rpFixedWidth)
        }
    },
    setDesignResolutionSize: function(a, b, d) {
        if (0 < a || 0 < b)
            if (this.setResolutionPolicy(d),
                d = this._resolutionPolicy) {
                d.preApply(this);
                cc.sys.isMobile && this._setViewPortMeta();
                this._initFrameSize();
                this._originalDesignResolutionSize.width = this._designResolutionSize.width = a;
                this._originalDesignResolutionSize.height = this._designResolutionSize.height = b;
                var e = d.apply(this, this._designResolutionSize);
                e.scale && 2 === e.scale.length && (this._scaleX = e.scale[0], this._scaleY = e.scale[1]);
                e.viewport && (a = this._viewPortRect, b = this._visibleRect, e = e.viewport, a.x = e.x, a.y = e.y, a.width = e.width, a.height = e.height,
                    b.x = -a.x / this._scaleX, b.y = -a.y / this._scaleY, b.width = cc._canvas.width / this._scaleX, b.height = cc._canvas.height / this._scaleY, cc._renderContext.setOffset && cc._renderContext.setOffset(a.x, -a.y));
                a = cc.director;
                a._winSizeInPoints.width = this._designResolutionSize.width;
                a._winSizeInPoints.height = this._designResolutionSize.height;
                d.postApply(this);
                cc.winSize.width = a._winSizeInPoints.width;
                cc.winSize.height = a._winSizeInPoints.height;
                cc._renderType === cc._RENDER_TYPE_WEBGL && (a._createStatsLabel(), a.setGLDefaultValues());
                this._originalScaleX = this._scaleX;
                this._originalScaleY = this._scaleY;
                cc.DOM && cc.DOM._resetEGLViewDiv();
                cc.visibleRect && cc.visibleRect.init(this._visibleRect)
            } else cc.log(cc._LogInfos.EGLView_setDesignResolutionSize_2);
        else cc.log(cc._LogInfos.EGLView_setDesignResolutionSize)
    },
    getDesignResolutionSize: function() {
        return cc.size(this._designResolutionSize.width, this._designResolutionSize.height)
    },
    setViewPortInPoints: function(a, b, d, e) {
        var f = this._frameZoomFactor,
            g = this._scaleX,
            h = this._scaleY;
        cc._renderContext.viewport(a *
            g * f + this._viewPortRect.x * f, b * h * f + this._viewPortRect.y * f, d * g * f, e * h * f)
    },
    setScissorInPoints: function(a, b, d, e) {
        var f = this._frameZoomFactor,
            g = this._scaleX,
            h = this._scaleY;
        cc._renderContext.scissor(a * g * f + this._viewPortRect.x * f, b * h * f + this._viewPortRect.y * f, d * g * f, e * h * f)
    },
    isScissorEnabled: function() {
        var a = cc._renderContext;
        return a.isEnabled(a.SCISSOR_TEST)
    },
    getScissorRect: function() {
        var a = cc._renderContext,
            b = this._scaleX,
            d = this._scaleY,
            a = a.getParameter(a.SCISSOR_BOX);
        return cc.rect((a[0] - this._viewPortRect.x) /
            b, (a[1] - this._viewPortRect.y) / d, a[2] / b, a[3] / d)
    },
    setViewName: function(a) {
        null != a && 0 < a.length && (this._viewName = a)
    },
    getViewName: function() {
        return this._viewName
    },
    getViewPortRect: function() {
        return this._viewPortRect
    },
    getScaleX: function() {
        return this._scaleX
    },
    getScaleY: function() {
        return this._scaleY
    },
    getDevicePixelRatio: function() {
        return this._devicePixelRatio
    },
    convertToLocationInView: function(a, b, d) {
        return {
            x: this._devicePixelRatio * (a - d.left),
            y: this._devicePixelRatio * (d.top + d.height - b)
        }
    },
    _convertMouseToLocationInView: function(a,
        b) {
        var d = this._viewPortRect;
        a.x = (this._devicePixelRatio * (a.x - b.left) - d.x) / this._scaleX;
        a.y = (this._devicePixelRatio * (b.top + b.height - a.y) - d.y) / this._scaleY
    },
    _convertTouchesWithScale: function(a) {
        for (var b = this._viewPortRect, d = this._scaleX, e = this._scaleY, f, g, h, k = 0; k < a.length; k++) f = a[k], g = f._point, h = f._prevPoint, f._setPoint((g.x - b.x) / d, (g.y - b.y) / e), f._setPrevPoint((h.x - b.x) / d, (h.y - b.y) / e)
    }
});
cc.EGLView._getInstance = function() {
    this._instance || (this._instance = this._instance || new cc.EGLView, this._instance.initialize());
    return this._instance
};
cc.ContainerStrategy = cc.Class.extend({
    preApply: function(a) {},
    apply: function(a, b) {},
    postApply: function(a) {},
    _setupContainer: function(a, b, d) {
        var e = a._frame;
        cc.view._autoFullScreen && (cc.sys.isMobile && e === document.documentElement) && cc.screen.autoFullScreen(e);
        var e = cc._canvas,
            f = cc.container;
        f.style.width = e.style.width = b + "px";
        f.style.height = e.style.height = d + "px";
        f = a._devicePixelRatio = 1;
        a.isRetinaEnabled() && (f = a._devicePixelRatio = window.devicePixelRatio || 1);
        e.width = b * f;
        e.height = d * f;
        cc._renderContext.resetCache &&
            cc._renderContext.resetCache();
        a = document.body;
        var g;
        if (a && (g = a.style)) g.paddingTop = g.paddingTop || "0px", g.paddingRight = g.paddingRight || "0px", g.paddingBottom = g.paddingBottom || "0px", g.paddingLeft = g.paddingLeft || "0px", g.borderTop = g.borderTop || "0px", g.borderRight = g.borderRight || "0px", g.borderBottom = g.borderBottom || "0px", g.borderLeft = g.borderLeft || "0px", g.marginTop = g.marginTop || "0px", g.marginRight = g.marginRight || "0px", g.marginBottom = g.marginBottom || "0px", g.marginLeft = g.marginLeft || "0px"
    },
    _fixContainer: function() {
        document.body.insertBefore(cc.container,
            document.body.firstChild);
        var a = document.body.style;
        a.width = window.innerWidth + "px";
        a.height = window.innerHeight + "px";
        a.overflow = "hidden";
        a = cc.container.style;
        a.position = "fixed";
        a.left = a.top = "0px";
        document.body.scrollTop = 0
    }
});
cc.ContentStrategy = cc.Class.extend({
    _result: {
        scale: [1, 1],
        viewport: null
    },
    _buildResult: function(a, b, d, e, f, g) {
        2 > Math.abs(a - d) && (d = a);
        2 > Math.abs(b - e) && (e = b);
        a = cc.rect(Math.round((a - d) / 2), Math.round((b - e) / 2), d, e);
        this._result.scale = [f, g];
        this._result.viewport = a;
        return this._result
    },
    preApply: function(a) {},
    apply: function(a, b) {
        return {
            scale: [1, 1]
        }
    },
    postApply: function(a) {}
});
(function() {
    var a = cc.ContainerStrategy.extend({
            apply: function(a) {
                this._setupContainer(a, a._frameSize.width, a._frameSize.height)
            }
        }),
        b = cc.ContainerStrategy.extend({
            apply: function(a, b) {
                var d = a._frameSize.width,
                    e = a._frameSize.height,
                    f = cc.container.style,
                    p = b.width,
                    r = b.height,
                    s = d / p,
                    t = e / r,
                    u, v;
                s < t ? (u = d, v = r * s) : (u = p * t, v = e);
                p = Math.round((d - u) / 2);
                v = Math.round((e - v) / 2);
                this._setupContainer(a, d - 2 * p, e - 2 * v);
                f.marginLeft = p + "px";
                f.marginRight = p + "px";
                f.marginTop = v + "px";
                f.marginBottom = v + "px"
            }
        });
    a.extend({
        preApply: function(a) {
            this._super(a);
            a._frame = document.documentElement
        },
        apply: function(a) {
            this._super(a);
            this._fixContainer()
        }
    });
    b.extend({
        preApply: function(a) {
            this._super(a);
            a._frame = document.documentElement
        },
        apply: function(a, b) {
            this._super(a, b);
            this._fixContainer()
        }
    });
    var d = cc.ContainerStrategy.extend({
        apply: function(a) {
            this._setupContainer(a, cc._canvas.width, cc._canvas.height)
        }
    });
    cc.ContainerStrategy.EQUAL_TO_FRAME = new a;
    cc.ContainerStrategy.PROPORTION_TO_FRAME = new b;
    cc.ContainerStrategy.ORIGINAL_CONTAINER = new d;
    var a = cc.ContentStrategy.extend({
            apply: function(a,
                b) {
                var d = cc._canvas.width,
                    e = cc._canvas.height;
                return this._buildResult(d, e, d, e, d / b.width, e / b.height)
            }
        }),
        b = cc.ContentStrategy.extend({
            apply: function(a, b) {
                var d = cc._canvas.width,
                    e = cc._canvas.height,
                    f = b.width,
                    p = b.height,
                    r = d / f,
                    s = e / p,
                    t = 0,
                    u, v;
                r < s ? (t = r, u = d, v = p * t) : (t = s, u = f * t, v = e);
                return this._buildResult(d, e, u, v, t, t)
            }
        }),
        d = cc.ContentStrategy.extend({
            apply: function(a, b) {
                var d = cc._canvas.width,
                    e = cc._canvas.height,
                    f = b.width,
                    p = b.height,
                    r = d / f,
                    s = e / p,
                    t, u, v;
                r < s ? (t = s, u = f * t, v = e) : (t = r, u = d, v = p * t);
                return this._buildResult(d,
                    e, u, v, t, t)
            }
        }),
        e = cc.ContentStrategy.extend({
            apply: function(a, b) {
                var d = cc._canvas.width,
                    e = cc._canvas.height,
                    f = e / b.height;
                return this._buildResult(d, e, d, e, f, f)
            },
            postApply: function(a) {
                cc.director._winSizeInPoints = a.getVisibleSize()
            }
        }),
        f = cc.ContentStrategy.extend({
            apply: function(a, b) {
                var d = cc._canvas.width,
                    e = cc._canvas.height,
                    f = d / b.width;
                return this._buildResult(d, e, d, e, f, f)
            },
            postApply: function(a) {
                cc.director._winSizeInPoints = a.getVisibleSize()
            }
        });
    cc.ContentStrategy.EXACT_FIT = new a;
    cc.ContentStrategy.SHOW_ALL =
        new b;
    cc.ContentStrategy.NO_BORDER = new d;
    cc.ContentStrategy.FIXED_HEIGHT = new e;
    cc.ContentStrategy.FIXED_WIDTH = new f
})();
cc.ResolutionPolicy = cc.Class.extend({
    _containerStrategy: null,
    _contentStrategy: null,
    ctor: function(a, b) {
        this.setContainerStrategy(a);
        this.setContentStrategy(b)
    },
    preApply: function(a) {
        this._containerStrategy.preApply(a);
        this._contentStrategy.preApply(a)
    },
    apply: function(a, b) {
        this._containerStrategy.apply(a, b);
        return this._contentStrategy.apply(a, b)
    },
    postApply: function(a) {
        this._containerStrategy.postApply(a);
        this._contentStrategy.postApply(a)
    },
    setContainerStrategy: function(a) {
        a instanceof cc.ContainerStrategy &&
            (this._containerStrategy = a)
    },
    setContentStrategy: function(a) {
        a instanceof cc.ContentStrategy && (this._contentStrategy = a)
    }
});
cc.ResolutionPolicy.EXACT_FIT = 0;
cc.ResolutionPolicy.NO_BORDER = 1;
cc.ResolutionPolicy.SHOW_ALL = 2;
cc.ResolutionPolicy.FIXED_HEIGHT = 3;
cc.ResolutionPolicy.FIXED_WIDTH = 4;
cc.ResolutionPolicy.UNKNOWN = 5;
cc.screen = {
    _supportsFullScreen: !1,
    _preOnFullScreenChange: null,
    _touchEvent: "",
    _fn: null,
    _fnMap: [
        ["requestFullscreen", "exitFullscreen", "fullscreenchange", "fullscreenEnabled", "fullscreenElement"],
        ["requestFullScreen", "exitFullScreen", "fullScreenchange", "fullScreenEnabled", "fullScreenElement"],
        ["webkitRequestFullScreen", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitIsFullScreen", "webkitCurrentFullScreenElement"],
        ["mozRequestFullScreen", "mozCancelFullScreen", "mozfullscreenchange", "mozFullScreen",
            "mozFullScreenElement"
        ],
        ["msRequestFullscreen", "msExitFullscreen", "MSFullscreenChange", "msFullscreenEnabled", "msFullscreenElement"]
    ],
    init: function() {
        this._fn = {};
        var a, b, d = this._fnMap,
            e;
        a = 0;
        for (l = d.length; a < l; a++)
            if ((b = d[a]) && b[1] in document) {
                a = 0;
                for (e = b.length; a < e; a++) this._fn[d[0][a]] = b[a];
                break
            }
        this._supportsFullScreen = "undefined" !== typeof this._fn.requestFullscreen;
        this._touchEvent = "ontouchstart" in window ? "touchstart" : "mousedown"
    },
    fullScreen: function() {
        return this._supportsFullScreen && document[this._fn.fullscreenElement]
    },
    requestFullScreen: function(a, b) {
        if (this._supportsFullScreen) {
            a = a || document.documentElement;
            if (b) {
                var d = this._fn.fullscreenchange;
                this._preOnFullScreenChange && document.removeEventListener(d, this._preOnFullScreenChange);
                this._preOnFullScreenChange = b;
                cc._addEventListener(document, d, b, !1)
            }
            return a[this._fn.requestFullscreen]()
        }
    },
    exitFullScreen: function() {
        return this._supportsFullScreen ? document[this._fn.exitFullscreen]() : !0
    },
    autoFullScreen: function(a, b) {
        function d() {
            f.requestFullScreen(a, b);
            e.removeEventListener(f._touchEvent,
                d)
        }
        a = a || document.body;
        var e = cc._canvas || a,
            f = this;
        this.requestFullScreen(a, b);
        cc._addEventListener(e, this._touchEvent, d)
    }
};
cc.screen.init();
cc.visibleRect = {
    topLeft: cc.p(0, 0),
    topRight: cc.p(0, 0),
    top: cc.p(0, 0),
    bottomLeft: cc.p(0, 0),
    bottomRight: cc.p(0, 0),
    bottom: cc.p(0, 0),
    center: cc.p(0, 0),
    left: cc.p(0, 0),
    right: cc.p(0, 0),
    width: 0,
    height: 0,
    init: function(a) {
        var b = this.width = a.width,
            d = this.height = a.height,
            e = a.x;
        a = a.y;
        var f = a + d,
            g = e + b;
        this.topLeft.x = e;
        this.topLeft.y = f;
        this.topRight.x = g;
        this.topRight.y = f;
        this.top.x = e + b / 2;
        this.top.y = f;
        this.bottomLeft.x = e;
        this.bottomLeft.y = a;
        this.bottomRight.x = g;
        this.bottomRight.y = a;
        this.bottom.x = e + b / 2;
        this.bottom.y =
            a;
        this.center.x = e + b / 2;
        this.center.y = a + d / 2;
        this.left.x = e;
        this.left.y = a + d / 2;
        this.right.x = g;
        this.right.y = a + d / 2
    }
};
cc.UIInterfaceOrientationLandscapeLeft = -90;
cc.UIInterfaceOrientationLandscapeRight = 90;
cc.UIInterfaceOrientationPortraitUpsideDown = 180;
cc.UIInterfaceOrientationPortrait = 0;
cc.inputManager = {
    _mousePressed: !1,
    _isRegisterEvent: !1,
    _preTouchPoint: cc.p(0, 0),
    _prevMousePoint: cc.p(0, 0),
    _preTouchPool: [],
    _preTouchPoolPointer: 0,
    _touches: [],
    _touchesIntegerDict: {},
    _indexBitsUsed: 0,
    _maxTouches: 5,
    _accelEnabled: !1,
    _accelInterval: 1 / 30,
    _accelMinus: 1,
    _accelCurTime: 0,
    _acceleration: null,
    _accelDeviceEvent: null,
    _getUnUsedIndex: function() {
        for (var a = this._indexBitsUsed, b = 0; b < this._maxTouches; b++) {
            if (!(a & 1)) return this._indexBitsUsed |= 1 << b, b;
            a >>= 1
        }
        return -1
    },
    _removeUsedIndexBit: function(a) {
        0 > a ||
            a >= this._maxTouches || (a = ~(1 << a), this._indexBitsUsed &= a)
    },
    _glView: null,
    handleTouchesBegin: function(a) {
        for (var b, d, e, f = [], g = this._touchesIntegerDict, h = 0, k = a.length; h < k; h++)
            if (b = a[h], e = b.getID(), d = g[e], null == d) {
                var m = this._getUnUsedIndex(); - 1 === m ? cc.log(cc._LogInfos.inputManager_handleTouchesBegin, m) : (d = this._touches[m] = new cc.Touch(b._point.x, b._point.y, b.getID()), d._setPrevPoint(b._prevPoint), g[e] = m, f.push(d))
            }
        0 < f.length && (this._glView._convertTouchesWithScale(f), a = new cc.EventTouch(f), a._eventCode =
            cc.EventTouch.EventCode.BEGAN, cc.eventManager.dispatchEvent(a))
    },
    handleTouchesMove: function(a) {
        for (var b, d, e = [], f = this._touches, g = 0, h = a.length; g < h; g++) b = a[g], d = b.getID(), d = this._touchesIntegerDict[d], null != d && f[d] && (f[d]._setPoint(b._point), f[d]._setPrevPoint(b._prevPoint), e.push(f[d]));
        0 < e.length && (this._glView._convertTouchesWithScale(e), a = new cc.EventTouch(e), a._eventCode = cc.EventTouch.EventCode.MOVED, cc.eventManager.dispatchEvent(a))
    },
    handleTouchesEnd: function(a) {
        a = this.getSetOfTouchesEndOrCancel(a);
        0 < a.length && (this._glView._convertTouchesWithScale(a), a = new cc.EventTouch(a), a._eventCode = cc.EventTouch.EventCode.ENDED, cc.eventManager.dispatchEvent(a))
    },
    handleTouchesCancel: function(a) {
        a = this.getSetOfTouchesEndOrCancel(a);
        0 < a.length && (this._glView._convertTouchesWithScale(a), a = new cc.EventTouch(a), a._eventCode = cc.EventTouch.EventCode.CANCELLED, cc.eventManager.dispatchEvent(a))
    },
    getSetOfTouchesEndOrCancel: function(a) {
        for (var b, d, e, f = [], g = this._touches, h = this._touchesIntegerDict, k = 0, m = a.length; k <
            m; k++) b = a[k], e = b.getID(), d = h[e], null != d && g[d] && (g[d]._setPoint(b._point), g[d]._setPrevPoint(b._prevPoint), f.push(g[d]), this._removeUsedIndexBit(d), delete h[e]);
        return f
    },
    getHTMLElementPosition: function(a) {
        var b = document.documentElement,
            d = window,
            e = null,
            e = cc.isFunction(a.getBoundingClientRect) ? a.getBoundingClientRect() : a instanceof HTMLCanvasElement ? {
                left: 0,
                top: 0,
                width: a.width,
                height: a.height
            } : {
                left: 0,
                top: 0,
                width: parseInt(a.style.width),
                height: parseInt(a.style.height)
            };
        return {
            left: e.left + d.pageXOffset -
                b.clientLeft,
            top: e.top + d.pageYOffset - b.clientTop,
            width: e.width,
            height: e.height
        }
    },
    getPreTouch: function(a) {
        for (var b = null, d = this._preTouchPool, e = a.getID(), f = d.length - 1; 0 <= f; f--)
            if (d[f].getID() === e) {
                b = d[f];
                break
            }
        b || (b = a);
        return b
    },
    setPreTouch: function(a) {
        for (var b = !1, d = this._preTouchPool, e = a.getID(), f = d.length - 1; 0 <= f; f--)
            if (d[f].getID() === e) {
                d[f] = a;
                b = !0;
                break
            }
        b || (50 >= d.length ? d.push(a) : (d[this._preTouchPoolPointer] = a, this._preTouchPoolPointer = (this._preTouchPoolPointer + 1) % 50))
    },
    getTouchByXY: function(a,
        b, d) {
        var e = this._preTouchPoint;
        a = this._glView.convertToLocationInView(a, b, d);
        b = new cc.Touch(a.x, a.y);
        b._setPrevPoint(e.x, e.y);
        e.x = a.x;
        e.y = a.y;
        return b
    },
    getMouseEvent: function(a, b, d) {
        var e = this._prevMousePoint;
        this._glView._convertMouseToLocationInView(a, b);
        b = new cc.EventMouse(d);
        b.setLocation(a.x, a.y);
        b._setPrevCursor(e.x, e.y);
        e.x = a.x;
        e.y = a.y;
        return b
    },
    getPointByEvent: function(a, b) {
        if (null != a.pageX) return {
            x: a.pageX,
            y: a.pageY
        };
        b.left -= document.body.scrollLeft;
        b.top -= document.body.scrollTop;
        return {
            x: a.clientX,
            y: a.clientY
        }
    },
    getTouchesByEvent: function(a, b) {
        for (var d = [], e = this._glView, f, g, h = this._preTouchPoint, k = a.changedTouches.length, m = 0; m < k; m++)
            if (f = a.changedTouches[m]) {
                var n;
                n = cc.sys.BROWSER_TYPE_FIREFOX === cc.sys.browserType ? e.convertToLocationInView(f.pageX, f.pageY, b) : e.convertToLocationInView(f.clientX, f.clientY, b);
                null != f.identifier ? (f = new cc.Touch(n.x, n.y, f.identifier), g = this.getPreTouch(f).getLocation(), f._setPrevPoint(g.x, g.y), this.setPreTouch(f)) : (f = new cc.Touch(n.x, n.y), f._setPrevPoint(h.x, h.y));
                h.x = n.x;
                h.y = n.y;
                d.push(f)
            }
        return d
    },
    registerSystemEvent: function(a) {
        if (!this._isRegisterEvent) {
            this._glView = cc.view;
            var b = this,
                d = "mouse" in cc.sys.capabilities,
                e = "touches" in cc.sys.capabilities,
                f = !1;
            cc.sys.isMobile && (f = !0);
            d && (cc._addEventListener(window, "mousedown", function() {
                b._mousePressed = !0
            }, !1), cc._addEventListener(window, "mouseup", function(d) {
                if (!f) {
                    var e = b._mousePressed;
                    b._mousePressed = !1;
                    if (e) {
                        var e = b.getHTMLElementPosition(a),
                            g = b.getPointByEvent(d, e);
                        cc.rectContainsPoint(new cc.Rect(e.left,
                            e.top, e.width, e.height), g) || (b.handleTouchesEnd([b.getTouchByXY(g.x, g.y, e)]), e = b.getMouseEvent(g, e, cc.EventMouse.UP), e.setButton(d.button), cc.eventManager.dispatchEvent(e))
                    }
                }
            }, !1), cc._addEventListener(a, "mousedown", function(d) {
                if (!f) {
                    b._mousePressed = !0;
                    var e = b.getHTMLElementPosition(a),
                        g = b.getPointByEvent(d, e);
                    b.handleTouchesBegin([b.getTouchByXY(g.x, g.y, e)]);
                    e = b.getMouseEvent(g, e, cc.EventMouse.DOWN);
                    e.setButton(d.button);
                    cc.eventManager.dispatchEvent(e);
                    d.stopPropagation();
                    d.preventDefault();
                    a.focus()
                }
            }, !1), cc._addEventListener(a, "mouseup", function(d) {
                if (!f) {
                    b._mousePressed = !1;
                    var e = b.getHTMLElementPosition(a),
                        g = b.getPointByEvent(d, e);
                    b.handleTouchesEnd([b.getTouchByXY(g.x, g.y, e)]);
                    e = b.getMouseEvent(g, e, cc.EventMouse.UP);
                    e.setButton(d.button);
                    cc.eventManager.dispatchEvent(e);
                    d.stopPropagation();
                    d.preventDefault()
                }
            }, !1), cc._addEventListener(a, "mousemove", function(d) {
                if (!f) {
                    var e = b.getHTMLElementPosition(a),
                        g = b.getPointByEvent(d, e);
                    b.handleTouchesMove([b.getTouchByXY(g.x, g.y, e)]);
                    e = b.getMouseEvent(g,
                        e, cc.EventMouse.MOVE);
                    b._mousePressed ? e.setButton(d.button) : e.setButton(null);
                    cc.eventManager.dispatchEvent(e);
                    d.stopPropagation();
                    d.preventDefault()
                }
            }, !1), cc._addEventListener(a, "mousewheel", function(d) {
                var e = b.getHTMLElementPosition(a),
                    f = b.getPointByEvent(d, e),
                    e = b.getMouseEvent(f, e, cc.EventMouse.SCROLL);
                e.setButton(d.button);
                e.setScrollData(0, d.wheelDelta);
                cc.eventManager.dispatchEvent(e);
                d.stopPropagation();
                d.preventDefault()
            }, !1), cc._addEventListener(a, "DOMMouseScroll", function(d) {
                var e = b.getHTMLElementPosition(a),
                    f = b.getPointByEvent(d, e),
                    e = b.getMouseEvent(f, e, cc.EventMouse.SCROLL);
                e.setButton(d.button);
                e.setScrollData(0, -120 * d.detail);
                cc.eventManager.dispatchEvent(e);
                d.stopPropagation();
                d.preventDefault()
            }, !1));
            if (window.navigator.msPointerEnabled) {
                var d = {
                        MSPointerDown: b.handleTouchesBegin,
                        MSPointerMove: b.handleTouchesMove,
                        MSPointerUp: b.handleTouchesEnd,
                        MSPointerCancel: b.handleTouchesCancel
                    },
                    g;
                for (g in d)(function(d, e) {
                    cc._addEventListener(a, d, function(d) {
                        var f = b.getHTMLElementPosition(a);
                        f.left -= document.documentElement.scrollLeft;
                        f.top -= document.documentElement.scrollTop;
                        e.call(b, [b.getTouchByXY(d.clientX, d.clientY, f)]);
                        d.stopPropagation()
                    }, !1)
                })(g, d[g])
            }
            e && (cc._addEventListener(a, "touchstart", function(d) {
                if (d.changedTouches) {
                    var e = b.getHTMLElementPosition(a);
                    e.left -= document.body.scrollLeft;
                    e.top -= document.body.scrollTop;
                    b.handleTouchesBegin(b.getTouchesByEvent(d, e));
                    d.stopPropagation();
                    d.preventDefault();
                    a.focus()
                }
            }, !1), cc._addEventListener(a, "touchmove", function(d) {
                if (d.changedTouches) {
                    var e = b.getHTMLElementPosition(a);
                    e.left -= document.body.scrollLeft;
                    e.top -= document.body.scrollTop;
                    b.handleTouchesMove(b.getTouchesByEvent(d, e));
                    d.stopPropagation();
                    d.preventDefault()
                }
            }, !1), cc._addEventListener(a, "touchend", function(d) {
                if (d.changedTouches) {
                    var e = b.getHTMLElementPosition(a);
                    e.left -= document.body.scrollLeft;
                    e.top -= document.body.scrollTop;
                    b.handleTouchesEnd(b.getTouchesByEvent(d, e));
                    d.stopPropagation();
                    d.preventDefault()
                }
            }, !1), cc._addEventListener(a, "touchcancel", function(d) {
                if (d.changedTouches) {
                    var e = b.getHTMLElementPosition(a);
                    e.left -= document.body.scrollLeft;
                    e.top -= document.body.scrollTop;
                    b.handleTouchesCancel(b.getTouchesByEvent(d, e));
                    d.stopPropagation();
                    d.preventDefault()
                }
            }, !1));
            this._registerKeyboardEvent();
            this._registerAccelerometerEvent();
            this._isRegisterEvent = !0
        }
    },
    _registerKeyboardEvent: function() {},
    _registerAccelerometerEvent: function() {},
    update: function(a) {
        this._accelCurTime > this._accelInterval && (this._accelCurTime -= this._accelInterval, cc.eventManager.dispatchEvent(new cc.EventAcceleration(this._acceleration)));
        this._accelCurTime += a
    }
};
var _p = cc.inputManager;
_p.setAccelerometerEnabled = function(a) {
    this._accelEnabled !== a && (this._accelEnabled = a, a = cc.director.getScheduler(), this._accelCurTime = 0, a.scheduleUpdate(this))
};
_p.setAccelerometerInterval = function(a) {
    this._accelInterval !== a && (this._accelInterval = a)
};
_p._registerKeyboardEvent = function() {
    cc._addEventListener(cc._canvas, "keydown", function(a) {
        cc.eventManager.dispatchEvent(new cc.EventKeyboard(a.keyCode, !0));
        a.stopPropagation();
        a.preventDefault()
    }, !1);
    cc._addEventListener(cc._canvas, "keyup", function(a) {
        cc.eventManager.dispatchEvent(new cc.EventKeyboard(a.keyCode, !1));
        a.stopPropagation();
        a.preventDefault()
    }, !1)
};
_p._registerAccelerometerEvent = function() {
    var a = window;
    this._acceleration = new cc.Acceleration;
    this._accelDeviceEvent = a.DeviceMotionEvent || a.DeviceOrientationEvent;
    cc.sys.browserType === cc.sys.BROWSER_TYPE_MOBILE_QQ && (this._accelDeviceEvent = window.DeviceOrientationEvent);
    var b = this._accelDeviceEvent === a.DeviceMotionEvent ? "devicemotion" : "deviceorientation",
        d = navigator.userAgent;
    if (/Android/.test(d) || /Adr/.test(d) && cc.sys.browserType === cc.BROWSER_TYPE_UC) this._minus = -1;
    cc._addEventListener(a, b, this.didAccelerate.bind(this), !1)
};
_p.didAccelerate = function(a) {
    var b = window;
    if (this._accelEnabled) {
        var d = this._acceleration,
            e, f, g;
        this._accelDeviceEvent === window.DeviceMotionEvent ? (g = a.accelerationIncludingGravity, e = 0.1 * this._accelMinus * g.x, f = 0.1 * this._accelMinus * g.y, g = 0.1 * g.z) : (e = 0.981 * (a.gamma / 90), f = 0.981 * -(a.beta / 90), g = 0.981 * (a.alpha / 90));
        cc.sys.os === cc.sys.OS_ANDROID ? (d.x = -e, d.y = -f) : (d.x = e, d.y = f);
        d.z = g;
        d.timestamp = a.timeStamp || Date.now();
        a = d.x;
        b.orientation === cc.UIInterfaceOrientationLandscapeRight ? (d.x = -d.y, d.y = a) : b.orientation === cc.UIInterfaceOrientationLandscapeLeft ?
            (d.x = d.y, d.y = -a) : b.orientation === cc.UIInterfaceOrientationPortraitUpsideDown && (d.x = -d.x, d.y = -d.y)
    }
};
delete _p;
cc.AffineTransform = function(a, b, d, e, f, g) {
    this.a = a;
    this.b = b;
    this.c = d;
    this.d = e;
    this.tx = f;
    this.ty = g
};
cc.affineTransformMake = function(a, b, d, e, f, g) {
    return {
        a: a,
        b: b,
        c: d,
        d: e,
        tx: f,
        ty: g
    }
};
cc.pointApplyAffineTransform = function(a, b, d) {
    var e;
    void 0 === d ? (d = b, e = a.x, a = a.y) : (e = a, a = b);
    return {
        x: d.a * e + d.c * a + d.tx,
        y: d.b * e + d.d * a + d.ty
    }
};
cc._pointApplyAffineTransform = function(a, b, d) {
    return cc.pointApplyAffineTransform(a, b, d)
};
cc.sizeApplyAffineTransform = function(a, b) {
    return {
        width: b.a * a.width + b.c * a.height,
        height: b.b * a.width + b.d * a.height
    }
};
cc.affineTransformMakeIdentity = function() {
    return {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
    }
};
cc.affineTransformIdentity = function() {
    return {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
    }
};
cc.rectApplyAffineTransform = function(a, b) {
    var d = cc.rectGetMinY(a),
        e = cc.rectGetMinX(a),
        f = cc.rectGetMaxX(a),
        g = cc.rectGetMaxY(a),
        h = cc.pointApplyAffineTransform(e, d, b),
        d = cc.pointApplyAffineTransform(f, d, b),
        e = cc.pointApplyAffineTransform(e, g, b),
        k = cc.pointApplyAffineTransform(f, g, b),
        f = Math.min(h.x, d.x, e.x, k.x),
        g = Math.max(h.x, d.x, e.x, k.x),
        m = Math.min(h.y, d.y, e.y, k.y),
        h = Math.max(h.y, d.y, e.y, k.y);
    return cc.rect(f, m, g - f, h - m)
};
cc._rectApplyAffineTransformIn = function(a, b) {
    var d = cc.rectGetMinY(a),
        e = cc.rectGetMinX(a),
        f = cc.rectGetMaxX(a),
        g = cc.rectGetMaxY(a),
        h = cc.pointApplyAffineTransform(e, d, b),
        d = cc.pointApplyAffineTransform(f, d, b),
        e = cc.pointApplyAffineTransform(e, g, b),
        k = cc.pointApplyAffineTransform(f, g, b),
        f = Math.min(h.x, d.x, e.x, k.x),
        g = Math.max(h.x, d.x, e.x, k.x),
        m = Math.min(h.y, d.y, e.y, k.y),
        h = Math.max(h.y, d.y, e.y, k.y);
    a.x = f;
    a.y = m;
    a.width = g - f;
    a.height = h - m;
    return a
};
cc.affineTransformTranslate = function(a, b, d) {
    return {
        a: a.a,
        b: a.b,
        c: a.c,
        d: a.d,
        tx: a.tx + a.a * b + a.c * d,
        ty: a.ty + a.b * b + a.d * d
    }
};
cc.affineTransformScale = function(a, b, d) {
    return {
        a: a.a * b,
        b: a.b * b,
        c: a.c * d,
        d: a.d * d,
        tx: a.tx,
        ty: a.ty
    }
};
cc.affineTransformRotate = function(a, b) {
    var d = Math.sin(b),
        e = Math.cos(b);
    return {
        a: a.a * e + a.c * d,
        b: a.b * e + a.d * d,
        c: a.c * e - a.a * d,
        d: a.d * e - a.b * d,
        tx: a.tx,
        ty: a.ty
    }
};
cc.affineTransformConcat = function(a, b) {
    return {
        a: a.a * b.a + a.b * b.c,
        b: a.a * b.b + a.b * b.d,
        c: a.c * b.a + a.d * b.c,
        d: a.c * b.b + a.d * b.d,
        tx: a.tx * b.a + a.ty * b.c + b.tx,
        ty: a.tx * b.b + a.ty * b.d + b.ty
    }
};
cc.affineTransformConcatIn = function(a, b) {
    var d = a.a,
        e = a.b,
        f = a.c,
        g = a.d,
        h = a.tx,
        k = a.ty;
    a.a = d * b.a + e * b.c;
    a.b = d * b.b + e * b.d;
    a.c = f * b.a + g * b.c;
    a.d = f * b.b + g * b.d;
    a.tx = h * b.a + k * b.c + b.tx;
    a.ty = h * b.b + k * b.d + b.ty;
    return a
};
cc.affineTransformEqualToTransform = function(a, b) {
    return a.a === b.a && a.b === b.b && a.c === b.c && a.d === b.d && a.tx === b.tx && a.ty === b.ty
};
cc.affineTransformInvert = function(a) {
    var b = 1 / (a.a * a.d - a.b * a.c);
    return {
        a: b * a.d,
        b: -b * a.b,
        c: -b * a.c,
        d: b * a.a,
        tx: b * (a.c * a.ty - a.d * a.tx),
        ty: b * (a.b * a.tx - a.a * a.ty)
    }
};
cc.POINT_EPSILON = parseFloat("1.192092896e-07F");
cc.pNeg = function(a) {
    return cc.p(-a.x, -a.y)
};
cc.pAdd = function(a, b) {
    return cc.p(a.x + b.x, a.y + b.y)
};
cc.pSub = function(a, b) {
    return cc.p(a.x - b.x, a.y - b.y)
};
cc.pMult = function(a, b) {
    return cc.p(a.x * b, a.y * b)
};
cc.pMidpoint = function(a, b) {
    return cc.pMult(cc.pAdd(a, b), 0.5)
};
cc.pDot = function(a, b) {
    return a.x * b.x + a.y * b.y
};
cc.pCross = function(a, b) {
    return a.x * b.y - a.y * b.x
};
cc.pPerp = function(a) {
    return cc.p(-a.y, a.x)
};
cc.pRPerp = function(a) {
    return cc.p(a.y, -a.x)
};
cc.pProject = function(a, b) {
    return cc.pMult(b, cc.pDot(a, b) / cc.pDot(b, b))
};
cc.pRotate = function(a, b) {
    return cc.p(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x)
};
cc.pUnrotate = function(a, b) {
    return cc.p(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y)
};
cc.pLengthSQ = function(a) {
    return cc.pDot(a, a)
};
cc.pDistanceSQ = function(a, b) {
    return cc.pLengthSQ(cc.pSub(a, b))
};
cc.pLength = function(a) {
    return Math.sqrt(cc.pLengthSQ(a))
};
cc.pDistance = function(a, b) {
    return cc.pLength(cc.pSub(a, b))
};
cc.pNormalize = function(a) {
    var b = cc.pLength(a);
    return 0 === b ? cc.p(a) : cc.pMult(a, 1 / b)
};
cc.pForAngle = function(a) {
    return cc.p(Math.cos(a), Math.sin(a))
};
cc.pToAngle = function(a) {
    return Math.atan2(a.y, a.x)
};
cc.clampf = function(a, b, d) {
    if (b > d) {
        var e = b;
        b = d;
        d = e
    }
    return a < b ? b : a < d ? a : d
};
cc.pClamp = function(a, b, d) {
    return cc.p(cc.clampf(a.x, b.x, d.x), cc.clampf(a.y, b.y, d.y))
};
cc.pFromSize = function(a) {
    return cc.p(a.width, a.height)
};
cc.pCompOp = function(a, b) {
    return cc.p(b(a.x), b(a.y))
};
cc.pLerp = function(a, b, d) {
    return cc.pAdd(cc.pMult(a, 1 - d), cc.pMult(b, d))
};
cc.pFuzzyEqual = function(a, b, d) {
    return a.x - d <= b.x && b.x <= a.x + d && a.y - d <= b.y && b.y <= a.y + d ? !0 : !1
};
cc.pCompMult = function(a, b) {
    return cc.p(a.x * b.x, a.y * b.y)
};
cc.pAngleSigned = function(a, b) {
    var d = cc.pNormalize(a),
        e = cc.pNormalize(b),
        d = Math.atan2(d.x * e.y - d.y * e.x, cc.pDot(d, e));
    return Math.abs(d) < cc.POINT_EPSILON ? 0 : d
};
cc.pAngle = function(a, b) {
    var d = Math.acos(cc.pDot(cc.pNormalize(a), cc.pNormalize(b)));
    return Math.abs(d) < cc.POINT_EPSILON ? 0 : d
};
cc.pRotateByAngle = function(a, b, d) {
    a = cc.pSub(a, b);
    var e = Math.cos(d);
    d = Math.sin(d);
    var f = a.x;
    a.x = f * e - a.y * d + b.x;
    a.y = f * d + a.y * e + b.y;
    return a
};
cc.pLineIntersect = function(a, b, d, e, f) {
    if (a.x === b.x && a.y === b.y || d.x === e.x && d.y === e.y) return !1;
    var g = b.x - a.x;
    b = b.y - a.y;
    var h = e.x - d.x;
    e = e.y - d.y;
    var k = a.x - d.x;
    a = a.y - d.y;
    d = e * g - h * b;
    f.x = h * a - e * k;
    f.y = g * a - b * k;
    if (0 === d) return 0 === f.x || 0 === f.y ? !0 : !1;
    f.x /= d;
    f.y /= d;
    return !0
};
cc.pSegmentIntersect = function(a, b, d, e) {
    var f = cc.p(0, 0);
    return cc.pLineIntersect(a, b, d, e, f) && 0 <= f.x && 1 >= f.x && 0 <= f.y && 1 >= f.y ? !0 : !1
};
cc.pIntersectPoint = function(a, b, d, e) {
    var f = cc.p(0, 0);
    return cc.pLineIntersect(a, b, d, e, f) ? (d = cc.p(0, 0), d.x = a.x + f.x * (b.x - a.x), d.y = a.y + f.x * (b.y - a.y), d) : cc.p(0, 0)
};
cc.pSameAs = function(a, b) {
    return null != a && null != b ? a.x === b.x && a.y === b.y : !1
};
cc.pZeroIn = function(a) {
    a.x = 0;
    a.y = 0
};
cc.pIn = function(a, b) {
    a.x = b.x;
    a.y = b.y
};
cc.pMultIn = function(a, b) {
    a.x *= b;
    a.y *= b
};
cc.pSubIn = function(a, b) {
    a.x -= b.x;
    a.y -= b.y
};
cc.pAddIn = function(a, b) {
    a.x += b.x;
    a.y += b.y
};
cc.pNormalizeIn = function(a) {
    cc.pMultIn(a, 1 / Math.sqrt(a.x * a.x + a.y * a.y))
};
cc.vertexLineToPolygon = function(a, b, d, e, f) {
    f += e;
    if (!(1 >= f)) {
        b *= 0.5;
        for (var g, h = f - 1, k = e; k < f; k++) {
            g = 2 * k;
            var m = cc.p(a[2 * k], a[2 * k + 1]),
                n;
            if (0 === k) n = cc.pPerp(cc.pNormalize(cc.pSub(m, cc.p(a[2 * (k + 1)], a[2 * (k + 1) + 1]))));
            else if (k === h) n = cc.pPerp(cc.pNormalize(cc.pSub(cc.p(a[2 * (k - 1)], a[2 * (k - 1) + 1]), m)));
            else {
                n = cc.p(a[2 * (k - 1)], a[2 * (k - 1) + 1]);
                var p = cc.p(a[2 * (k + 1)], a[2 * (k + 1) + 1]),
                    r = cc.pNormalize(cc.pSub(p, m)),
                    s = cc.pNormalize(cc.pSub(n, m)),
                    t = Math.acos(cc.pDot(r, s));
                n = t < cc.degreesToRadians(70) ? cc.pPerp(cc.pNormalize(cc.pMidpoint(r,
                    s))) : t < cc.degreesToRadians(170) ? cc.pNormalize(cc.pMidpoint(r, s)) : cc.pPerp(cc.pNormalize(cc.pSub(p, n)))
            }
            n = cc.pMult(n, b);
            d[2 * g] = m.x + n.x;
            d[2 * g + 1] = m.y + n.y;
            d[2 * (g + 1)] = m.x - n.x;
            d[2 * (g + 1) + 1] = m.y - n.y
        }
        for (k = 0 === e ? 0 : e - 1; k < h; k++) {
            g = 2 * k;
            a = g + 2;
            b = cc.vertex2(d[2 * g], d[2 * g + 1]);
            f = cc.vertex2(d[2 * (g + 1)], d[2 * (g + 1) + 1]);
            g = cc.vertex2(d[2 * a], d[2 * a]);
            e = cc.vertex2(d[2 * (a + 1)], d[2 * (a + 1) + 1]);
            b = !cc.vertexLineIntersect(b.x, b.y, e.x, e.y, f.x, f.y, g.x, g.y);
            if (!b.isSuccess && (0 > b.value || 1 < b.value)) b.isSuccess = !0;
            b.isSuccess && (d[2 * a] = e.x,
                d[2 * a + 1] = e.y, d[2 * (a + 1)] = g.x, d[2 * (a + 1) + 1] = g.y)
        }
    }
};
cc.vertexLineIntersect = function(a, b, d, e, f, g, h, k) {
    if (a === d && b === e || f === h && g === k) return {
        isSuccess: !1,
        value: 0
    };
    d -= a;
    e -= b;
    f -= a;
    g -= b;
    h -= a;
    k -= b;
    a = Math.sqrt(d * d + e * e);
    d /= a;
    e /= a;
    b = f * d + g * e;
    g = g * d - f * e;
    f = b;
    b = h * d + k * e;
    k = k * d - h * e;
    h = b;
    return g === k ? {
        isSuccess: !1,
        value: 0
    } : {
        isSuccess: !0,
        value: (h + (f - h) * k / (k - g)) / a
    }
};
cc.vertexListIsClockwise = function(a) {
    for (var b = 0, d = a.length; b < d; b++) {
        var e = a[(b + 1) % d],
            f = a[(b + 2) % d];
        if (0 < cc.pCross(cc.pSub(e, a[b]), cc.pSub(f, e))) return !1
    }
    return !0
};
cc.CGAffineToGL = function(a, b) {
    b[2] = b[3] = b[6] = b[7] = b[8] = b[9] = b[11] = b[14] = 0;
    b[10] = b[15] = 1;
    b[0] = a.a;
    b[4] = a.c;
    b[12] = a.tx;
    b[1] = a.b;
    b[5] = a.d;
    b[13] = a.ty
};
cc.GLToCGAffine = function(a, b) {
    b.a = a[0];
    b.c = a[4];
    b.tx = a[12];
    b.b = a[1];
    b.d = a[5];
    b.ty = a[13]
};
cc.Touch = cc.Class.extend({
    _point: null,
    _prevPoint: null,
    _id: 0,
    _startPointCaptured: !1,
    _startPoint: null,
    ctor: function(a, b, d) {
        this._point = cc.p(a || 0, b || 0);
        this._id = d || 0
    },
    getLocation: function() {
        return {
            x: this._point.x,
            y: this._point.y
        }
    },
    getLocationX: function() {
        return this._point.x
    },
    getLocationY: function() {
        return this._point.y
    },
    getPreviousLocation: function() {
        return {
            x: this._prevPoint.x,
            y: this._prevPoint.y
        }
    },
    getStartLocation: function() {
        return {
            x: this._startPoint.x,
            y: this._startPoint.y
        }
    },
    getDelta: function() {
        return cc.pSub(this._point,
            this._prevPoint)
    },
    getLocationInView: function() {
        return {
            x: this._point.x,
            y: this._point.y
        }
    },
    getPreviousLocationInView: function() {
        return {
            x: this._prevPoint.x,
            y: this._prevPoint.y
        }
    },
    getStartLocationInView: function() {
        return {
            x: this._startPoint.x,
            y: this._startPoint.y
        }
    },
    getID: function() {
        return this._id
    },
    getId: function() {
        cc.log("getId is deprecated. Please use getID instead.");
        return this._id
    },
    setTouchInfo: function(a, b, d) {
        this._prevPoint = this._point;
        this._point = cc.p(b || 0, d || 0);
        this._id = a;
        this._startPointCaptured ||
            (this._startPoint = cc.p(this._point), this._startPointCaptured = !0)
    },
    _setPoint: function(a, b) {
        void 0 === b ? (this._point.x = a.x, this._point.y = a.y) : (this._point.x = a, this._point.y = b)
    },
    _setPrevPoint: function(a, b) {
        this._prevPoint = void 0 === b ? cc.p(a.x, a.y) : cc.p(a || 0, b || 0)
    }
});
cc.Event = cc.Class.extend({
    _type: 0,
    _isStopped: !1,
    _currentTarget: null,
    _setCurrentTarget: function(a) {
        this._currentTarget = a
    },
    ctor: function(a) {
        this._type = a
    },
    getType: function() {
        return this._type
    },
    stopPropagation: function() {
        this._isStopped = !0
    },
    isStopped: function() {
        return this._isStopped
    },
    getCurrentTarget: function() {
        return this._currentTarget
    }
});
cc.Event.TOUCH = 0;
cc.Event.KEYBOARD = 1;
cc.Event.ACCELERATION = 2;
cc.Event.MOUSE = 3;
cc.Event.FOCUS = 4;
cc.Event.CUSTOM = 6;
cc.EventCustom = cc.Event.extend({
    _eventName: null,
    _userData: null,
    ctor: function(a) {
        cc.Event.prototype.ctor.call(this, cc.Event.CUSTOM);
        this._eventName = a
    },
    setUserData: function(a) {
        this._userData = a
    },
    getUserData: function() {
        return this._userData
    },
    getEventName: function() {
        return this._eventName
    }
});
cc.EventMouse = cc.Event.extend({
    _eventType: 0,
    _button: 0,
    _x: 0,
    _y: 0,
    _prevX: 0,
    _prevY: 0,
    _scrollX: 0,
    _scrollY: 0,
    ctor: function(a) {
        cc.Event.prototype.ctor.call(this, cc.Event.MOUSE);
        this._eventType = a
    },
    setScrollData: function(a, b) {
        this._scrollX = a;
        this._scrollY = b
    },
    getScrollX: function() {
        return this._scrollX
    },
    getScrollY: function() {
        return this._scrollY
    },
    setLocation: function(a, b) {
        this._x = a;
        this._y = b
    },
    getLocation: function() {
        return {
            x: this._x,
            y: this._y
        }
    },
    getLocationInView: function() {
        return {
            x: this._x,
            y: cc.view._designResolutionSize.height -
                this._y
        }
    },
    _setPrevCursor: function(a, b) {
        this._prevX = a;
        this._prevY = b
    },
    getDelta: function() {
        return {
            x: this._x - this._prevX,
            y: this._y - this._prevY
        }
    },
    getDeltaX: function() {
        return this._x - this._prevX
    },
    getDeltaY: function() {
        return this._y - this._prevY
    },
    setButton: function(a) {
        this._button = a
    },
    getButton: function() {
        return this._button
    },
    getLocationX: function() {
        return this._x
    },
    getLocationY: function() {
        return this._y
    }
});
cc.EventMouse.NONE = 0;
cc.EventMouse.DOWN = 1;
cc.EventMouse.UP = 2;
cc.EventMouse.MOVE = 3;
cc.EventMouse.SCROLL = 4;
cc.EventMouse.BUTTON_LEFT = 0;
cc.EventMouse.BUTTON_RIGHT = 2;
cc.EventMouse.BUTTON_MIDDLE = 1;
cc.EventMouse.BUTTON_4 = 3;
cc.EventMouse.BUTTON_5 = 4;
cc.EventMouse.BUTTON_6 = 5;
cc.EventMouse.BUTTON_7 = 6;
cc.EventMouse.BUTTON_8 = 7;
cc.EventTouch = cc.Event.extend({
    _eventCode: 0,
    _touches: null,
    ctor: function(a) {
        cc.Event.prototype.ctor.call(this, cc.Event.TOUCH);
        this._touches = a || []
    },
    getEventCode: function() {
        return this._eventCode
    },
    getTouches: function() {
        return this._touches
    },
    _setEventCode: function(a) {
        this._eventCode = a
    },
    _setTouches: function(a) {
        this._touches = a
    }
});
cc.EventTouch.MAX_TOUCHES = 5;
cc.EventTouch.EventCode = {
    BEGAN: 0,
    MOVED: 1,
    ENDED: 2,
    CANCELLED: 3
};
cc.EventFocus = cc.Event.extend({
    _widgetGetFocus: null,
    _widgetLoseFocus: null,
    ctor: function(a, b) {
        cc.Event.prototype.ctor.call(this, cc.Event.FOCUS);
        this._widgetGetFocus = b;
        this._widgetLoseFocus = a
    }
});
cc.EventListener = cc.Class.extend({
    _onEvent: null,
    _type: 0,
    _listenerID: null,
    _registered: !1,
    _fixedPriority: 0,
    _node: null,
    _paused: !0,
    _isEnabled: !0,
    ctor: function(a, b, d) {
        this._onEvent = d;
        this._type = a || 0;
        this._listenerID = b || ""
    },
    _setPaused: function(a) {
        this._paused = a
    },
    _isPaused: function() {
        return this._paused
    },
    _setRegistered: function(a) {
        this._registered = a
    },
    _isRegistered: function() {
        return this._registered
    },
    _getType: function() {
        return this._type
    },
    _getListenerID: function() {
        return this._listenerID
    },
    _setFixedPriority: function(a) {
        this._fixedPriority =
            a
    },
    _getFixedPriority: function() {
        return this._fixedPriority
    },
    _setSceneGraphPriority: function(a) {
        this._node = a
    },
    _getSceneGraphPriority: function() {
        return this._node
    },
    checkAvailable: function() {
        return null !== this._onEvent
    },
    clone: function() {
        return null
    },
    setEnabled: function(a) {
        this._isEnabled = a
    },
    isEnabled: function() {
        return this._isEnabled
    },
    retain: function() {},
    release: function() {}
});
cc.EventListener.UNKNOWN = 0;
cc.EventListener.TOUCH_ONE_BY_ONE = 1;
cc.EventListener.TOUCH_ALL_AT_ONCE = 2;
cc.EventListener.KEYBOARD = 3;
cc.EventListener.MOUSE = 4;
cc.EventListener.ACCELERATION = 5;
cc.EventListener.ACCELERATION = 6;
cc.EventListener.CUSTOM = 8;
cc.EventListener.FOCUS = 7;
cc._EventListenerCustom = cc.EventListener.extend({
    _onCustomEvent: null,
    ctor: function(a, b) {
        this._onCustomEvent = b;
        var d = this;
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.CUSTOM, a, function(a) {
            null !== d._onCustomEvent && d._onCustomEvent(a)
        })
    },
    checkAvailable: function() {
        return cc.EventListener.prototype.checkAvailable.call(this) && null !== this._onCustomEvent
    },
    clone: function() {
        return new cc._EventListenerCustom(this._listenerID, this._onCustomEvent)
    }
});
cc._EventListenerCustom.create = function(a, b) {
    return new cc._EventListenerCustom(a, b)
};
cc._EventListenerMouse = cc.EventListener.extend({
    onMouseDown: null,
    onMouseUp: null,
    onMouseMove: null,
    onMouseScroll: null,
    ctor: function() {
        var a = this;
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.MOUSE, cc._EventListenerMouse.LISTENER_ID, function(b) {
            var d = cc.EventMouse;
            switch (b._eventType) {
                case d.DOWN:
                    if (a.onMouseDown) a.onMouseDown(b);
                    break;
                case d.UP:
                    if (a.onMouseUp) a.onMouseUp(b);
                    break;
                case d.MOVE:
                    if (a.onMouseMove) a.onMouseMove(b);
                    break;
                case d.SCROLL:
                    if (a.onMouseScroll) a.onMouseScroll(b)
            }
        })
    },
    clone: function() {
        var a = new cc._EventListenerMouse;
        a.onMouseDown = this.onMouseDown;
        a.onMouseUp = this.onMouseUp;
        a.onMouseMove = this.onMouseMove;
        a.onMouseScroll = this.onMouseScroll;
        return a
    },
    checkAvailable: function() {
        return !0
    }
});
cc._EventListenerMouse.LISTENER_ID = "__cc_mouse";
cc._EventListenerMouse.create = function() {
    return new cc._EventListenerMouse
};
cc._EventListenerTouchOneByOne = cc.EventListener.extend({
    _claimedTouches: null,
    swallowTouches: !1,
    onTouchBegan: null,
    onTouchMoved: null,
    onTouchEnded: null,
    onTouchCancelled: null,
    ctor: function() {
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ONE_BY_ONE, cc._EventListenerTouchOneByOne.LISTENER_ID, null);
        this._claimedTouches = []
    },
    setSwallowTouches: function(a) {
        this.swallowTouches = a
    },
    isSwallowTouches: function() {
        return this.swallowTouches
    },
    clone: function() {
        var a = new cc._EventListenerTouchOneByOne;
        a.onTouchBegan = this.onTouchBegan;
        a.onTouchMoved = this.onTouchMoved;
        a.onTouchEnded = this.onTouchEnded;
        a.onTouchCancelled = this.onTouchCancelled;
        a.swallowTouches = this.swallowTouches;
        return a
    },
    checkAvailable: function() {
        return !this.onTouchBegan ? (cc.log(cc._LogInfos._EventListenerTouchOneByOne_checkAvailable), !1) : !0
    }
});
cc._EventListenerTouchOneByOne.LISTENER_ID = "__cc_touch_one_by_one";
cc._EventListenerTouchOneByOne.create = function() {
    return new cc._EventListenerTouchOneByOne
};
cc._EventListenerTouchAllAtOnce = cc.EventListener.extend({
    onTouchesBegan: null,
    onTouchesMoved: null,
    onTouchesEnded: null,
    onTouchesCancelled: null,
    ctor: function() {
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ALL_AT_ONCE, cc._EventListenerTouchAllAtOnce.LISTENER_ID, null)
    },
    clone: function() {
        var a = new cc._EventListenerTouchAllAtOnce;
        a.onTouchesBegan = this.onTouchesBegan;
        a.onTouchesMoved = this.onTouchesMoved;
        a.onTouchesEnded = this.onTouchesEnded;
        a.onTouchesCancelled = this.onTouchesCancelled;
        return a
    },
    checkAvailable: function() {
        return null === this.onTouchesBegan && null === this.onTouchesMoved && null === this.onTouchesEnded && null === this.onTouchesCancelled ? (cc.log(cc._LogInfos._EventListenerTouchAllAtOnce_checkAvailable), !1) : !0
    }
});
cc._EventListenerTouchAllAtOnce.LISTENER_ID = "__cc_touch_all_at_once";
cc._EventListenerTouchAllAtOnce.create = function() {
    return new cc._EventListenerTouchAllAtOnce
};
cc.EventListener.create = function(a) {
    cc.assert(a && a.event, cc._LogInfos.EventListener_create);
    var b = a.event;
    delete a.event;
    var d = null;
    b === cc.EventListener.TOUCH_ONE_BY_ONE ? d = new cc._EventListenerTouchOneByOne : b === cc.EventListener.TOUCH_ALL_AT_ONCE ? d = new cc._EventListenerTouchAllAtOnce : b === cc.EventListener.MOUSE ? d = new cc._EventListenerMouse : b === cc.EventListener.CUSTOM ? (d = new cc._EventListenerCustom(a.eventName, a.callback), delete a.eventName, delete a.callback) : b === cc.EventListener.KEYBOARD ? d = new cc._EventListenerKeyboard :
        b === cc.EventListener.ACCELERATION ? (d = new cc._EventListenerAcceleration(a.callback), delete a.callback) : b === cc.EventListener.FOCUS && (d = new cc._EventListenerFocus);
    for (var e in a) d[e] = a[e];
    return d
};
cc._EventListenerFocus = cc.EventListener.extend({
    clone: function() {
        var a = new cc._EventListenerFocus;
        a.onFocusChanged = this.onFocusChanged;
        return a
    },
    checkAvailable: function() {
        return !this.onFocusChanged ? (cc.log("Invalid EventListenerFocus!"), !1) : !0
    },
    onFocusChanged: null,
    ctor: function() {
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.FOCUS, cc._EventListenerFocus.LISTENER_ID, function(a) {
            if (this.onFocusChanged) this.onFocusChanged(a._widgetLoseFocus, a._widgetGetFocus)
        })
    }
});
cc._EventListenerFocus.LISTENER_ID = "__cc_focus_event";
cc._EventListenerVector = cc.Class.extend({
    _fixedListeners: null,
    _sceneGraphListeners: null,
    gt0Index: 0,
    ctor: function() {
        this._fixedListeners = [];
        this._sceneGraphListeners = []
    },
    size: function() {
        return this._fixedListeners.length + this._sceneGraphListeners.length
    },
    empty: function() {
        return 0 === this._fixedListeners.length && 0 === this._sceneGraphListeners.length
    },
    push: function(a) {
        0 === a._getFixedPriority() ? this._sceneGraphListeners.push(a) : this._fixedListeners.push(a)
    },
    clearSceneGraphListeners: function() {
        this._sceneGraphListeners.length =
            0
    },
    clearFixedListeners: function() {
        this._fixedListeners.length = 0
    },
    clear: function() {
        this._sceneGraphListeners.length = 0;
        this._fixedListeners.length = 0
    },
    getFixedPriorityListeners: function() {
        return this._fixedListeners
    },
    getSceneGraphPriorityListeners: function() {
        return this._sceneGraphListeners
    }
});
cc.__getListenerID = function(a) {
    var b = cc.Event,
        d = a.getType();
    if (d === b.ACCELERATION) return cc._EventListenerAcceleration.LISTENER_ID;
    if (d === b.CUSTOM) return a.getEventName();
    if (d === b.KEYBOARD) return cc._EventListenerKeyboard.LISTENER_ID;
    if (d === b.MOUSE) return cc._EventListenerMouse.LISTENER_ID;
    if (d === b.FOCUS) return cc._EventListenerFocus.LISTENER_ID;
    d === b.TOUCH && cc.log(cc._LogInfos.__getListenerID);
    return ""
};
cc.eventManager = {
    DIRTY_NONE: 0,
    DIRTY_FIXED_PRIORITY: 1,
    DIRTY_SCENE_GRAPH_PRIORITY: 2,
    DIRTY_ALL: 3,
    _listenersMap: {},
    _priorityDirtyFlagMap: {},
    _nodeListenersMap: {},
    _nodePriorityMap: {},
    _globalZOrderNodeMap: {},
    _toAddedListeners: [],
    _dirtyNodes: [],
    _inDispatch: 0,
    _isEnabled: !1,
    _nodePriorityIndex: 0,
    _internalCustomListenerIDs: [cc.game.EVENT_HIDE, cc.game.EVENT_SHOW],
    _setDirtyForNode: function(a) {
        null != this._nodeListenersMap[a.__instanceId] && this._dirtyNodes.push(a);
        a = a.getChildren();
        for (var b = 0, d = a.length; b < d; b++) this._setDirtyForNode(a[b])
    },
    pauseTarget: function(a, b) {
        var d = this._nodeListenersMap[a.__instanceId],
            e, f;
        if (d) {
            e = 0;
            for (f = d.length; e < f; e++) d[e]._setPaused(!0)
        }
        if (!0 === b) {
            d = a.getChildren();
            e = 0;
            for (f = d.length; e < f; e++) this.pauseTarget(d[e], !0)
        }
    },
    resumeTarget: function(a, b) {
        var d = this._nodeListenersMap[a.__instanceId],
            e, f;
        if (d) {
            e = 0;
            for (f = d.length; e < f; e++) d[e]._setPaused(!1)
        }
        this._setDirtyForNode(a);
        if (!0 === b) {
            d = a.getChildren();
            e = 0;
            for (f = d.length; e < f; e++) this.resumeTarget(d[e], !0)
        }
    },
    _addListener: function(a) {
        0 === this._inDispatch ? this._forceAddEventListener(a) :
            this._toAddedListeners.push(a)
    },
    _forceAddEventListener: function(a) {
        var b = a._getListenerID(),
            d = this._listenersMap[b];
        d || (d = new cc._EventListenerVector, this._listenersMap[b] = d);
        d.push(a);
        0 === a._getFixedPriority() ? (this._setDirty(b, this.DIRTY_SCENE_GRAPH_PRIORITY), b = a._getSceneGraphPriority(), null === b && cc.log(cc._LogInfos.eventManager__forceAddEventListener), this._associateNodeAndEventListener(b, a), b.isRunning() && this.resumeTarget(b)) : this._setDirty(b, this.DIRTY_FIXED_PRIORITY)
    },
    _getListeners: function(a) {
        return this._listenersMap[a]
    },
    _updateDirtyFlagForSceneGraph: function() {
        if (0 !== this._dirtyNodes.length) {
            for (var a = this._dirtyNodes, b, d, e = this._nodeListenersMap, f = 0, g = a.length; f < g; f++)
                if (b = e[a[f].__instanceId])
                    for (var h = 0, k = b.length; h < k; h++)(d = b[h]) && this._setDirty(d._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY);
            this._dirtyNodes.length = 0
        }
    },
    _removeAllListenersInVector: function(a) {
        if (a)
            for (var b, d = 0; d < a.length;) b = a[d], b._setRegistered(!1), null != b._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(b._getSceneGraphPriority(),
                b), b._setSceneGraphPriority(null)), 0 === this._inDispatch ? cc.arrayRemoveObject(a, b) : ++d
    },
    _removeListenersForListenerID: function(a) {
        var b = this._listenersMap[a];
        if (b) {
            var d = b.getFixedPriorityListeners(),
                e = b.getSceneGraphPriorityListeners();
            this._removeAllListenersInVector(e);
            this._removeAllListenersInVector(d);
            delete this._priorityDirtyFlagMap[a];
            this._inDispatch || (b.clear(), delete this._listenersMap[a])
        }
        d = this._toAddedListeners;
        for (b = 0; b < d.length;)(e = d[b]) && e._getListenerID() === a ? cc.arrayRemoveObject(d,
            e) : ++b
    },
    _sortEventListeners: function(a) {
        var b = this.DIRTY_NONE,
            d = this._priorityDirtyFlagMap;
        d[a] && (b = d[a]);
        b !== this.DIRTY_NONE && (d[a] = this.DIRTY_NONE, b & this.DIRTY_FIXED_PRIORITY && this._sortListenersOfFixedPriority(a), b & this.DIRTY_SCENE_GRAPH_PRIORITY && ((b = cc.director.getRunningScene()) ? this._sortListenersOfSceneGraphPriority(a, b) : d[a] = this.DIRTY_SCENE_GRAPH_PRIORITY))
    },
    _sortListenersOfSceneGraphPriority: function(a, b) {
        var d = this._getListeners(a);
        if (d) {
            var e = d.getSceneGraphPriorityListeners();
            e && 0 !==
                e.length && (this._nodePriorityIndex = 0, this._nodePriorityMap = {}, this._visitTarget(b, !0), d.getSceneGraphPriorityListeners().sort(this._sortEventListenersOfSceneGraphPriorityDes))
        }
    },
    _sortEventListenersOfSceneGraphPriorityDes: function(a, b) {
        var d = cc.eventManager._nodePriorityMap,
            e = a._getSceneGraphPriority(),
            f = b._getSceneGraphPriority();
        return !b || !f || !d[f.__instanceId] ? -1 : !a || !e || !d[e.__instanceId] ? 1 : d[b._getSceneGraphPriority().__instanceId] - d[a._getSceneGraphPriority().__instanceId]
    },
    _sortListenersOfFixedPriority: function(a) {
        if (a =
            this._listenersMap[a]) {
            var b = a.getFixedPriorityListeners();
            if (b && 0 !== b.length) {
                b.sort(this._sortListenersOfFixedPriorityAsc);
                for (var d = 0, e = b.length; d < e && !(0 <= b[d]._getFixedPriority());)++d;
                a.gt0Index = d
            }
        }
    },
    _sortListenersOfFixedPriorityAsc: function(a, b) {
        return a._getFixedPriority() - b._getFixedPriority()
    },
    _onUpdateListeners: function(a) {
        if (a = this._listenersMap[a]) {
            var b = a.getFixedPriorityListeners(),
                d = a.getSceneGraphPriorityListeners(),
                e, f;
            if (d)
                for (e = 0; e < d.length;) f = d[e], f._isRegistered() ? ++e : cc.arrayRemoveObject(d,
                    f);
            if (b)
                for (e = 0; e < b.length;) f = b[e], f._isRegistered() ? ++e : cc.arrayRemoveObject(b, f);
            d && 0 === d.length && a.clearSceneGraphListeners();
            b && 0 === b.length && a.clearFixedListeners()
        }
    },
    _updateListeners: function(a) {
        var b = this._inDispatch;
        cc.assert(0 < b, cc._LogInfos.EventManager__updateListeners);
        if (!(1 < b)) {
            a.getType() === cc.Event.TOUCH ? (this._onUpdateListeners(cc._EventListenerTouchOneByOne.LISTENER_ID), this._onUpdateListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID)) : this._onUpdateListeners(cc.__getListenerID(a));
            cc.assert(1 === b, cc._LogInfos.EventManager__updateListeners_2);
            a = this._listenersMap;
            var b = this._priorityDirtyFlagMap,
                d;
            for (d in a) a[d].empty() && (delete b[d], delete a[d]);
            d = this._toAddedListeners;
            if (0 !== d.length) {
                a = 0;
                for (b = d.length; a < b; a++) this._forceAddEventListener(d[a]);
                this._toAddedListeners.length = 0
            }
        }
    },
    _onTouchEventCallback: function(a, b) {
        if (!a._isRegistered) return !1;
        var d = b.event,
            e = b.selTouch;
        d._setCurrentTarget(a._node);
        var f = !1,
            g, h = d.getEventCode(),
            k = cc.EventTouch.EventCode;
        if (h === k.BEGAN) a.onTouchBegan &&
            (f = a.onTouchBegan(e, d)) && a._registered && a._claimedTouches.push(e);
        else if (0 < a._claimedTouches.length && -1 !== (g = a._claimedTouches.indexOf(e)))
            if (f = !0, h === k.MOVED && a.onTouchMoved) a.onTouchMoved(e, d);
            else if (h === k.ENDED) {
            if (a.onTouchEnded) a.onTouchEnded(e, d);
            a._registered && a._claimedTouches.splice(g, 1)
        } else if (h === k.CANCELLED) {
            if (a.onTouchCancelled) a.onTouchCancelled(e, d);
            a._registered && a._claimedTouches.splice(g, 1)
        }
        return d.isStopped() ? (cc.eventManager._updateListeners(d), !0) : f && a._registered && a.swallowTouches ?
            (b.needsMutableSet && b.touches.splice(e, 1), !0) : !1
    },
    _dispatchTouchEvent: function(a) {
        this._sortEventListeners(cc._EventListenerTouchOneByOne.LISTENER_ID);
        this._sortEventListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
        var b = this._getListeners(cc._EventListenerTouchOneByOne.LISTENER_ID),
            d = this._getListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
        if (!(null === b && null === d)) {
            var e = a.getTouches(),
                f = cc.copyArray(e),
                g = {
                    event: a,
                    needsMutableSet: b && d,
                    touches: f,
                    selTouch: null
                };
            if (b)
                for (var h = 0; h < e.length; h++)
                    if (g.selTouch =
                        e[h], this._dispatchEventToListeners(b, this._onTouchEventCallback, g), a.isStopped()) return;
            if (d && 0 < f.length && (this._dispatchEventToListeners(d, this._onTouchesEventCallback, {
                event: a,
                touches: f
            }), a.isStopped())) return;
            this._updateListeners(a)
        }
    },
    _onTouchesEventCallback: function(a, b) {
        if (!a._registered) return !1;
        var d = cc.EventTouch.EventCode,
            e = b.event,
            f = b.touches,
            g = e.getEventCode();
        e._setCurrentTarget(a._node);
        if (g === d.BEGAN && a.onTouchesBegan) a.onTouchesBegan(f, e);
        else if (g === d.MOVED && a.onTouchesMoved) a.onTouchesMoved(f,
            e);
        else if (g === d.ENDED && a.onTouchesEnded) a.onTouchesEnded(f, e);
        else if (g === d.CANCELLED && a.onTouchesCancelled) a.onTouchesCancelled(f, e);
        return e.isStopped() ? (cc.eventManager._updateListeners(e), !0) : !1
    },
    _associateNodeAndEventListener: function(a, b) {
        var d = this._nodeListenersMap[a.__instanceId];
        d || (d = [], this._nodeListenersMap[a.__instanceId] = d);
        d.push(b)
    },
    _dissociateNodeAndEventListener: function(a, b) {
        var d = this._nodeListenersMap[a.__instanceId];
        d && (cc.arrayRemoveObject(d, b), 0 === d.length && delete this._nodeListenersMap[a.__instanceId])
    },
    _dispatchEventToListeners: function(a, b, d) {
        var e = !1,
            f = a.getFixedPriorityListeners(),
            g = a.getSceneGraphPriorityListeners(),
            h = 0,
            k;
        if (f && 0 !== f.length)
            for (; h < a.gt0Index; ++h)
                if (k = f[h], k.isEnabled() && !k._isPaused() && k._isRegistered() && b(k, d)) {
                    e = !0;
                    break
                }
        if (g && !e)
            for (a = 0; a < g.length; a++)
                if (k = g[a], k.isEnabled() && !k._isPaused() && k._isRegistered() && b(k, d)) {
                    e = !0;
                    break
                }
        if (f && !e)
            for (; h < f.length && !(k = f[h], k.isEnabled() && !k._isPaused() && k._isRegistered() && b(k, d)); ++h);
    },
    _setDirty: function(a, b) {
        var d = this._priorityDirtyFlagMap;
        d[a] = null == d[a] ? b : b | d[a]
    },
    _visitTarget: function(a, b) {
        var d = a.getChildren(),
            e = 0,
            f = d.length,
            g = this._globalZOrderNodeMap,
            h = this._nodeListenersMap;
        if (0 < f) {
            for (var k; e < f; e++)
                if ((k = d[e]) && 0 > k.getLocalZOrder()) this._visitTarget(k, !1);
                else break;
            null != h[a.__instanceId] && (g[a.getGlobalZOrder()] || (g[a.getGlobalZOrder()] = []), g[a.getGlobalZOrder()].push(a.__instanceId));
            for (; e < f; e++)(k = d[e]) && this._visitTarget(k, !1)
        } else null != h[a.__instanceId] && (g[a.getGlobalZOrder()] || (g[a.getGlobalZOrder()] = []), g[a.getGlobalZOrder()].push(a.__instanceId));
        if (b) {
            var d = [],
                m;
            for (m in g) d.push(m);
            d.sort(this._sortNumberAsc);
            m = d.length;
            k = this._nodePriorityMap;
            for (e = 0; e < m; e++) {
                f = g[d[e]];
                for (h = 0; h < f.length; h++) k[f[h]] = ++this._nodePriorityIndex
            }
            this._globalZOrderNodeMap = {}
        }
    },
    _sortNumberAsc: function(a, b) {
        return a - b
    },
    addListener: function(a, b) {
        cc.assert(a && b, cc._LogInfos.eventManager_addListener_2);
        if (a instanceof cc.EventListener) {
            if (a._isRegistered()) {
                cc.log(cc._LogInfos.eventManager_addListener_4);
                return
            }
        } else cc.assert(!cc.isNumber(b), cc._LogInfos.eventManager_addListener_3),
            a = cc.EventListener.create(a); if (a.checkAvailable()) {
            if (cc.isNumber(b)) {
                if (0 === b) {
                    cc.log(cc._LogInfos.eventManager_addListener);
                    return
                }
                a._setSceneGraphPriority(null);
                a._setFixedPriority(b);
                a._setRegistered(!0);
                a._setPaused(!1)
            } else a._setSceneGraphPriority(b), a._setFixedPriority(0), a._setRegistered(!0);
            this._addListener(a);
            return a
        }
    },
    addCustomListener: function(a, b) {
        var d = new cc._EventListenerCustom(a, b);
        this.addListener(d, 1);
        return d
    },
    removeListener: function(a) {
        if (null != a) {
            var b, d = this._listenersMap,
                e;
            for (e in d) {
                var f = d[e],
                    g = f.getFixedPriorityListeners();
                b = f.getSceneGraphPriorityListeners();
                (b = this._removeListenerInVector(b, a)) ? this._setDirty(a._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY): (b = this._removeListenerInVector(g, a)) && this._setDirty(a._getListenerID(), this.DIRTY_FIXED_PRIORITY);
                f.empty() && (delete this._priorityDirtyFlagMap[a._getListenerID()], delete d[e]);
                if (b) break
            }
            if (!b) {
                d = this._toAddedListeners;
                e = 0;
                for (f = d.length; e < f; e++)
                    if (g = d[e], g === a) {
                        cc.arrayRemoveObject(d, g);
                        g._setRegistered(!1);
                        break
                    }
            }
        }
    },
    _removeListenerInCallback: function(a, b) {
        if (null == a) return !1;
        for (var d = 0, e = a.length; d < e; d++) {
            var f = a[d];
            if (f._onCustomEvent === b || f._onEvent === b) return f._setRegistered(!1), null != f._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(f._getSceneGraphPriority(), f), f._setSceneGraphPriority(null)), 0 === this._inDispatch && cc.arrayRemoveObject(a, f), !0
        }
        return !1
    },
    _removeListenerInVector: function(a, b) {
        if (null == a) return !1;
        for (var d = 0, e = a.length; d < e; d++) {
            var f = a[d];
            if (f === b) return f._setRegistered(!1),
                null != f._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(f._getSceneGraphPriority(), f), f._setSceneGraphPriority(null)), 0 === this._inDispatch && cc.arrayRemoveObject(a, f), !0
        }
        return !1
    },
    removeListeners: function(a, b) {
        if (a instanceof cc.Node) {
            delete this._nodePriorityMap[a.__instanceId];
            cc.arrayRemoveObject(this._dirtyNodes, a);
            var d = this._nodeListenersMap[a.__instanceId];
            if (d) {
                for (var e = cc.copyArray(d), d = 0; d < e.length; d++) this.removeListener(e[d]);
                e.length = 0
            }
            e = this._toAddedListeners;
            for (d = 0; d <
                e.length;) {
                var f = e[d];
                f._getSceneGraphPriority() === a ? (f._setSceneGraphPriority(null), f._setRegistered(!1), e.splice(d, 1)) : ++d
            }
            if (!0 === b) {
                e = a.getChildren();
                d = 0;
                for (f = e.length; d < f; d++) this.removeListeners(e[d], !0)
            }
        } else a === cc.EventListener.TOUCH_ONE_BY_ONE ? this._removeListenersForListenerID(cc._EventListenerTouchOneByOne.LISTENER_ID) : a === cc.EventListener.TOUCH_ALL_AT_ONCE ? this._removeListenersForListenerID(cc._EventListenerTouchAllAtOnce.LISTENER_ID) : a === cc.EventListener.MOUSE ? this._removeListenersForListenerID(cc._EventListenerMouse.LISTENER_ID) :
            a === cc.EventListener.ACCELERATION ? this._removeListenersForListenerID(cc._EventListenerAcceleration.LISTENER_ID) : a === cc.EventListener.KEYBOARD ? this._removeListenersForListenerID(cc._EventListenerKeyboard.LISTENER_ID) : cc.log(cc._LogInfos.eventManager_removeListeners)
    },
    removeCustomListeners: function(a) {
        this._removeListenersForListenerID(a)
    },
    removeAllListeners: function() {
        var a = this._listenersMap,
            b = this._internalCustomListenerIDs,
            d;
        for (d in a) - 1 === b.indexOf(d) && this._removeListenersForListenerID(d)
    },
    setPriority: function(a,
        b) {
        if (null != a) {
            var d = this._listenersMap,
                e;
            for (e in d) {
                var f = d[e].getFixedPriorityListeners();
                if (f && -1 !== f.indexOf(a)) {
                    null != a._getSceneGraphPriority() && cc.log(cc._LogInfos.eventManager_setPriority);
                    a._getFixedPriority() !== b && (a._setFixedPriority(b), this._setDirty(a._getListenerID(), this.DIRTY_FIXED_PRIORITY));
                    break
                }
            }
        }
    },
    setEnabled: function(a) {
        this._isEnabled = a
    },
    isEnabled: function() {
        return this._isEnabled
    },
    dispatchEvent: function(a) {
        if (this._isEnabled) {
            this._updateDirtyFlagForSceneGraph();
            this._inDispatch++;
            if (!a || !a.getType) throw Error("event is undefined");
            if (a.getType() === cc.Event.TOUCH) this._dispatchTouchEvent(a);
            else {
                var b = cc.__getListenerID(a);
                this._sortEventListeners(b);
                b = this._listenersMap[b];
                null != b && this._dispatchEventToListeners(b, this._onListenerCallback, a);
                this._updateListeners(a)
            }
            this._inDispatch--
        }
    },
    _onListenerCallback: function(a, b) {
        b._setCurrentTarget(a._getSceneGraphPriority());
        a._onEvent(b);
        return b.isStopped()
    },
    dispatchCustomEvent: function(a, b) {
        var d = new cc.EventCustom(a);
        d.setUserData(b);
        this.dispatchEvent(d)
    }
};
cc.EventHelper = function() {};
cc.EventHelper.prototype = {
    constructor: cc.EventHelper,
    apply: function(a) {
        a.addEventListener = cc.EventHelper.prototype.addEventListener;
        a.hasEventListener = cc.EventHelper.prototype.hasEventListener;
        a.removeEventListener = cc.EventHelper.prototype.removeEventListener;
        a.dispatchEvent = cc.EventHelper.prototype.dispatchEvent
    },
    addEventListener: function(a, b, d) {
        if ("load" === a && this._textureLoaded) setTimeout(function() {
            b.call(d)
        }, 0);
        else {
            void 0 === this._listeners && (this._listeners = {});
            var e = this._listeners;
            void 0 ===
                e[a] && (e[a] = []);
            this.hasEventListener(a, b, d) || e[a].push({
                callback: b,
                eventTarget: d
            })
        }
    },
    hasEventListener: function(a, b, d) {
        if (void 0 === this._listeners) return !1;
        var e = this._listeners;
        if (void 0 !== e[a]) {
            a = 0;
            for (var f = e.length; a < f; a++) {
                var g = e[a];
                if (g.callback === b && g.eventTarget === d) return !0
            }
        }
        return !1
    },
    removeEventListener: function(a, b) {
        if (void 0 !== this._listeners) {
            var d = this._listeners[a];
            if (void 0 !== d)
                for (var e = 0; e < d.length;) d[e].eventTarget === b ? d.splice(e, 1) : e++
        }
    },
    dispatchEvent: function(a, b) {
        if (void 0 !==
            this._listeners) {
            null == b && (b = !0);
            var d = this._listeners[a];
            if (void 0 !== d) {
                for (var e = [], f = d.length, g = 0; g < f; g++) e[g] = d[g];
                for (g = 0; g < f; g++) e[g].callback.call(e[g].eventTarget, this);
                b && (d.length = 0)
            }
        }
    }
};
cc.EventAcceleration = cc.Event.extend({
    _acc: null,
    ctor: function(a) {
        cc.Event.prototype.ctor.call(this, cc.Event.ACCELERATION);
        this._acc = a
    }
});
cc.EventKeyboard = cc.Event.extend({
    _keyCode: 0,
    _isPressed: !1,
    ctor: function(a, b) {
        cc.Event.prototype.ctor.call(this, cc.Event.KEYBOARD);
        this._keyCode = a;
        this._isPressed = b
    }
});
cc._EventListenerAcceleration = cc.EventListener.extend({
    _onAccelerationEvent: null,
    ctor: function(a) {
        this._onAccelerationEvent = a;
        var b = this;
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.ACCELERATION, cc._EventListenerAcceleration.LISTENER_ID, function(a) {
            b._onAccelerationEvent(a._acc, a)
        })
    },
    checkAvailable: function() {
        cc.assert(this._onAccelerationEvent, cc._LogInfos._EventListenerAcceleration_checkAvailable);
        return !0
    },
    clone: function() {
        return new cc._EventListenerAcceleration(this._onAccelerationEvent)
    }
});
cc._EventListenerAcceleration.LISTENER_ID = "__cc_acceleration";
cc._EventListenerAcceleration.create = function(a) {
    return new cc._EventListenerAcceleration(a)
};
cc._EventListenerKeyboard = cc.EventListener.extend({
    onKeyPressed: null,
    onKeyReleased: null,
    ctor: function() {
        var a = this;
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.KEYBOARD, cc._EventListenerKeyboard.LISTENER_ID, function(b) {
            if (b._isPressed) {
                if (a.onKeyPressed) a.onKeyPressed(b._keyCode, b)
            } else if (a.onKeyReleased) a.onKeyReleased(b._keyCode, b)
        })
    },
    clone: function() {
        var a = new cc._EventListenerKeyboard;
        a.onKeyPressed = this.onKeyPressed;
        a.onKeyReleased = this.onKeyReleased;
        return a
    },
    checkAvailable: function() {
        return null ===
            this.onKeyPressed && null === this.onKeyReleased ? (cc.log(cc._LogInfos._EventListenerKeyboard_checkAvailable), !1) : !0
    }
});
cc._EventListenerKeyboard.LISTENER_ID = "__cc_keyboard";
cc._EventListenerKeyboard.create = function() {
    return new cc._EventListenerKeyboard
};
cc.rendererCanvas = {
    childrenOrderDirty: !0,
    _transformNodePool: [],
    _renderCmds: [],
    _isCacheToCanvasOn: !1,
    _cacheToCanvasCmds: {},
    _cacheInstanceIds: [],
    _currentID: 0,
    _clearColor: cc.color(),
    _clearFillStyle: "rgb(0, 0, 0)",
    getRenderCmd: function(a) {
        return a._createRenderCmd()
    },
    rendering: function(a) {
        var b = this._renderCmds,
            d, e = cc.view.getScaleX(),
            f = cc.view.getScaleY(),
            g = a || cc._renderContext;
        g.computeRealOffsetY();
        a = 0;
        for (d = b.length; a < d; a++) b[a].rendering(g, e, f)
    },
    _renderingToCacheCanvas: function(a, b, d, e) {
        a || cc.log("The context of RenderTexture is invalid.");
        d = cc.isUndefined(d) ? 1 : d;
        e = cc.isUndefined(e) ? 1 : e;
        b = b || this._currentID;
        var f = this._cacheToCanvasCmds[b],
            g, h;
        a.computeRealOffsetY();
        g = 0;
        for (h = f.length; g < h; g++) f[g].rendering(a, d, e);
        f.length = 0;
        a = this._cacheInstanceIds;
        delete this._cacheToCanvasCmds[b];
        cc.arrayRemoveObject(a, b);
        0 === a.length ? this._isCacheToCanvasOn = !1 : this._currentID = a[a.length - 1]
    },
    _turnToCacheMode: function(a) {
        this._isCacheToCanvasOn = !0;
        a = a || 0;
        this._cacheToCanvasCmds[a] = []; - 1 === this._cacheInstanceIds.indexOf(a) && this._cacheInstanceIds.push(a);
        this._currentID = a
    },
    _turnToNormalMode: function() {
        this._isCacheToCanvasOn = !1
    },
    resetFlag: function() {
        this.childrenOrderDirty = !1;
        this._transformNodePool.length = 0
    },
    transform: function() {
        var a = this._transformNodePool;
        a.sort(this._sortNodeByLevelAsc);
        for (var b = 0, d = a.length; b < d; b++) 0 !== a[b]._dirtyFlag && a[b].updateStatus();
        a.length = 0
    },
    transformDirty: function() {
        return 0 < this._transformNodePool.length
    },
    _sortNodeByLevelAsc: function(a, b) {
        return a._curLevel - b._curLevel
    },
    pushDirtyNode: function(a) {
        this._transformNodePool.push(a)
    },
    clear: function() {
        var a = cc._canvas,
            b = cc._renderContext.getContext(),
            d = cc._renderContext;
        b.setTransform(1, 0, 0, 1, 0, 0);
        255 !== this._clearColor.a && b.clearRect(0, 0, a.width, a.height);
        d.setFillStyle(this._clearFillStyle);
        d.setGlobalAlpha(this._clearColor.a);
        b.fillRect(0, 0, a.width, a.height)
    },
    clearRenderCommands: function() {
        this._renderCmds.length = 0
    },
    pushRenderCommand: function(a) {
        if (a._needDraw)
            if (this._isCacheToCanvasOn) {
                var b = this._cacheToCanvasCmds[this._currentID]; - 1 === b.indexOf(a) && b.push(a)
            } else -1 === this._renderCmds.indexOf(a) &&
                this._renderCmds.push(a)
    }
};
cc._renderType === cc._RENDER_TYPE_CANVAS && (cc.renderer = cc.rendererCanvas);
(function() {
    cc.CanvasContextWrapper = function(a) {
        this._context = a;
        this._saveCount = 0;
        this._currentAlpha = a.globalAlpha;
        this._currentCompositeOperation = a.globalCompositeOperation;
        this._currentFillStyle = a.fillStyle;
        this._currentStrokeStyle = a.strokeStyle;
        this._offsetY = this._offsetX = 0;
        this._realOffsetY = this.height;
        this._armatureMode = 0
    };
    var a = cc.CanvasContextWrapper.prototype;
    a.resetCache = function() {
        var a = this._context;
        this._currentAlpha = a.globalAlpha;
        this._currentCompositeOperation = a.globalCompositeOperation;
        this._currentFillStyle = a.fillStyle;
        this._currentStrokeStyle = a.strokeStyle;
        this._realOffsetY = this._context.canvas.height + this._offsetY
    };
    a.setOffset = function(a, d) {
        this._offsetX = a;
        this._offsetY = d;
        this._realOffsetY = this._context.canvas.height + this._offsetY
    };
    a.computeRealOffsetY = function() {
        this._realOffsetY = this._context.canvas.height + this._offsetY
    };
    a.setViewScale = function(a, d) {
        this._scaleX = a;
        this._scaleY = d
    };
    a.getContext = function() {
        return this._context
    };
    a.save = function() {
        this._context.save();
        this._saveCount++
    };
    a.restore = function() {
        this._context.restore();
        this._saveCount--
    };
    a.setGlobalAlpha = function(a) {
        0 < this._saveCount ? this._context.globalAlpha = a : this._currentAlpha !== a && (this._currentAlpha = a, this._context.globalAlpha = a)
    };
    a.setCompositeOperation = function(a) {
        0 < this._saveCount ? this._context.globalCompositeOperation = a : this._currentCompositeOperation !== a && (this._currentCompositeOperation = a, this._context.globalCompositeOperation = a)
    };
    a.setFillStyle = function(a) {
        0 < this._saveCount ? this._context.fillStyle = a : this._currentFillStyle !==
            a && (this._currentFillStyle = a, this._context.fillStyle = a)
    };
    a.setStrokeStyle = function(a) {
        0 < this._saveCount ? this._context.strokeStyle = a : this._currentStrokeStyle !== a && (this._currentStrokeStyle = a, this._context.strokeStyle = a)
    };
    a.setTransform = function(a, d, e) {
        0 < this._armatureMode ? (this.restore(), this.save(), this._context.transform(a.a, -a.b, -a.c, a.d, a.tx * d, -(a.ty * e))) : this._context.setTransform(a.a, -a.b, -a.c, a.d, this._offsetX + a.tx * d, this._realOffsetY - a.ty * e)
    };
    a._switchToArmatureMode = function(a, d, e, f) {
        a ? (this._armatureMode++,
            this._context.setTransform(d.a, d.c, d.b, d.d, this._offsetX + d.tx * e, this._realOffsetY - d.ty * f), this.save()) : (this._armatureMode--, this.restore())
    }
})();
cc.rendererWebGL = {
    childrenOrderDirty: !0,
    _transformNodePool: [],
    _renderCmds: [],
    _isCacheToBufferOn: !1,
    _cacheToBufferCmds: {},
    _cacheInstanceIds: [],
    _currentID: 0,
    _clearColor: cc.color(),
    getRenderCmd: function(a) {
        return a._createRenderCmd()
    },
    rendering: function(a) {
        var b = this._renderCmds,
            d, e = a || cc._renderContext;
        a = 0;
        for (d = b.length; a < d; a++) b[a].rendering(e)
    },
    _turnToCacheMode: function(a) {
        this._isCacheToBufferOn = !0;
        a = a || 0;
        this._cacheToBufferCmds[a] = [];
        this._cacheInstanceIds.push(a);
        this._currentID = a
    },
    _turnToNormalMode: function() {
        this._isCacheToBufferOn = !1
    },
    _renderingToBuffer: function(a) {
        a = a || this._currentID;
        var b = this._cacheToBufferCmds[a],
            d, e, f = cc._renderContext,
            g = this._cacheInstanceIds;
        d = 0;
        for (e = b.length; d < e; d++) b[d].rendering(f);
        b.length = 0;
        delete this._cacheToBufferCmds[a];
        cc.arrayRemoveObject(g, a);
        0 === g.length ? this._isCacheToBufferOn = !1 : this._currentID = g[g.length - 1]
    },
    resetFlag: function() {
        this.childrenOrderDirty = !1;
        this._transformNodePool.length = 0
    },
    transform: function() {
        var a = this._transformNodePool;
        a.sort(this._sortNodeByLevelAsc);
        for (var b =
            0, d = a.length; b < d; b++) a[b].updateStatus();
        a.length = 0
    },
    transformDirty: function() {
        return 0 < this._transformNodePool.length
    },
    _sortNodeByLevelAsc: function(a, b) {
        return a._curLevel - b._curLevel
    },
    pushDirtyNode: function(a) {
        this._transformNodePool.push(a)
    },
    clearRenderCommands: function() {
        this._renderCmds.length = 0
    },
    clear: function() {
        var a = cc._renderContext;
        a.clearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearColor.a);
        a.clear(a.COLOR_BUFFER_BIT | a.DEPTH_BUFFER_BIT);
        0 === this._clearColor.a &&
            a.blendFunc(a.SRC_ALPHA, a.DST_ALPHA)
    },
    pushRenderCommand: function(a) {
        if (a._needDraw)
            if (this._isCacheToBufferOn) {
                var b = this._cacheToBufferCmds[this._currentID]; - 1 === b.indexOf(a) && b.push(a)
            } else -1 === this._renderCmds.indexOf(a) && this._renderCmds.push(a)
    }
};
cc._renderType === cc._RENDER_TYPE_WEBGL && (cc.renderer = cc.rendererWebGL);
cc._tmp.PrototypeCCNode = function() {
    var a = cc.Node.prototype;
    cc.defineGetterSetter(a, "x", a.getPositionX, a.setPositionX);
    cc.defineGetterSetter(a, "y", a.getPositionY, a.setPositionY);
    cc.defineGetterSetter(a, "width", a._getWidth, a._setWidth);
    cc.defineGetterSetter(a, "height", a._getHeight, a._setHeight);
    cc.defineGetterSetter(a, "anchorX", a._getAnchorX, a._setAnchorX);
    cc.defineGetterSetter(a, "anchorY", a._getAnchorY, a._setAnchorY);
    cc.defineGetterSetter(a, "skewX", a.getSkewX, a.setSkewX);
    cc.defineGetterSetter(a, "skewY",
        a.getSkewY, a.setSkewY);
    cc.defineGetterSetter(a, "zIndex", a.getLocalZOrder, a.setLocalZOrder);
    cc.defineGetterSetter(a, "vertexZ", a.getVertexZ, a.setVertexZ);
    cc.defineGetterSetter(a, "rotation", a.getRotation, a.setRotation);
    cc.defineGetterSetter(a, "rotationX", a.getRotationX, a.setRotationX);
    cc.defineGetterSetter(a, "rotationY", a.getRotationY, a.setRotationY);
    cc.defineGetterSetter(a, "scale", a.getScale, a.setScale);
    cc.defineGetterSetter(a, "scaleX", a.getScaleX, a.setScaleX);
    cc.defineGetterSetter(a, "scaleY", a.getScaleY,
        a.setScaleY);
    cc.defineGetterSetter(a, "children", a.getChildren);
    cc.defineGetterSetter(a, "childrenCount", a.getChildrenCount);
    cc.defineGetterSetter(a, "parent", a.getParent, a.setParent);
    cc.defineGetterSetter(a, "visible", a.isVisible, a.setVisible);
    cc.defineGetterSetter(a, "running", a.isRunning);
    cc.defineGetterSetter(a, "ignoreAnchor", a.isIgnoreAnchorPointForPosition, a.ignoreAnchorPointForPosition);
    cc.defineGetterSetter(a, "actionManager", a.getActionManager, a.setActionManager);
    cc.defineGetterSetter(a, "scheduler",
        a.getScheduler, a.setScheduler);
    cc.defineGetterSetter(a, "shaderProgram", a.getShaderProgram, a.setShaderProgram);
    cc.defineGetterSetter(a, "opacity", a.getOpacity, a.setOpacity);
    cc.defineGetterSetter(a, "opacityModifyRGB", a.isOpacityModifyRGB);
    cc.defineGetterSetter(a, "cascadeOpacity", a.isCascadeOpacityEnabled, a.setCascadeOpacityEnabled);
    cc.defineGetterSetter(a, "color", a.getColor, a.setColor);
    cc.defineGetterSetter(a, "cascadeColor", a.isCascadeColorEnabled, a.setCascadeColorEnabled)
};
cc.NODE_TAG_INVALID = -1;
cc.s_globalOrderOfArrival = 1;
cc.Node = cc.Class.extend({
    _localZOrder: 0,
    _globalZOrder: 0,
    _vertexZ: 0,
    _rotationX: 0,
    _rotationY: 0,
    _scaleX: 1,
    _scaleY: 1,
    _position: null,
    _normalizedPosition: null,
    _usingNormalizedPosition: !1,
    _normalizedPositionDirty: !1,
    _skewX: 0,
    _skewY: 0,
    _children: null,
    _visible: !0,
    _anchorPoint: null,
    _contentSize: null,
    _running: !1,
    _parent: null,
    _ignoreAnchorPointForPosition: !1,
    tag: cc.NODE_TAG_INVALID,
    userData: null,
    userObject: null,
    _reorderChildDirty: !1,
    _shaderProgram: null,
    arrivalOrder: 0,
    _actionManager: null,
    _scheduler: null,
    _eventDispatcher: null,
    _additionalTransformDirty: !1,
    _additionalTransform: null,
    _componentContainer: null,
    _isTransitionFinished: !1,
    _className: "Node",
    _showNode: !1,
    _name: "",
    _realOpacity: 255,
    _realColor: null,
    _cascadeColorEnabled: !1,
    _cascadeOpacityEnabled: !1,
    _renderCmd: null,
    _camera: null,
    ctor: function() {
        this._initNode();
        this._initRendererCmd()
    },
    _initNode: function() {
        this._anchorPoint = cc.p(0, 0);
        this._contentSize = cc.size(0, 0);
        this._position = cc.p(0, 0);
        this._normalizedPosition = cc.p(0, 0);
        this._children = [];
        var a = cc.director;
        this._actionManager =
            a.getActionManager();
        this._scheduler = a.getScheduler();
        this._additionalTransform = cc.affineTransformMakeIdentity();
        cc.ComponentContainer && (this._componentContainer = new cc.ComponentContainer(this));
        this._realOpacity = 255;
        this._realColor = cc.color(255, 255, 255, 255);
        this._cascadeOpacityEnabled = this._cascadeColorEnabled = !1
    },
    init: function() {
        return !0
    },
    _arrayMakeObjectsPerformSelector: function(a, b) {
        if (a && 0 !== a.length) {
            var d, e = a.length,
                f;
            d = cc.Node._stateCallbackType;
            switch (b) {
                case d.onEnter:
                    for (d = 0; d < e; d++)
                        if (f =
                            a[d]) f.onEnter();
                    break;
                case d.onExit:
                    for (d = 0; d < e; d++)
                        if (f = a[d]) f.onExit();
                    break;
                case d.onEnterTransitionDidFinish:
                    for (d = 0; d < e; d++)
                        if (f = a[d]) f.onEnterTransitionDidFinish();
                    break;
                case d.cleanup:
                    for (d = 0; d < e; d++)(f = a[d]) && f.cleanup();
                    break;
                case d.updateTransform:
                    for (d = 0; d < e; d++)(f = a[d]) && f.updateTransform();
                    break;
                case d.onExitTransitionDidStart:
                    for (d = 0; d < e; d++)
                        if (f = a[d]) f.onExitTransitionDidStart();
                    break;
                case d.sortAllChildren:
                    for (d = 0; d < e; d++)(f = a[d]) && f.sortAllChildren();
                    break;
                default:
                    cc.assert(0, cc._LogInfos.Node__arrayMakeObjectsPerformSelector)
            }
        }
    },
    attr: function(a) {
        for (var b in a) this[b] = a[b]
    },
    getSkewX: function() {
        return this._skewX
    },
    setSkewX: function(a) {
        this._skewX = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getSkewY: function() {
        return this._skewY
    },
    setSkewY: function(a) {
        this._skewY = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    setLocalZOrder: function(a) {
        this._localZOrder = a;
        this._parent && this._parent.reorderChild(this, a);
        cc.eventManager._setDirtyForNode(this)
    },
    _setLocalZOrder: function(a) {
        this._localZOrder =
            a
    },
    getLocalZOrder: function() {
        return this._localZOrder
    },
    getZOrder: function() {
        cc.log(cc._LogInfos.Node_getZOrder);
        return this.getLocalZOrder()
    },
    setZOrder: function(a) {
        cc.log(cc._LogInfos.Node_setZOrder);
        this.setLocalZOrder(a)
    },
    setGlobalZOrder: function(a) {
        this._globalZOrder !== a && (this._globalZOrder = a, cc.eventManager._setDirtyForNode(this))
    },
    getGlobalZOrder: function() {
        return this._globalZOrder
    },
    getVertexZ: function() {
        return this._vertexZ
    },
    setVertexZ: function(a) {
        this._vertexZ = a
    },
    getRotation: function() {
        this._rotationX !==
            this._rotationY && cc.log(cc._LogInfos.Node_getRotation);
        return this._rotationX
    },
    setRotation: function(a) {
        this._rotationX = this._rotationY = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getRotationX: function() {
        return this._rotationX
    },
    setRotationX: function(a) {
        this._rotationX = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getRotationY: function() {
        return this._rotationY
    },
    setRotationY: function(a) {
        this._rotationY = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getScale: function() {
        this._scaleX !== this._scaleY && cc.log(cc._LogInfos.Node_getScale);
        return this._scaleX
    },
    setScale: function(a, b) {
        this._scaleX = a;
        this._scaleY = b || 0 === b ? b : a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getScaleX: function() {
        return this._scaleX
    },
    setScaleX: function(a) {
        this._scaleX = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getScaleY: function() {
        return this._scaleY
    },
    setScaleY: function(a) {
        this._scaleY = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    setPosition: function(a, b) {
        var d = this._position;
        if (void 0 === b) {
            if (d.x === a.x && d.y === a.y) return;
            d.x = a.x;
            d.y = a.y
        } else {
            if (d.x === a && d.y === b) return;
            d.x = a;
            d.y = b
        }
        this._usingNormalizedPosition = !1;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    setNormalizedPosition: function(a, b) {
        var d = this._normalizedPosition;
        void 0 === b ? (d.x = a.x, d.y = a.y) : (d.x = a, d.y = b);
        this._normalizedPositionDirty = this._usingNormalizedPosition = !0;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getPosition: function() {
        return cc.p(this._position)
    },
    getNormalizedPosition: function() {
        return cc.p(this._normalizedPosition)
    },
    getPositionX: function() {
        return this._position.x
    },
    setPositionX: function(a) {
        this._position.x = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getPositionY: function() {
        return this._position.y
    },
    setPositionY: function(a) {
        this._position.y = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getChildrenCount: function() {
        return this._children.length
    },
    getChildren: function() {
        return this._children
    },
    isVisible: function() {
        return this._visible
    },
    setVisible: function(a) {
        this._visible !== a && (this._visible = a, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty), cc.renderer.childrenOrderDirty = !0)
    },
    getAnchorPoint: function() {
        return cc.p(this._anchorPoint)
    },
    setAnchorPoint: function(a, b) {
        var d = this._anchorPoint;
        if (void 0 === b) {
            if (a.x === d.x && a.y === d.y) return;
            d.x = a.x;
            d.y = a.y
        } else {
            if (a === d.x && b === d.y) return;
            d.x = a;
            d.y = b
        }
        this._renderCmd._updateAnchorPointInPoint()
    },
    _getAnchorX: function() {
        return this._anchorPoint.x
    },
    _setAnchorX: function(a) {
        this._anchorPoint.x !==
            a && (this._anchorPoint.x = a, this._renderCmd._updateAnchorPointInPoint())
    },
    _getAnchorY: function() {
        return this._anchorPoint.y
    },
    _setAnchorY: function(a) {
        this._anchorPoint.y !== a && (this._anchorPoint.y = a, this._renderCmd._updateAnchorPointInPoint())
    },
    getAnchorPointInPoints: function() {
        return this._renderCmd.getAnchorPointInPoints()
    },
    _getWidth: function() {
        return this._contentSize.width
    },
    _setWidth: function(a) {
        this._contentSize.width = a;
        this._renderCmd._updateAnchorPointInPoint()
    },
    _getHeight: function() {
        return this._contentSize.height
    },
    _setHeight: function(a) {
        this._contentSize.height = a;
        this._renderCmd._updateAnchorPointInPoint()
    },
    getContentSize: function() {
        return cc.size(this._contentSize)
    },
    setContentSize: function(a, b) {
        var d = this._contentSize;
        if (void 0 === b) {
            if (a.width === d.width && a.height === d.height) return;
            d.width = a.width;
            d.height = a.height
        } else {
            if (a === d.width && b === d.height) return;
            d.width = a;
            d.height = b
        }
        this._renderCmd._updateAnchorPointInPoint()
    },
    isRunning: function() {
        return this._running
    },
    getParent: function() {
        return this._parent
    },
    setParent: function(a) {
        this._parent =
            a
    },
    isIgnoreAnchorPointForPosition: function() {
        return this._ignoreAnchorPointForPosition
    },
    ignoreAnchorPointForPosition: function(a) {
        a !== this._ignoreAnchorPointForPosition && (this._ignoreAnchorPointForPosition = a, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty))
    },
    getTag: function() {
        return this.tag
    },
    setTag: function(a) {
        this.tag = a
    },
    setName: function(a) {
        this._name = a
    },
    getName: function() {
        return this._name
    },
    getUserData: function() {
        return this.userData
    },
    setUserData: function(a) {
        this.userData = a
    },
    getUserObject: function() {
        return this.userObject
    },
    setUserObject: function(a) {
        this.userObject !== a && (this.userObject = a)
    },
    getOrderOfArrival: function() {
        return this.arrivalOrder
    },
    setOrderOfArrival: function(a) {
        this.arrivalOrder = a
    },
    getActionManager: function() {
        this._actionManager || (this._actionManager = cc.director.getActionManager());
        return this._actionManager
    },
    setActionManager: function(a) {
        this._actionManager !== a && (this.stopAllActions(), this._actionManager = a)
    },
    getScheduler: function() {
        this._scheduler || (this._scheduler = cc.director.getScheduler());
        return this._scheduler
    },
    setScheduler: function(a) {
        this._scheduler !== a && (this.unscheduleAllCallbacks(), this._scheduler = a)
    },
    boundingBox: function() {
        cc.log(cc._LogInfos.Node_boundingBox);
        return this.getBoundingBox()
    },
    getBoundingBox: function() {
        var a = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        return cc._rectApplyAffineTransformIn(a, this.getNodeToParentTransform())
    },
    cleanup: function() {
        this.stopAllActions();
        this.unscheduleAllCallbacks();
        cc.eventManager.removeListeners(this);
        this._arrayMakeObjectsPerformSelector(this._children,
            cc.Node._stateCallbackType.cleanup)
    },
    getChildByTag: function(a) {
        var b = this._children;
        if (null !== b)
            for (var d = 0; d < b.length; d++) {
                var e = b[d];
                if (e && e.tag === a) return e
            }
        return null
    },
    getChildByName: function(a) {
        if (!a) return cc.log("Invalid name"), null;
        for (var b = this._children, d = 0, e = b.length; d < e; d++)
            if (b[d]._name === a) return b[d];
        return null
    },
    addChild: function(a, b, d) {
        b = void 0 === b ? a._localZOrder : b;
        var e, f = !1;
        cc.isUndefined(d) ? (d = void 0, e = a._name) : cc.isString(d) ? (e = d, d = void 0) : cc.isNumber(d) && (f = !0, e = "");
        cc.assert(a,
            cc._LogInfos.Node_addChild_3);
        cc.assert(null === a._parent, "child already added. It can't be added again");
        this._addChildHelper(a, b, d, e, f)
    },
    _addChildHelper: function(a, b, d, e, f) {
        this._children || (this._children = []);
        this._insertChild(a, b);
        f ? a.setTag(d) : a.setName(e);
        a.setParent(this);
        a.setOrderOfArrival(cc.s_globalOrderOfArrival++);
        if (this._running && (a.onEnter(), this._isTransitionFinished)) a.onEnterTransitionDidFinish();
        this._cascadeColorEnabled && a._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty);
        this._cascadeOpacityEnabled && a._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
    },
    removeFromParent: function(a) {
        this._parent && (void 0 === a && (a = !0), this._parent.removeChild(this, a))
    },
    removeFromParentAndCleanup: function(a) {
        cc.log(cc._LogInfos.Node_removeFromParentAndCleanup);
        this.removeFromParent(a)
    },
    removeChild: function(a, b) {
        0 !== this._children.length && (void 0 === b && (b = !0), -1 < this._children.indexOf(a) && this._detachChild(a, b), cc.renderer.childrenOrderDirty = !0)
    },
    removeChildByTag: function(a, b) {
        a ===
            cc.NODE_TAG_INVALID && cc.log(cc._LogInfos.Node_removeChildByTag);
        var d = this.getChildByTag(a);
        d ? this.removeChild(d, b) : cc.log(cc._LogInfos.Node_removeChildByTag_2, a)
    },
    removeAllChildrenWithCleanup: function(a) {
        this.removeAllChildren(a)
    },
    removeAllChildren: function(a) {
        var b = this._children;
        if (null !== b) {
            void 0 === a && (a = !0);
            for (var d = 0; d < b.length; d++) {
                var e = b[d];
                e && (this._running && (e.onExitTransitionDidStart(), e.onExit()), a && e.cleanup(), e.parent = null, e._renderCmd.detachFromParent())
            }
            this._children.length = 0;
            cc.renderer.childrenOrderDirty = !0
        }
    },
    _detachChild: function(a, b) {
        this._running && (a.onExitTransitionDidStart(), a.onExit());
        b && a.cleanup();
        a.parent = null;
        a._renderCmd.detachFromParent();
        cc.arrayRemoveObject(this._children, a)
    },
    _insertChild: function(a, b) {
        cc.renderer.childrenOrderDirty = this._reorderChildDirty = !0;
        this._children.push(a);
        a._setLocalZOrder(b)
    },
    setNodeDirty: function() {
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    reorderChild: function(a, b) {
        cc.assert(a, cc._LogInfos.Node_reorderChild);
        cc.renderer.childrenOrderDirty = this._reorderChildDirty = !0;
        a.arrivalOrder = cc.s_globalOrderOfArrival;
        cc.s_globalOrderOfArrival++;
        a._setLocalZOrder(b)
    },
    sortAllChildren: function() {
        if (this._reorderChildDirty) {
            var a = this._children,
                b = a.length,
                d, e, f;
            for (d = 1; d < b; d++) {
                f = a[d];
                for (e = d - 1; 0 <= e;) {
                    if (f._localZOrder < a[e]._localZOrder) a[e + 1] = a[e];
                    else if (f._localZOrder === a[e]._localZOrder && f.arrivalOrder < a[e].arrivalOrder) a[e + 1] = a[e];
                    else break;
                    e--
                }
                a[e + 1] = f
            }
            this._reorderChildDirty = !1
        }
    },
    draw: function(a) {},
    transformAncestors: function() {
        null !==
            this._parent && (this._parent.transformAncestors(), this._parent.transform())
    },
    onEnter: function() {
        this._isTransitionFinished = !1;
        this._running = !0;
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.onEnter);
        this.resume()
    },
    onEnterTransitionDidFinish: function() {
        this._isTransitionFinished = !0;
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.onEnterTransitionDidFinish)
    },
    onExitTransitionDidStart: function() {
        this._arrayMakeObjectsPerformSelector(this._children,
            cc.Node._stateCallbackType.onExitTransitionDidStart)
    },
    onExit: function() {
        this._running = !1;
        this.pause();
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.onExit);
        this.removeAllComponents()
    },
    runAction: function(a) {
        cc.assert(a, cc._LogInfos.Node_runAction);
        this.actionManager.addAction(a, this, !this._running);
        return a
    },
    stopAllActions: function() {
        this.actionManager && this.actionManager.removeAllActionsFromTarget(this)
    },
    stopAction: function(a) {
        this.actionManager.removeAction(a)
    },
    stopActionByTag: function(a) {
        a === cc.ACTION_TAG_INVALID ? cc.log(cc._LogInfos.Node_stopActionByTag) : this.actionManager.removeActionByTag(a, this)
    },
    getActionByTag: function(a) {
        return a === cc.ACTION_TAG_INVALID ? (cc.log(cc._LogInfos.Node_getActionByTag), null) : this.actionManager.getActionByTag(a, this)
    },
    getNumberOfRunningActions: function() {
        return this.actionManager.numberOfRunningActionsInTarget(this)
    },
    scheduleUpdate: function() {
        this.scheduleUpdateWithPriority(0)
    },
    scheduleUpdateWithPriority: function(a) {
        this.scheduler.scheduleUpdate(this,
            a, !this._running)
    },
    unscheduleUpdate: function() {
        this.scheduler.unscheduleUpdate(this)
    },
    schedule: function(a, b, d, e, f) {
        var g = arguments.length;
        "function" === typeof a ? 1 === g ? (b = 0, d = cc.REPEAT_FOREVER, e = 0, f = this.__instanceId) : 2 === g ? "number" === typeof b ? (d = cc.REPEAT_FOREVER, e = 0, f = this.__instanceId) : (f = b, b = 0, d = cc.REPEAT_FOREVER, e = 0) : 3 === g ? ("string" === typeof d ? (f = d, d = cc.REPEAT_FOREVER) : f = this.__instanceId, e = 0) : 4 === g && (f = this.__instanceId) : 1 === g ? (b = 0, d = cc.REPEAT_FOREVER, e = 0) : 2 === g && (d = cc.REPEAT_FOREVER, e = 0);
        cc.assert(a,
            cc._LogInfos.Node_schedule);
        cc.assert(0 <= b, cc._LogInfos.Node_schedule_2);
        d = null == d ? cc.REPEAT_FOREVER : d;
        this.scheduler.schedule(a, this, b || 0, d, e || 0, !this._running, f)
    },
    scheduleOnce: function(a, b, d) {
        void 0 === d && (d = this.__instanceId);
        this.schedule(a, 0, 0, b, d)
    },
    unschedule: function(a) {
        a && this.scheduler.unschedule(a, this)
    },
    unscheduleAllCallbacks: function() {
        this.scheduler.unscheduleAllForTarget(this)
    },
    resumeSchedulerAndActions: function() {
        cc.log(cc._LogInfos.Node_resumeSchedulerAndActions);
        this.resume()
    },
    resume: function() {
        this.scheduler.resumeTarget(this);
        this.actionManager && this.actionManager.resumeTarget(this);
        cc.eventManager.resumeTarget(this)
    },
    pauseSchedulerAndActions: function() {
        cc.log(cc._LogInfos.Node_pauseSchedulerAndActions);
        this.pause()
    },
    pause: function() {
        this.scheduler.pauseTarget(this);
        this.actionManager && this.actionManager.pauseTarget(this);
        cc.eventManager.pauseTarget(this)
    },
    setAdditionalTransform: function(a) {
        if (void 0 === a) return this._additionalTransformDirty = !1;
        this._additionalTransform = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
        this._additionalTransformDirty = !0
    },
    getParentToNodeTransform: function() {
        this._renderCmd.getParentToNodeTransform()
    },
    parentToNodeTransform: function() {
        return this.getParentToNodeTransform()
    },
    getNodeToWorldTransform: function() {
        for (var a = this.getNodeToParentTransform(), b = this._parent; null !== b; b = b.parent) a = cc.affineTransformConcat(a, b.getNodeToParentTransform());
        return a
    },
    nodeToWorldTransform: function() {
        return this.getNodeToWorldTransform()
    },
    getWorldToNodeTransform: function() {
        return cc.affineTransformInvert(this.getNodeToWorldTransform())
    },
    worldToNodeTransform: function() {
        return this.getWorldToNodeTransform()
    },
    convertToNodeSpace: function(a) {
        return cc.pointApplyAffineTransform(a, this.getWorldToNodeTransform())
    },
    convertToWorldSpace: function(a) {
        a = a || cc.p(0, 0);
        return cc.pointApplyAffineTransform(a, this.getNodeToWorldTransform())
    },
    convertToNodeSpaceAR: function(a) {
        return cc.pSub(this.convertToNodeSpace(a), this._renderCmd.getAnchorPointInPoints())
    },
    convertToWorldSpaceAR: function(a) {
        a = a || cc.p(0, 0);
        a = cc.pAdd(a, this._renderCmd.getAnchorPointInPoints());
        return this.convertToWorldSpace(a)
    },
    _convertToWindowSpace: function(a) {
        a = this.convertToWorldSpace(a);
        return cc.director.convertToUI(a)
    },
    convertTouchToNodeSpace: function(a) {
        a = a.getLocation();
        return this.convertToNodeSpace(a)
    },
    convertTouchToNodeSpaceAR: function(a) {
        a = cc.director.convertToGL(a.getLocation());
        return this.convertToNodeSpaceAR(a)
    },
    update: function(a) {
        this._componentContainer && !this._componentContainer.isEmpty() && this._componentContainer.visit(a)
    },
    updateTransform: function() {
        this._arrayMakeObjectsPerformSelector(this._children,
            cc.Node._stateCallbackType.updateTransform)
    },
    retain: function() {},
    release: function() {},
    getComponent: function(a) {
        return this._componentContainer ? this._componentContainer.getComponent(a) : null
    },
    addComponent: function(a) {
        this._componentContainer && this._componentContainer.add(a)
    },
    removeComponent: function(a) {
        return this._componentContainer ? this._componentContainer.remove(a) : !1
    },
    removeAllComponents: function() {
        this._componentContainer && this._componentContainer.removeAll()
    },
    grid: null,
    visit: function(a) {
        this._renderCmd.visit(a)
    },
    transform: function(a, b) {
        this._renderCmd.transform(a, b)
    },
    nodeToParentTransform: function() {
        return this.getNodeToParentTransform()
    },
    getNodeToParentTransform: function(a) {
        var b = this._renderCmd.getNodeToParentTransform();
        if (a)
            for (var b = {
                a: b.a,
                b: b.b,
                c: b.c,
                d: b.d,
                tx: b.tx,
                ty: b.ty
            }, d = this._parent; null != d && d != a; d = d.getParent()) cc.affineTransformConcatIn(b, d.getNodeToParentTransform());
        return b
    },
    getNodeToParentAffineTransform: function(a) {
        return this.getNodeToParentTransform(a)
    },
    getCamera: function() {
        this._camera ||
            (this._camera = new cc.Camera);
        return this._camera
    },
    getGrid: function() {
        return this.grid
    },
    setGrid: function(a) {
        this.grid = a
    },
    getShaderProgram: function() {
        return this._renderCmd.getShaderProgram()
    },
    setShaderProgram: function(a) {
        this._renderCmd.setShaderProgram(a)
    },
    getGLServerState: function() {
        return 0
    },
    setGLServerState: function(a) {},
    getBoundingBoxToWorld: function() {
        var a = cc.rect(0, 0, this._contentSize.width, this._contentSize.height),
            b = this.getNodeToWorldTransform(),
            a = cc.rectApplyAffineTransform(a, b);
        if (!this._children) return a;
        for (var d = this._children, e = 0; e < d.length; e++) {
            var f = d[e];
            f && f._visible && (f = f._getBoundingBoxToCurrentNode(b)) && (a = cc.rectUnion(a, f))
        }
        return a
    },
    _getBoundingBoxToCurrentNode: function(a) {
        var b = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        a = void 0 === a ? this.getNodeToParentTransform() : cc.affineTransformConcat(this.getNodeToParentTransform(), a);
        b = cc.rectApplyAffineTransform(b, a);
        if (!this._children) return b;
        for (var d = this._children, e = 0; e < d.length; e++) {
            var f = d[e];
            f && f._visible && (f = f._getBoundingBoxToCurrentNode(a)) &&
                (b = cc.rectUnion(b, f))
        }
        return b
    },
    getOpacity: function() {
        return this._realOpacity
    },
    getDisplayedOpacity: function() {
        return this._renderCmd.getDisplayedOpacity()
    },
    setOpacity: function(a) {
        this._realOpacity = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
    },
    updateDisplayedOpacity: function(a) {
        this._renderCmd._updateDisplayOpacity(a)
    },
    isCascadeOpacityEnabled: function() {
        return this._cascadeOpacityEnabled
    },
    setCascadeOpacityEnabled: function(a) {
        this._cascadeOpacityEnabled !== a && (this._cascadeOpacityEnabled =
            a, this._renderCmd.setCascadeOpacityEnabledDirty())
    },
    getColor: function() {
        var a = this._realColor;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    getDisplayedColor: function() {
        return this._renderCmd.getDisplayedColor()
    },
    setColor: function(a) {
        var b = this._realColor;
        b.r = a.r;
        b.g = a.g;
        b.b = a.b;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty)
    },
    updateDisplayedColor: function(a) {
        this._renderCmd._updateDisplayColor(a)
    },
    isCascadeColorEnabled: function() {
        return this._cascadeColorEnabled
    },
    setCascadeColorEnabled: function(a) {
        this._cascadeColorEnabled !==
            a && (this._cascadeColorEnabled = a, this._renderCmd.setCascadeColorEnabledDirty())
    },
    setOpacityModifyRGB: function(a) {},
    isOpacityModifyRGB: function() {
        return !1
    },
    _initRendererCmd: function() {
        this._renderCmd = cc.renderer.getRenderCmd(this)
    },
    _createRenderCmd: function() {
        return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.Node.CanvasRenderCmd(this) : new cc.Node.WebGLRenderCmd(this)
    },
    enumerateChildren: function(a, b) {
        cc.assert(a && 0 != a.length, "Invalid name");
        cc.assert(null != b, "Invalid callback function");
        var d = a.length,
            e = 0,
            f = d,
            g = !1;
        2 < d && ("/" === a[0] && "/" === a[1]) && (g = !0, e = 2, f -= 2);
        var h = !1;
        3 < d && ("/" === a[d - 3] && "." === a[d - 2] && "." === a[d - 1]) && (h = !0, f -= 3);
        d = a.substr(e, f);
        h && (d = "[[:alnum:]]+/" + d);
        g ? this.doEnumerateRecursive(this, d, b) : this.doEnumerate(d, b)
    },
    doEnumerateRecursive: function(a, b, d) {
        if (!a.doEnumerate(b, d))
            for (var e = a.getChildren(), f = e.length, g = 0; g < f && !(a = e[g], this.doEnumerateRecursive(a, b, d)); g++);
    },
    doEnumerate: function(a, b) {
        var d = a.indexOf("/"),
            e = a,
            f = !1; - 1 !== d && (e = a.substr(0, d), f = !0);
        for (var d = !1, g, h = this._children,
            k = h.length, m = 0; m < k; m++)
            if (g = h[m], -1 !== g._name.indexOf(e))
                if (f) {
                    if (d = g.doEnumerate(a, b)) break
                } else if (b(g)) {
            d = !0;
            break
        }
        return d
    }
});
cc.Node.create = function() {
    return new cc.Node
};
cc.Node._stateCallbackType = {
    onEnter: 1,
    onExit: 2,
    cleanup: 3,
    onEnterTransitionDidFinish: 4,
    updateTransform: 5,
    onExitTransitionDidStart: 6,
    sortAllChildren: 7
};
cc.assert(cc.isFunction(cc._tmp.PrototypeCCNode), cc._LogInfos.MissingFile, "BaseNodesPropertyDefine.js");
cc._tmp.PrototypeCCNode();
delete cc._tmp.PrototypeCCNode;
cc.CustomRenderCmd = function(a, b) {
    this._needDraw = !0;
    this._target = a;
    this._callback = b;
    this.rendering = function(a, b, f) {
        this._callback && this._callback.call(this._target, a, b, f)
    }
};
cc.Node._dirtyFlags = {
    transformDirty: 1,
    visibleDirty: 2,
    colorDirty: 4,
    opacityDirty: 8,
    cacheDirty: 16,
    orderDirty: 32,
    textDirty: 64,
    gradientDirty: 128,
    all: 255
};
cc.Node.RenderCmd = function(a) {
    this._dirtyFlag = 1;
    this._node = a;
    this._needDraw = !1;
    this._anchorPointInPoints = new cc.Point(0, 0);
    this._transform = {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
    };
    this._worldTransform = {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
    };
    this._inverse = {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
    };
    this._displayedOpacity = 255;
    this._displayedColor = cc.color(255, 255, 255, 255);
    this._cascadeOpacityEnabledDirty = this._cascadeColorEnabledDirty = !1;
    this._curLevel = -1
};
cc.Node.RenderCmd.prototype = {
    constructor: cc.Node.RenderCmd,
    getAnchorPointInPoints: function() {
        return cc.p(this._anchorPointInPoints)
    },
    getDisplayedColor: function() {
        var a = this._displayedColor;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    getDisplayedOpacity: function() {
        return this._displayedOpacity
    },
    setCascadeColorEnabledDirty: function() {
        this._cascadeColorEnabledDirty = !0;
        this.setDirtyFlag(cc.Node._dirtyFlags.colorDirty)
    },
    setCascadeOpacityEnabledDirty: function() {
        this._cascadeOpacityEnabledDirty = !0;
        this.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
    },
    getParentToNodeTransform: function() {
        this._dirtyFlag & cc.Node._dirtyFlags.transformDirty && (this._inverse = cc.affineTransformInvert(this.getNodeToParentTransform()));
        return this._inverse
    },
    detachFromParent: function() {},
    _updateAnchorPointInPoint: function() {
        var a = this._anchorPointInPoints,
            b = this._node._contentSize,
            d = this._node._anchorPoint;
        a.x = b.width * d.x;
        a.y = b.height * d.y;
        this.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    setDirtyFlag: function(a) {
        0 === this._dirtyFlag && 0 !== a && cc.renderer.pushDirtyNode(this);
        this._dirtyFlag |= a
    },
    getParentRenderCmd: function() {
        return this._node && this._node._parent && this._node._parent._renderCmd ? this._node._parent._renderCmd : null
    },
    _updateDisplayColor: function(a) {
        var b = this._node,
            d = this._displayedColor,
            e = b._realColor,
            f;
        if (this._cascadeColorEnabledDirty && !b._cascadeColorEnabled) {
            d.r = e.r;
            d.g = e.g;
            d.b = e.b;
            d = new cc.Color(255, 255, 255, 255);
            a = b._children;
            b = 0;
            for (e = a.length; b < e; b++)(f = a[b]) && f._renderCmd && f._renderCmd._updateDisplayColor(d);
            this._cascadeColorEnabledDirty = !1
        } else if (void 0 ===
            a && (a = (a = b._parent) && a._cascadeColorEnabled ? a.getDisplayedColor() : cc.color.WHITE), d.r = 0 | e.r * a.r / 255, d.g = 0 | e.g * a.g / 255, d.b = 0 | e.b * a.b / 255, b._cascadeColorEnabled) {
            a = b._children;
            b = 0;
            for (e = a.length; b < e; b++)
                if ((f = a[b]) && f._renderCmd) f._renderCmd._updateDisplayColor(d), f._renderCmd._updateColor()
        }
        this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.colorDirty
    },
    _updateDisplayOpacity: function(a) {
        var b = this._node,
            d, e;
        if (this._cascadeOpacityEnabledDirty && !b._cascadeOpacityEnabled) {
            this._displayedOpacity = b._realOpacity;
            d = b._children;
            a = 0;
            for (b = d.length; a < b; a++)(e = d[a]) && e._renderCmd && e._renderCmd._updateDisplayOpacity(255);
            this._cascadeOpacityEnabledDirty = !1
        } else if (void 0 === a && (d = b._parent, a = 255, d && d._cascadeOpacityEnabled && (a = d.getDisplayedOpacity())), this._displayedOpacity = b._realOpacity * a / 255, b._cascadeOpacityEnabled) {
            d = b._children;
            a = 0;
            for (b = d.length; a < b; a++)
                if ((e = d[a]) && e._renderCmd) e._renderCmd._updateDisplayOpacity(this._displayedOpacity), e._renderCmd._updateColor()
        }
        this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.opacityDirty
    },
    _syncDisplayColor: function(a) {
        var b = this._node,
            d = this._displayedColor,
            e = b._realColor;
        void 0 === a && (a = (a = b._parent) && a._cascadeColorEnabled ? a.getDisplayedColor() : cc.color.WHITE);
        d.r = 0 | e.r * a.r / 255;
        d.g = 0 | e.g * a.g / 255;
        d.b = 0 | e.b * a.b / 255
    },
    _syncDisplayOpacity: function(a) {
        var b = this._node;
        if (void 0 === a) {
            var d = b._parent;
            a = 255;
            d && d._cascadeOpacityEnabled && (a = d.getDisplayedOpacity())
        }
        this._displayedOpacity = b._realOpacity * a / 255
    },
    _updateColor: function() {},
    updateStatus: function() {
        var a = cc.Node._dirtyFlags,
            b = this._dirtyFlag,
            d = b & a.colorDirty,
            e = b & a.opacityDirty;
        d && this._updateDisplayColor();
        e && this._updateDisplayOpacity();
        (d || e) && this._updateColor();
        b & a.transformDirty && (this.transform(this.getParentRenderCmd(), !0), this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.transformDirty)
    }
};
(function() {
    cc.Node.CanvasRenderCmd = function(a) {
        cc.Node.RenderCmd.call(this, a);
        this._cachedParent = null;
        this._cacheDirty = !1
    };
    var a = cc.Node.CanvasRenderCmd.prototype = Object.create(cc.Node.RenderCmd.prototype);
    a.constructor = cc.Node.CanvasRenderCmd;
    a.transform = function(a, d) {
        var e = this.getNodeToParentTransform(),
            f = this._worldTransform;
        this._cacheDirty = !0;
        if (a) {
            var g = a._worldTransform;
            f.a = e.a * g.a + e.b * g.c;
            f.b = e.a * g.b + e.b * g.d;
            f.c = e.c * g.a + e.d * g.c;
            f.d = e.c * g.b + e.d * g.d;
            f.tx = g.a * e.tx + g.c * e.ty + g.tx;
            f.ty = g.d * e.ty +
                g.ty + g.b * e.tx
        } else f.a = e.a, f.b = e.b, f.c = e.c, f.d = e.d, f.tx = e.tx, f.ty = e.ty; if (d && (e = this._node._children) && 0 !== e.length) {
            f = 0;
            for (g = e.length; f < g; f++) e[f]._renderCmd.transform(this, d)
        }
    };
    a.getNodeToParentTransform = function() {
        var a = this._node,
            d = !1;
        a._usingNormalizedPosition && a._parent && (d = a._parent._contentSize, a._position.x = a._normalizedPosition.x * d.width, a._position.y = a._normalizedPosition.y * d.height, a._normalizedPositionDirty = !1, d = !0);
        if (d || this._dirtyFlag & cc.Node._dirtyFlags.transformDirty) {
            d = this._transform;
            d.tx = a._position.x;
            d.ty = a._position.y;
            var e = 1,
                f = 0,
                g = 0,
                h = 1;
            a._rotationX && (h = 0.017453292519943295 * a._rotationX, g = Math.sin(h), h = Math.cos(h));
            a._rotationY && (f = 0.017453292519943295 * a._rotationY, e = Math.cos(f), f = -Math.sin(f));
            d.a = e;
            d.b = f;
            d.c = g;
            d.d = h;
            var k = a._scaleX,
                m = a._scaleY,
                n = this._anchorPointInPoints.x,
                p = this._anchorPointInPoints.y,
                r = 1E-6 > k && -1E-6 < k ? 1E-6 : k,
                s = 1E-6 > m && -1E-6 < m ? 1E-6 : m;
            if (1 !== k || 1 !== m) e = d.a *= r, f = d.b *= r, g = d.c *= s, h = d.d *= s;
            if (a._skewX || a._skewY) k = Math.tan(-a._skewX * Math.PI / 180), m = Math.tan(-a._skewY *
                Math.PI / 180), Infinity === k && (k = 99999999), Infinity === m && (m = 99999999), r = p * k, s = n * m, d.a = e - g * m, d.b = f - h * m, d.c = g - e * k, d.d = h - f * k, d.tx += e * r + g * s, d.ty += f * r + h * s;
            d.tx -= e * n + g * p;
            d.ty -= f * n + h * p;
            a._ignoreAnchorPointForPosition && (d.tx += n, d.ty += p);
            a._additionalTransformDirty && (this._transform = cc.affineTransformConcat(d, a._additionalTransform))
        }
        return this._transform
    };
    a.visit = function(a) {
        var d = this._node;
        if (d._visible) {
            if (a = a || this.getParentRenderCmd()) this._curLevel = a._curLevel + 1;
            var e = d._children,
                f;
            this._syncStatus(a);
            a = e.length;
            if (0 < a) {
                d.sortAllChildren();
                for (d = 0; d < a; d++)
                    if (f = e[d], 0 > f._localZOrder) f._renderCmd.visit(this);
                    else break;
                for (cc.renderer.pushRenderCommand(this); d < a; d++) e[d]._renderCmd.visit(this)
            } else cc.renderer.pushRenderCommand(this);
            this._dirtyFlag = 0
        }
    };
    a._syncStatus = function(a) {
        var d = cc.Node._dirtyFlags,
            e = this._dirtyFlag,
            f = a ? a._node : null;
        f && (f._cascadeColorEnabled && a._dirtyFlag & d.colorDirty) && (e |= d.colorDirty);
        f && (f._cascadeOpacityEnabled && a._dirtyFlag & d.opacityDirty) && (e |= d.opacityDirty);
        a && a._dirtyFlag &
            d.transformDirty && (e |= d.transformDirty);
        var f = e & d.colorDirty,
            g = e & d.opacityDirty,
            d = e & d.transformDirty;
        this._dirtyFlag = e;
        f && this._syncDisplayColor();
        g && this._syncDisplayOpacity();
        f && this._updateColor();
        d && this.transform(a)
    };
    a.setDirtyFlag = function(a, d) {
        cc.Node.RenderCmd.prototype.setDirtyFlag.call(this, a, d);
        this._setCacheDirty(d);
        this._cachedParent && this._cachedParent.setDirtyFlag(a, !0)
    };
    a._setCacheDirty = function() {
        if (!1 === this._cacheDirty) {
            this._cacheDirty = !0;
            var a = this._cachedParent;
            a && a !== this &&
                a._setNodeDirtyForCache && a._setNodeDirtyForCache()
        }
    };
    a._setCachedParent = function(a) {
        if (this._cachedParent !== a) {
            this._cachedParent = a;
            for (var d = this._node._children, e = 0, f = d.length; e < f; e++) d[e]._renderCmd._setCachedParent(a)
        }
    };
    a.detachFromParent = function() {
        this._cachedParent = null;
        for (var a = this._node._children, d, e = 0, f = a.length; e < f; e++)(d = a[e]) && d._renderCmd && d._renderCmd.detachFromParent()
    };
    a.setShaderProgram = function(a) {};
    a.getShaderProgram = function() {
        return null
    };
    cc.Node.CanvasRenderCmd._getCompositeOperationByBlendFunc =
        function(a) {
            return a ? a.src === cc.SRC_ALPHA && a.dst === cc.ONE || a.src === cc.ONE && a.dst === cc.ONE ? "lighter" : a.src === cc.ZERO && a.dst === cc.SRC_ALPHA ? "destination-in" : a.src === cc.ZERO && a.dst === cc.ONE_MINUS_SRC_ALPHA ? "destination-out" : "source-over" : "source-over"
        }
})();
(function() {
    cc.Node.WebGLRenderCmd = function(a) {
        cc.Node.RenderCmd.call(this, a);
        a = new cc.math.Matrix4;
        var d = a.mat;
        d[2] = d[3] = d[6] = d[7] = d[8] = d[9] = d[11] = d[14] = 0;
        d[10] = d[15] = 1;
        this._transform4x4 = a;
        this._stackMatrix = new cc.math.Matrix4;
        this._camera = this._shaderProgram = null
    };
    var a = cc.Node.WebGLRenderCmd.prototype = Object.create(cc.Node.RenderCmd.prototype);
    a.constructor = cc.Node.WebGLRenderCmd;
    a.getNodeToParentTransform = function() {
        var a = this._node;
        if (a._usingNormalizedPosition && a._parent) {
            var d = a._parent._contentSize;
            a._position.x = a._normalizedPosition.x * d.width;
            a._position.y = a._normalizedPosition.y * d.height;
            a._normalizedPositionDirty = !1
        }
        if (this._dirtyFlag & cc.Node._dirtyFlags.transformDirty) {
            var d = a._position.x,
                e = a._position.y,
                f = this._anchorPointInPoints.x,
                g = -f,
                h = this._anchorPointInPoints.y,
                k = -h,
                m = a._scaleX,
                n = a._scaleY,
                p = 0.017453292519943295 * a._rotationX,
                r = 0.017453292519943295 * a._rotationY;
            a._ignoreAnchorPointForPosition && (d += f, e += h);
            var s = 1,
                t = 0,
                u = 1,
                v = 0;
            if (0 !== a._rotationX || 0 !== a._rotationY) s = Math.cos(-p), t = Math.sin(-p),
                u = Math.cos(-r), v = Math.sin(-r);
            p = a._skewX || a._skewY;
            if (!p && (0 !== f || 0 !== h)) d += u * g * m + -t * k * n, e += v * g * m + s * k * n;
            r = this._transform;
            r.a = u * m;
            r.b = v * m;
            r.c = -t * n;
            r.d = s * n;
            r.tx = d;
            r.ty = e;
            if (p && (r = cc.affineTransformConcat({
                a: 1,
                b: Math.tan(cc.degreesToRadians(a._skewY)),
                c: Math.tan(cc.degreesToRadians(a._skewX)),
                d: 1,
                tx: 0,
                ty: 0
            }, r), 0 !== f || 0 !== h)) r = cc.affineTransformTranslate(r, g, k);
            a._additionalTransformDirty && (r = cc.affineTransformConcat(r, a._additionalTransform), a._additionalTransformDirty = !1);
            this._transform = r
        }
        return this._transform
    };
    a._syncStatus = function(a) {
        var d = cc.Node._dirtyFlags,
            e = this._dirtyFlag,
            f = a ? a._node : null;
        f && (f._cascadeColorEnabled && a._dirtyFlag & d.colorDirty) && (e |= d.colorDirty);
        f && (f._cascadeOpacityEnabled && a._dirtyFlag & d.opacityDirty) && (e |= d.opacityDirty);
        a && a._dirtyFlag & d.transformDirty && (e |= d.transformDirty);
        f = e & d.colorDirty;
        d = e & d.opacityDirty;
        this._dirtyFlag = e;
        f && this._syncDisplayColor();
        d && this._syncDisplayOpacity();
        (f || d) && this._updateColor();
        this.transform(a)
    };
    a._updateColor = function() {};
    a.visit = function(a) {
        var d =
            this._node;
        if (d._visible) {
            a = a || this.getParentRenderCmd();
            d._parent && d._parent._renderCmd && (this._curLevel = d._parent._renderCmd._curLevel + 1);
            var e = cc.current_stack;
            e.stack.push(e.top);
            this._syncStatus(a);
            e.top = this._stackMatrix;
            if ((a = d._children) && 0 < a.length) {
                var f = a.length;
                d.sortAllChildren();
                for (d = 0; d < f; d++)
                    if (a[d] && 0 > a[d]._localZOrder) a[d]._renderCmd.visit(this);
                    else break;
                for (cc.renderer.pushRenderCommand(this); d < f; d++) a[d] && a[d]._renderCmd.visit(this)
            } else cc.renderer.pushRenderCommand(this);
            this._dirtyFlag = 0;
            e.top = e.stack.pop()
        }
    };
    a.transform = function(a, d) {
        var e = this._transform4x4,
            f = this._stackMatrix,
            g = this._node,
            h = (a = a || this.getParentRenderCmd()) ? a._stackMatrix : cc.current_stack.top,
            k = this.getNodeToParentTransform();
        this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.transformDirty;
        var m = e.mat;
        m[0] = k.a;
        m[4] = k.c;
        m[12] = k.tx;
        m[1] = k.b;
        m[5] = k.d;
        m[13] = k.ty;
        m[14] = g._vertexZ;
        cc.kmMat4Multiply(f, h, e);
        null !== g._camera && !(null !== g.grid && g.grid.isActive()) && (h = this._anchorPointInPoints.x, k = this._anchorPointInPoints.y,
            0 !== h || 0 !== k ? (cc.SPRITEBATCHNODE_RENDER_SUBPIXEL || (h |= 0, k |= 0), m = cc.math.Matrix4.createByTranslation(h, k, 0, e), f.multiply(m), g._camera._locateForRenderer(f), m = cc.math.Matrix4.createByTranslation(-h, -k, 0, m), f.multiply(m), e.identity()) : g._camera._locateForRenderer(f));
        if (d && g._children && 0 !== g._children.length) {
            g = g._children;
            e = 0;
            for (f = g.length; e < f; e++) g[e]._renderCmd.transform(this, d)
        }
    };
    a.setShaderProgram = function(a) {
        this._shaderProgram = a
    };
    a.getShaderProgram = function() {
        return this._shaderProgram
    }
})();
cc.AtlasNode = cc.Node.extend({
    textureAtlas: null,
    quadsToDraw: 0,
    _itemsPerRow: 0,
    _itemsPerColumn: 0,
    _itemWidth: 0,
    _itemHeight: 0,
    _opacityModifyRGB: !1,
    _blendFunc: null,
    _ignoreContentScaleFactor: !1,
    _className: "AtlasNode",
    _textureForCanvas: null,
    ctor: function(a, b, d, e) {
        cc.Node.prototype.ctor.call(this);
        this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        };
        this._ignoreContentScaleFactor = !1;
        void 0 !== e && this.initWithTileFile(a, b, d, e)
    },
    _createRenderCmd: function() {
        this._renderCmd = cc._renderType === cc._RENDER_TYPE_CANVAS ?
            new cc.AtlasNode.CanvasRenderCmd(this) : new cc.AtlasNode.WebGLRenderCmd(this)
    },
    updateAtlasValues: function() {
        cc.log(cc._LogInfos.AtlasNode_updateAtlasValues)
    },
    getColor: function() {
        return this._opacityModifyRGB ? this._renderCmd._colorUnmodified : cc.Node.prototype.getColor.call(this)
    },
    setOpacityModifyRGB: function(a) {
        var b = this.color;
        this._opacityModifyRGB = a;
        this.setColor(b)
    },
    isOpacityModifyRGB: function() {
        return this._opacityModifyRGB
    },
    getBlendFunc: function() {
        return this._blendFunc
    },
    setBlendFunc: function(a,
        b) {
        this._blendFunc = void 0 === b ? a : {
            src: a,
            dst: b
        }
    },
    setTextureAtlas: function(a) {
        this.textureAtlas = a
    },
    getTextureAtlas: function() {
        return this.textureAtlas
    },
    getQuadsToDraw: function() {
        return this.quadsToDraw
    },
    setQuadsToDraw: function(a) {
        this.quadsToDraw = a
    },
    initWithTileFile: function(a, b, d, e) {
        if (!a) throw Error("cc.AtlasNode.initWithTileFile(): title should not be null");
        a = cc.textureCache.addImage(a);
        return this.initWithTexture(a, b, d, e)
    },
    initWithTexture: function(a, b, d, e) {
        return this._renderCmd.initWithTexture(a,
            b, d, e)
    },
    setColor: function(a) {
        this._renderCmd.setColor(a)
    },
    setOpacity: function(a) {
        this._renderCmd.setOpacity(a)
    },
    getTexture: function() {
        return this._renderCmd.getTexture()
    },
    setTexture: function(a) {
        this._renderCmd.setTexture(a)
    },
    _setIgnoreContentScaleFactor: function(a) {
        this._ignoreContentScaleFactor = a
    }
});
_p = cc.AtlasNode.prototype;
cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity);
cc.defineGetterSetter(_p, "color", _p.getColor, _p.setColor);
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.EventHelper.prototype.apply(_p);
cc.AtlasNode.create = function(a, b, d, e) {
    return new cc.AtlasNode(a, b, d, e)
};
(function() {
    cc.AtlasNode.CanvasRenderCmd = function(a) {
        cc.Node.CanvasRenderCmd.call(this, a);
        this._needDraw = !1;
        this._colorUnmodified = cc.color.WHITE;
        this._texture = this._originalTexture = null
    };
    var a = cc.AtlasNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    a.constructor = cc.AtlasNode.CanvasRenderCmd;
    a.initWithTexture = function(a, d, e, f) {
        var g = this._node;
        g._itemWidth = d;
        g._itemHeight = e;
        g._opacityModifyRGB = !0;
        this._originalTexture = a;
        if (!this._originalTexture) return cc.log(cc._LogInfos.AtlasNode__initWithTexture), !1;
        this._texture = this._originalTexture;
        this._calculateMaxItems();
        g.quadsToDraw = f;
        return !0
    };
    a.setColor = function(a) {
        var d = this._node._realColor;
        d.r === a.r && d.g === a.g && d.b === a.b || (this._colorUnmodified = a, this._changeTextureColor())
    };
    a._changeTextureColor = cc.sys._supportCanvasNewBlendModes ? function() {
        var a = this._node,
            d = a.getTexture();
        if (d && this._originalTexture) {
            var e = this._originalTexture.getHtmlElementObj();
            if (e) {
                var f = d.getHtmlElementObj(),
                    d = cc.rect(0, 0, e.width, e.height);
                f instanceof HTMLCanvasElement ?
                    cc.Sprite.CanvasRenderCmd._generateTintImageWithMultiply(e, this._colorUnmodified, d, f) : (f = cc.Sprite.CanvasRenderCmd._generateTintImageWithMultiply(e, this._colorUnmodified, d), d = new cc.Texture2D, d.initWithElement(f), d.handleLoadedTexture(), a.setTexture(d))
            }
        }
    } : function() {
        var a = this._node,
            d, e = a.getTexture();
        if (e && this._originalTexture && (d = e.getHtmlElementObj())) {
            var f = this._originalTexture.getHtmlElementObj();
            if (e = cc.textureCache.getTextureColors(f)) f = cc.rect(0, 0, f.width, f.height), d instanceof HTMLCanvasElement ?
                cc.Sprite.CanvasRenderCmd._generateTintImage(d, e, this._displayedColor, f, d) : (d = cc.Sprite.CanvasRenderCmd._generateTintImage(d, e, this._displayedColor, f), e = new cc.Texture2D, e.initWithElement(d), e.handleLoadedTexture(), a.setTexture(e))
        }
    };
    a.setOpacity = function(a) {
        cc.Node.prototype.setOpacity.call(this._node, a)
    };
    a.getTexture = function() {
        return this._texture
    };
    a.setTexture = function(a) {
        this._texture = a
    };
    a._calculateMaxItems = function() {
        var a = this._node,
            d = this._texture.getContentSize();
        a._itemsPerColumn = 0 | d.height /
            a._itemHeight;
        a._itemsPerRow = 0 | d.width / a._itemWidth
    }
})();
(function() {
    cc.AtlasNode.WebGLRenderCmd = function(a) {
        cc.Node.WebGLRenderCmd.call(this, a);
        this._needDraw = !0;
        this._textureAtlas = null;
        this._colorUnmodified = cc.color.WHITE;
        this._uniformColor = this._colorF32Array = null;
        this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE_UCOLOR);
        this._uniformColor = cc._renderContext.getUniformLocation(this._shaderProgram.getProgram(), "u_color")
    };
    var a = cc.AtlasNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    a.constructor =
        cc.AtlasNode.WebGLRenderCmd;
    a._updateBlendFunc = function() {
        var a = this._node;
        this._textureAtlas.texture.hasPremultipliedAlpha() || (a._blendFunc.src = cc.SRC_ALPHA, a._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA)
    };
    a._updateOpacityModifyRGB = function() {
        this._node._opacityModifyRGB = this._textureAtlas.texture.hasPremultipliedAlpha()
    };
    a.rendering = function(a) {
        a = a || cc._renderContext;
        var d = this._node;
        this._shaderProgram.use();
        this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix);
        cc.glBlendFunc(d._blendFunc.src,
            d._blendFunc.dst);
        this._uniformColor && this._colorF32Array && (a.uniform4fv(this._uniformColor, this._colorF32Array), this._textureAtlas.drawNumberOfQuads(d.quadsToDraw, 0))
    };
    a.initWithTexture = function(a, d, e, f) {
        var g = this._node;
        g._itemWidth = d;
        g._itemHeight = e;
        this._colorUnmodified = cc.color.WHITE;
        g._opacityModifyRGB = !0;
        g._blendFunc.src = cc.BLEND_SRC;
        g._blendFunc.dst = cc.BLEND_DST;
        d = g._realColor;
        this._colorF32Array = new Float32Array([d.r / 255, d.g / 255, d.b / 255, g._realOpacity / 255]);
        this._textureAtlas = new cc.TextureAtlas;
        this._textureAtlas.initWithTexture(a, f);
        if (!this._textureAtlas) return cc.log(cc._LogInfos.AtlasNode__initWithTexture), !1;
        this._updateBlendFunc();
        this._updateOpacityModifyRGB();
        this._calculateMaxItems();
        g.quadsToDraw = f;
        return !0
    };
    a.setColor = function(a) {
        var d = cc.color(a.r, a.g, a.b),
            e = this._node;
        this._colorUnmodified = a;
        a = this._displayedOpacity;
        e._opacityModifyRGB && (d.r = d.r * a / 255, d.g = d.g * a / 255, d.b = d.b * a / 255);
        cc.Node.prototype.setColor.call(e, d)
    };
    a.setOpacity = function(a) {
        var d = this._node;
        cc.Node.prototype.setOpacity.call(d,
            a);
        d._opacityModifyRGB && (d.color = this._colorUnmodified)
    };
    a._updateColor = function() {
        var a = this._displayedColor;
        this._colorF32Array = new Float32Array([a.r / 255, a.g / 255, a.b / 255, this._displayedOpacity / 255])
    };
    a.getTexture = function() {
        return this._textureAtlas.texture
    };
    a.setTexture = function(a) {
        this._textureAtlas.texture = a;
        this._updateBlendFunc();
        this._updateOpacityModifyRGB()
    };
    a._calculateMaxItems = function() {
        var a = this._node,
            d = this._textureAtlas.texture,
            e = d.getContentSize();
        a._ignoreContentScaleFactor && (e =
            d.getContentSizeInPixels());
        a._itemsPerColumn = 0 | e.height / a._itemHeight;
        a._itemsPerRow = 0 | e.width / a._itemWidth
    }
})();
cc._tmp.WebGLTexture2D = function() {
    cc.Texture2D = cc.Class.extend({
        _pVRHaveAlphaPremultiplied: !0,
        _pixelFormat: null,
        _pixelsWide: 0,
        _pixelsHigh: 0,
        _name: "",
        _contentSize: null,
        maxS: 0,
        maxT: 0,
        _hasPremultipliedAlpha: !1,
        _hasMipmaps: !1,
        shaderProgram: null,
        _textureLoaded: !1,
        _htmlElementObj: null,
        _webTextureObj: null,
        url: null,
        ctor: function() {
            this._contentSize = cc.size(0, 0);
            this._pixelFormat = cc.Texture2D.defaultPixelFormat
        },
        releaseTexture: function() {
            this._webTextureObj && cc._renderContext.deleteTexture(this._webTextureObj);
            cc.loader.release(this.url)
        },
        getPixelFormat: function() {
            return this._pixelFormat
        },
        getPixelsWide: function() {
            return this._pixelsWide
        },
        getPixelsHigh: function() {
            return this._pixelsHigh
        },
        getName: function() {
            return this._webTextureObj
        },
        getContentSize: function() {
            return cc.size(this._contentSize.width / cc.contentScaleFactor(), this._contentSize.height / cc.contentScaleFactor())
        },
        _getWidth: function() {
            return this._contentSize.width / cc.contentScaleFactor()
        },
        _getHeight: function() {
            return this._contentSize.height / cc.contentScaleFactor()
        },
        getContentSizeInPixels: function() {
            return this._contentSize
        },
        getMaxS: function() {
            return this.maxS
        },
        setMaxS: function(a) {
            this.maxS = a
        },
        getMaxT: function() {
            return this.maxT
        },
        setMaxT: function(a) {
            this.maxT = a
        },
        getShaderProgram: function() {
            return this.shaderProgram
        },
        setShaderProgram: function(a) {
            this.shaderProgram = a
        },
        hasPremultipliedAlpha: function() {
            return this._hasPremultipliedAlpha
        },
        hasMipmaps: function() {
            return this._hasMipmaps
        },
        description: function() {
            return "\x3ccc.Texture2D | Name \x3d " + this._name + " | Dimensions \x3d " +
                this._pixelsWide + " x " + this._pixelsHigh + " | Coordinates \x3d (" + this.maxS + ", " + this.maxT + ")\x3e"
        },
        releaseData: function(a) {},
        keepData: function(a, b) {
            return a
        },
        initWithData: function(a, b, d, e, f) {
            var g = cc.Texture2D,
                h = cc._renderContext,
                k = h.RGBA,
                m = h.UNSIGNED_BYTE,
                n = d * cc.Texture2D._B[b] / 8;
            0 === n % 8 ? h.pixelStorei(h.UNPACK_ALIGNMENT, 8) : 0 === n % 4 ? h.pixelStorei(h.UNPACK_ALIGNMENT, 4) : 0 === n % 2 ? h.pixelStorei(h.UNPACK_ALIGNMENT, 2) : h.pixelStorei(h.UNPACK_ALIGNMENT, 1);
            this._webTextureObj = h.createTexture();
            cc.glBindTexture2D(this);
            h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MIN_FILTER, h.LINEAR);
            h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MAG_FILTER, h.LINEAR);
            h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_S, h.CLAMP_TO_EDGE);
            h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_T, h.CLAMP_TO_EDGE);
            switch (b) {
                case g.PIXEL_FORMAT_RGBA8888:
                    k = h.RGBA;
                    break;
                case g.PIXEL_FORMAT_RGB888:
                    k = h.RGB;
                    break;
                case g.PIXEL_FORMAT_RGBA4444:
                    m = h.UNSIGNED_SHORT_4_4_4_4;
                    break;
                case g.PIXEL_FORMAT_RGB5A1:
                    m = h.UNSIGNED_SHORT_5_5_5_1;
                    break;
                case g.PIXEL_FORMAT_RGB565:
                    m = h.UNSIGNED_SHORT_5_6_5;
                    break;
                case g.PIXEL_FORMAT_AI88:
                    k = h.LUMINANCE_ALPHA;
                    break;
                case g.PIXEL_FORMAT_A8:
                    k = h.ALPHA;
                    break;
                case g.PIXEL_FORMAT_I8:
                    k = h.LUMINANCE;
                    break;
                default:
                    cc.assert(0, cc._LogInfos.Texture2D_initWithData)
            }
            h.texImage2D(h.TEXTURE_2D, 0, k, d, e, 0, k, m, a);
            this._contentSize.width = f.width;
            this._contentSize.height = f.height;
            this._pixelsWide = d;
            this._pixelsHigh = e;
            this._pixelFormat = b;
            this.maxS = f.width / d;
            this.maxT = f.height / e;
            this._hasMipmaps = this._hasPremultipliedAlpha = !1;
            this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE);
            return this._textureLoaded = !0
        },
        drawAtPoint: function(a) {
            var b = [0, this.maxT, this.maxS, this.maxT, 0, 0, this.maxS, 0],
                d = this._pixelsWide * this.maxS,
                e = this._pixelsHigh * this.maxT;
            a = [a.x, a.y, 0, d + a.x, a.y, 0, a.x, e + a.y, 0, d + a.x, e + a.y, 0];
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS);
            this._shaderProgram.use();
            this._shaderProgram.setUniformsForBuiltins();
            cc.glBindTexture2D(this);
            d = cc._renderContext;
            d.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, d.FLOAT, !1, 0, a);
            d.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS,
                2, d.FLOAT, !1, 0, b);
            d.drawArrays(d.TRIANGLE_STRIP, 0, 4)
        },
        drawInRect: function(a) {
            var b = [0, this.maxT, this.maxS, this.maxT, 0, 0, this.maxS, 0];
            a = [a.x, a.y, a.x + a.width, a.y, a.x, a.y + a.height, a.x + a.width, a.y + a.height];
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS);
            this._shaderProgram.use();
            this._shaderProgram.setUniformsForBuiltins();
            cc.glBindTexture2D(this);
            var d = cc._renderContext;
            d.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, d.FLOAT, !1, 0, a);
            d.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS,
                2, d.FLOAT, !1, 0, b);
            d.drawArrays(d.TRIANGLE_STRIP, 0, 4)
        },
        initWithImage: function(a) {
            if (null == a) return cc.log(cc._LogInfos.Texture2D_initWithImage), !1;
            var b = a.getWidth(),
                d = a.getHeight(),
                e = cc.configuration.getMaxTextureSize();
            if (b > e || d > e) return cc.log(cc._LogInfos.Texture2D_initWithImage_2, b, d, e, e), !1;
            this._textureLoaded = !0;
            return this._initPremultipliedATextureWithImage(a, b, d)
        },
        initWithElement: function(a) {
            a && (this._webTextureObj = cc._renderContext.createTexture(), this._htmlElementObj = a, this._textureLoaded = !0)
        },
        getHtmlElementObj: function() {
            return this._htmlElementObj
        },
        isLoaded: function() {
            return this._textureLoaded
        },
        handleLoadedTexture: function(a) {
            a = void 0 === a ? !1 : a;
            if (cc._rendererInitialized) {
                if (!this._htmlElementObj) {
                    var b = cc.loader.getRes(this.url);
                    if (!b) return;
                    this.initWithElement(b)
                }
                this._htmlElementObj.width && this._htmlElementObj.height && (b = cc._renderContext, cc.glBindTexture2D(this), b.pixelStorei(b.UNPACK_ALIGNMENT, 4), a && b.pixelStorei(b.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1), b.texImage2D(b.TEXTURE_2D,
                        0, b.RGBA, b.RGBA, b.UNSIGNED_BYTE, this._htmlElementObj), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.LINEAR), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, b.LINEAR), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.CLAMP_TO_EDGE), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.CLAMP_TO_EDGE), this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE), cc.glBindTexture2D(null), a && b.pixelStorei(b.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0), b = this._htmlElementObj.height, this._pixelsWide =
                    this._contentSize.width = this._htmlElementObj.width, this._pixelsHigh = this._contentSize.height = b, this._pixelFormat = cc.Texture2D.PIXEL_FORMAT_RGBA8888, this.maxT = this.maxS = 1, this._hasPremultipliedAlpha = a, this._hasMipmaps = !1, this.dispatchEvent("load"))
            }
        },
        initWithString: function(a, b, d, e, f, g) {
            cc.log(cc._LogInfos.Texture2D_initWithString);
            return null
        },
        initWithETCFile: function(a) {
            cc.log(cc._LogInfos.Texture2D_initWithETCFile_2);
            return !1
        },
        initWithPVRFile: function(a) {
            cc.log(cc._LogInfos.Texture2D_initWithPVRFile_2);
            return !1
        },
        initWithPVRTCData: function(a, b, d, e, f, g) {
            cc.log(cc._LogInfos.Texture2D_initWithPVRTCData_2);
            return !1
        },
        setTexParameters: function(a, b, d, e) {
            var f = cc._renderContext;
            void 0 !== b && (a = {
                minFilter: a,
                magFilter: b,
                wrapS: d,
                wrapT: e
            });
            cc.assert(this._pixelsWide === cc.NextPOT(this._pixelsWide) && this._pixelsHigh === cc.NextPOT(this._pixelsHigh) || a.wrapS === f.CLAMP_TO_EDGE && a.wrapT === f.CLAMP_TO_EDGE, "WebGLRenderingContext.CLAMP_TO_EDGE should be used in NPOT textures");
            cc.glBindTexture2D(this);
            f.texParameteri(f.TEXTURE_2D,
                f.TEXTURE_MIN_FILTER, a.minFilter);
            f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MAG_FILTER, a.magFilter);
            f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_S, a.wrapS);
            f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_T, a.wrapT)
        },
        setAntiAliasTexParameters: function() {
            var a = cc._renderContext;
            cc.glBindTexture2D(this);
            this._hasMipmaps ? a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR_MIPMAP_NEAREST) : a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR);
            a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.LINEAR)
        },
        setAliasTexParameters: function() {
            var a = cc._renderContext;
            cc.glBindTexture2D(this);
            this._hasMipmaps ? a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.NEAREST_MIPMAP_NEAREST) : a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.NEAREST);
            a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.NEAREST)
        },
        generateMipmap: function() {
            cc.assert(this._pixelsWide === cc.NextPOT(this._pixelsWide) && this._pixelsHigh === cc.NextPOT(this._pixelsHigh), "Mimpap texture only works in POT textures");
            cc.glBindTexture2D(this);
            cc._renderContext.generateMipmap(cc._renderContext.TEXTURE_2D);
            this._hasMipmaps = !0
        },
        stringForFormat: function() {
            return cc.Texture2D._M[this._pixelFormat]
        },
        bitsPerPixelForFormat: function(a) {
            a = a || this._pixelFormat;
            var b = cc.Texture2D._B[a];
            if (null != b) return b;
            cc.log(cc._LogInfos.Texture2D_bitsPerPixelForFormat, a);
            return -1
        },
        _initPremultipliedATextureWithImage: function(a, b, d) {
            var e = cc.Texture2D,
                f = a.getData(),
                g = null,
                g = null,
                h = a.hasAlpha(),
                k = cc.size(a.getWidth(), a.getHeight()),
                m = e.defaultPixelFormat,
                n = a.getBitsPerComponent();
            h || (8 <= n ? m = e.PIXEL_FORMAT_RGB888 : (cc.log(cc._LogInfos.Texture2D__initPremultipliedATextureWithImage), m = e.PIXEL_FORMAT_RGB565));
            var p = b * d;
            if (m === e.PIXEL_FORMAT_RGB565)
                if (h) {
                    f = new Uint16Array(b * d);
                    g = a.getData();
                    for (n = 0; n < p; ++n) f[n] = (g[n] >> 0 & 255) >> 3 << 11 | (g[n] >> 8 & 255) >> 2 << 5 | (g[n] >> 16 & 255) >> 3 << 0
                } else {
                    f = new Uint16Array(b * d);
                    g = a.getData();
                    for (n = 0; n < p; ++n) f[n] = (g[n] & 255) >> 3 << 11 | (g[n] & 255) >> 2 << 5 | (g[n] & 255) >> 3 << 0
                } else if (m === e.PIXEL_FORMAT_RGBA4444) {
                f = new Uint16Array(b * d);
                g = a.getData();
                for (n = 0; n < p; ++n) f[n] =
                    (g[n] >> 0 & 255) >> 4 << 12 | (g[n] >> 8 & 255) >> 4 << 8 | (g[n] >> 16 & 255) >> 4 << 4 | (g[n] >> 24 & 255) >> 4 << 0
            } else if (m === e.PIXEL_FORMAT_RGB5A1) {
                f = new Uint16Array(b * d);
                g = a.getData();
                for (n = 0; n < p; ++n) f[n] = (g[n] >> 0 & 255) >> 3 << 11 | (g[n] >> 8 & 255) >> 3 << 6 | (g[n] >> 16 & 255) >> 3 << 1 | (g[n] >> 24 & 255) >> 7 << 0
            } else if (m === e.PIXEL_FORMAT_A8) {
                f = new Uint8Array(b * d);
                g = a.getData();
                for (n = 0; n < p; ++n) f[n] = g >> 24 & 255
            }
            if (h && m === e.PIXEL_FORMAT_RGB888) {
                g = a.getData();
                f = new Uint8Array(3 * b * d);
                for (n = 0; n < p; ++n) f[3 * n] = g >> 0 & 255, f[3 * n + 1] = g >> 8 & 255, f[3 * n + 2] = g >> 16 & 255
            }
            this.initWithData(f,
                m, b, d, k);
            a.getData();
            this._hasPremultipliedAlpha = a.isPremultipliedAlpha();
            return !0
        },
        addLoadedEventListener: function(a, b) {
            this.addEventListener("load", a, b)
        },
        removeLoadedEventListener: function(a) {
            this.removeEventListener("load", a)
        }
    })
};
cc._tmp.WebGLTextureAtlas = function() {
    var a = cc.TextureAtlas.prototype;
    a._setupVBO = function() {
        var a = cc._renderContext;
        this._buffersVBO[0] = a.createBuffer();
        this._buffersVBO[1] = a.createBuffer();
        this._quadsWebBuffer = a.createBuffer();
        this._mapBuffers()
    };
    a._mapBuffers = function() {
        var a = cc._renderContext;
        a.bindBuffer(a.ARRAY_BUFFER, this._quadsWebBuffer);
        a.bufferData(a.ARRAY_BUFFER, this._quadsArrayBuffer, a.DYNAMIC_DRAW);
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
        a.bufferData(a.ELEMENT_ARRAY_BUFFER,
            this._indices, a.STATIC_DRAW)
    };
    a.drawNumberOfQuads = function(a, d) {
        d = d || 0;
        if (!(0 === a || !this.texture || !this.texture.isLoaded())) {
            var e = cc._renderContext;
            cc.glBindTexture2D(this.texture);
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
            e.bindBuffer(e.ARRAY_BUFFER, this._quadsWebBuffer);
            this.dirty && (e.bufferData(e.ARRAY_BUFFER, this._quadsArrayBuffer, e.DYNAMIC_DRAW), this.dirty = !1);
            e.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, e.FLOAT, !1, 24, 0);
            e.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR,
                4, e.UNSIGNED_BYTE, !0, 24, 12);
            e.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, e.FLOAT, !1, 24, 16);
            e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
            cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP ? e.drawElements(e.TRIANGLE_STRIP, 6 * a, e.UNSIGNED_SHORT, 6 * d * this._indices.BYTES_PER_ELEMENT) : e.drawElements(e.TRIANGLES, 6 * a, e.UNSIGNED_SHORT, 6 * d * this._indices.BYTES_PER_ELEMENT);
            cc.g_NumberOfDraws++
        }
    }
};
cc._tmp.WebGLTextureCache = function() {
    var a = cc.textureCache;
    a.handleLoadedTexture = function(a) {
        var d = this._textures,
            e;
        cc._rendererInitialized || (d = this._loadedTexturesBefore);
        e = d[a];
        e || (e = d[a] = new cc.Texture2D, e.url = a);
        ".png" === cc.path.extname(a) ? e.handleLoadedTexture(!0) : e.handleLoadedTexture()
    };
    a.addImage = function(a, d, e) {
        cc.assert(a, cc._LogInfos.Texture2D_addImage_2);
        var f = this._textures;
        cc._rendererInitialized || (f = this._loadedTexturesBefore);
        var g = f[a] || f[cc.loader._aliases[a]];
        if (g) return g.isLoaded() ?
            d && d.call(e, g) : g.addEventListener("load", function() {
                d && d.call(e, g)
            }, e), g;
        g = f[a] = new cc.Texture2D;
        g.url = a;
        (cc.loader._checkIsImageURL(a) ? cc.loader.load : cc.loader.loadImg).call(cc.loader, a, function(g, k) {
            if (g) return d && d.call(e, g);
            cc.textureCache.handleLoadedTexture(a);
            var m = f[a];
            d && d.call(e, m)
        });
        return g
    };
    a.addImageAsync = a.addImage;
    a = null
};
cc._tmp.PrototypeTexture2D = function() {
    var a = cc.Texture2D;
    a.PVRImagesHavePremultipliedAlpha = function(a) {
        cc.PVRHaveAlphaPremultiplied_ = a
    };
    a.PIXEL_FORMAT_RGBA8888 = 2;
    a.PIXEL_FORMAT_RGB888 = 3;
    a.PIXEL_FORMAT_RGB565 = 4;
    a.PIXEL_FORMAT_A8 = 5;
    a.PIXEL_FORMAT_I8 = 6;
    a.PIXEL_FORMAT_AI88 = 7;
    a.PIXEL_FORMAT_RGBA4444 = 8;
    a.PIXEL_FORMAT_RGB5A1 = 7;
    a.PIXEL_FORMAT_PVRTC4 = 9;
    a.PIXEL_FORMAT_PVRTC2 = 10;
    a.PIXEL_FORMAT_DEFAULT = a.PIXEL_FORMAT_RGBA8888;
    a.defaultPixelFormat = a.PIXEL_FORMAT_DEFAULT;
    var b = cc.Texture2D._M = {};
    b[a.PIXEL_FORMAT_RGBA8888] =
        "RGBA8888";
    b[a.PIXEL_FORMAT_RGB888] = "RGB888";
    b[a.PIXEL_FORMAT_RGB565] = "RGB565";
    b[a.PIXEL_FORMAT_A8] = "A8";
    b[a.PIXEL_FORMAT_I8] = "I8";
    b[a.PIXEL_FORMAT_AI88] = "AI88";
    b[a.PIXEL_FORMAT_RGBA4444] = "RGBA4444";
    b[a.PIXEL_FORMAT_RGB5A1] = "RGB5A1";
    b[a.PIXEL_FORMAT_PVRTC4] = "PVRTC4";
    b[a.PIXEL_FORMAT_PVRTC2] = "PVRTC2";
    b = cc.Texture2D._B = {};
    b[a.PIXEL_FORMAT_RGBA8888] = 32;
    b[a.PIXEL_FORMAT_RGB888] = 24;
    b[a.PIXEL_FORMAT_RGB565] = 16;
    b[a.PIXEL_FORMAT_A8] = 8;
    b[a.PIXEL_FORMAT_I8] = 8;
    b[a.PIXEL_FORMAT_AI88] = 16;
    b[a.PIXEL_FORMAT_RGBA4444] =
        16;
    b[a.PIXEL_FORMAT_RGB5A1] = 16;
    b[a.PIXEL_FORMAT_PVRTC4] = 4;
    b[a.PIXEL_FORMAT_PVRTC2] = 3;
    a = cc.Texture2D.prototype;
    cc.defineGetterSetter(a, "name", a.getName);
    cc.defineGetterSetter(a, "pixelFormat", a.getPixelFormat);
    cc.defineGetterSetter(a, "pixelsWidth", a.getPixelsWide);
    cc.defineGetterSetter(a, "pixelsHeight", a.getPixelsHigh);
    cc.defineGetterSetter(a, "width", a._getWidth);
    cc.defineGetterSetter(a, "height", a._getHeight)
};
cc._tmp.PrototypeTextureAtlas = function() {
    var a = cc.TextureAtlas.prototype;
    cc.defineGetterSetter(a, "totalQuads", a.getTotalQuads);
    cc.defineGetterSetter(a, "capacity", a.getCapacity);
    cc.defineGetterSetter(a, "quads", a.getQuads, a.setQuads)
};
cc.ALIGN_CENTER = 51;
cc.ALIGN_TOP = 19;
cc.ALIGN_TOP_RIGHT = 18;
cc.ALIGN_RIGHT = 50;
cc.ALIGN_BOTTOM_RIGHT = 34;
cc.ALIGN_BOTTOM = 35;
cc.ALIGN_BOTTOM_LEFT = 33;
cc.ALIGN_LEFT = 49;
cc.ALIGN_TOP_LEFT = 17;
cc.PVRHaveAlphaPremultiplied_ = !1;
cc._renderType === cc._RENDER_TYPE_CANVAS ? (cc.Texture2D = cc.Class.extend({
    _contentSize: null,
    _textureLoaded: !1,
    _htmlElementObj: null,
    url: null,
    _pattern: null,
    ctor: function() {
        this._contentSize = cc.size(0, 0);
        this._textureLoaded = !1;
        this._htmlElementObj = null;
        this._pattern = ""
    },
    getPixelsWide: function() {
        return this._contentSize.width
    },
    getPixelsHigh: function() {
        return this._contentSize.height
    },
    getContentSize: function() {
        var a = cc.contentScaleFactor();
        return cc.size(this._contentSize.width / a, this._contentSize.height /
            a)
    },
    _getWidth: function() {
        return this._contentSize.width / cc.contentScaleFactor()
    },
    _getHeight: function() {
        return this._contentSize.height / cc.contentScaleFactor()
    },
    getContentSizeInPixels: function() {
        return this._contentSize
    },
    initWithElement: function(a) {
        a && (this._htmlElementObj = a, this._contentSize.width = a.width, this._contentSize.height = a.height, this._textureLoaded = !0)
    },
    getHtmlElementObj: function() {
        return this._htmlElementObj
    },
    isLoaded: function() {
        return this._textureLoaded
    },
    handleLoadedTexture: function() {
        if (!this._textureLoaded) {
            if (!this._htmlElementObj) {
                var a =
                    cc.loader.getRes(this.url);
                if (!a) return;
                this.initWithElement(a)
            }
            a = this._htmlElementObj;
            this._contentSize.width = a.width;
            this._contentSize.height = a.height;
            this.dispatchEvent("load")
        }
    },
    description: function() {
        return "\x3ccc.Texture2D | width \x3d " + this._contentSize.width + " height " + this._contentSize.height + "\x3e"
    },
    initWithData: function(a, b, d, e, f) {
        return !1
    },
    initWithImage: function(a) {
        return !1
    },
    initWithString: function(a, b, d, e, f, g) {
        return !1
    },
    releaseTexture: function() {
        cc.loader.release(this.url)
    },
    getName: function() {
        return null
    },
    getMaxS: function() {
        return 1
    },
    setMaxS: function(a) {},
    getMaxT: function() {
        return 1
    },
    setMaxT: function(a) {},
    getPixelFormat: function() {
        return null
    },
    getShaderProgram: function() {
        return null
    },
    setShaderProgram: function(a) {},
    hasPremultipliedAlpha: function() {
        return !1
    },
    hasMipmaps: function() {
        return !1
    },
    releaseData: function(a) {},
    keepData: function(a, b) {
        return a
    },
    drawAtPoint: function(a) {},
    drawInRect: function(a) {},
    initWithETCFile: function(a) {
        cc.log(cc._LogInfos.Texture2D_initWithETCFile);
        return !1
    },
    initWithPVRFile: function(a) {
        cc.log(cc._LogInfos.Texture2D_initWithPVRFile);
        return !1
    },
    initWithPVRTCData: function(a, b, d, e, f, g) {
        cc.log(cc._LogInfos.Texture2D_initWithPVRTCData);
        return !1
    },
    setTexParameters: function(a, b, d, e) {
        void 0 !== b && (a = {
            minFilter: a,
            magFilter: b,
            wrapS: d,
            wrapT: e
        });
        this._pattern = a.wrapS === cc.REPEAT && a.wrapT === cc.REPEAT ? "repeat" : a.wrapS === cc.REPEAT ? "repeat-x" : a.wrapT === cc.REPEAT ? "repeat-y" : ""
    },
    setAntiAliasTexParameters: function() {},
    setAliasTexParameters: function() {},
    generateMipmap: function() {},
    stringForFormat: function() {
        return ""
    },
    bitsPerPixelForFormat: function(a) {
        return -1
    },
    addLoadedEventListener: function(a, b) {
        this.addEventListener("load", a, b)
    },
    removeLoadedEventListener: function(a) {
        this.removeEventListener("load", a)
    },
    _grayElementObj: null,
    _backupElement: null,
    _isGray: !1,
    _switchToGray: function(a) {
        this._textureLoaded && this._isGray !== a && ((this._isGray = a) ? (this._backupElement = this._htmlElementObj, this._grayElementObj || (this._grayElementObj = cc.Texture2D._generateGrayTexture(this._htmlElementObj)), this._htmlElementObj = this._grayElementObj) : null !== this._backupElement && (this._htmlElementObj =
            this._backupElement))
    }
}), cc.Texture2D._generateGrayTexture = function(a, b, d) {
    if (null === a) return null;
    d = d || cc.newElement("canvas");
    b = b || cc.rect(0, 0, a.width, a.height);
    d.width = b.width;
    d.height = b.height;
    var e = d.getContext("2d");
    e.drawImage(a, b.x, b.y, b.width, b.height, 0, 0, b.width, b.height);
    a = e.getImageData(0, 0, b.width, b.height);
    b = a.data;
    for (var f = 0, g = b.length; f < g; f += 4) b[f] = b[f + 1] = b[f + 2] = 0.34 * b[f] + 0.5 * b[f + 1] + 0.16 * b[f + 2];
    e.putImageData(a, 0, 0);
    return d
}) : (cc.assert(cc.isFunction(cc._tmp.WebGLTexture2D), cc._LogInfos.MissingFile,
    "TexturesWebGL.js"), cc._tmp.WebGLTexture2D(), delete cc._tmp.WebGLTexture2D);
cc.EventHelper.prototype.apply(cc.Texture2D.prototype);
cc.assert(cc.isFunction(cc._tmp.PrototypeTexture2D), cc._LogInfos.MissingFile, "TexturesPropertyDefine.js");
cc._tmp.PrototypeTexture2D();
delete cc._tmp.PrototypeTexture2D;
cc.textureCache = {
    _textures: {},
    _textureColorsCache: {},
    _textureKeySeq: 0 | 1E3 * Math.random(),
    _loadedTexturesBefore: {},
    _initializingRenderer: function() {
        var a, b = this._loadedTexturesBefore,
            d = this._textures;
        for (a in b) {
            var e = b[a];
            e.handleLoadedTexture();
            d[a] = e
        }
        this._loadedTexturesBefore = {}
    },
    addPVRTCImage: function(a) {
        cc.log(cc._LogInfos.textureCache_addPVRTCImage)
    },
    addETCImage: function(a) {
        cc.log(cc._LogInfos.textureCache_addETCImage)
    },
    description: function() {
        return "\x3cTextureCache | Number of textures \x3d " +
            this._textures.length + "\x3e"
    },
    textureForKey: function(a) {
        cc.log(cc._LogInfos.textureCache_textureForKey);
        return this.getTextureForKey(a)
    },
    getTextureForKey: function(a) {
        return this._textures[a] || this._textures[cc.loader._aliases[a]]
    },
    getKeyByTexture: function(a) {
        for (var b in this._textures)
            if (this._textures[b] === a) return b;
        return null
    },
    _generalTextureKey: function() {
        this._textureKeySeq++;
        return "_textureKey_" + this._textureKeySeq
    },
    getTextureColors: function(a) {
        var b = this.getKeyByTexture(a);
        b || (b = a instanceof HTMLImageElement ? a.src : this._generalTextureKey());
        this._textureColorsCache[b] || (this._textureColorsCache[b] = cc.Sprite.CanvasRenderCmd._generateTextureCacheForColor(a));
        return this._textureColorsCache[b]
    },
    addPVRImage: function(a) {
        cc.log(cc._LogInfos.textureCache_addPVRImage)
    },
    removeAllTextures: function() {
        var a = this._textures,
            b;
        for (b in a) a[b] && a[b].releaseTexture();
        this._textures = {}
    },
    removeTexture: function(a) {
        if (a) {
            var b = this._textures,
                d;
            for (d in b) b[d] === a && (b[d].releaseTexture(), delete b[d])
        }
    },
    removeTextureForKey: function(a) {
        null !=
            a && this._textures[a] && delete this._textures[a]
    },
    cacheImage: function(a, b) {
        if (b instanceof cc.Texture2D) this._textures[a] = b;
        else {
            var d = new cc.Texture2D;
            d.initWithElement(b);
            d.handleLoadedTexture();
            this._textures[a] = d
        }
    },
    addUIImage: function(a, b) {
        cc.assert(a, cc._LogInfos.textureCache_addUIImage_2);
        if (b && this._textures[b]) return this._textures[b];
        var d = new cc.Texture2D;
        d.initWithImage(a);
        null != b ? this._textures[b] = d : cc.log(cc._LogInfos.textureCache_addUIImage);
        return d
    },
    dumpCachedTextureInfo: function() {
        var a =
            0,
            b = 0,
            d = this._textures,
            e;
        for (e in d) {
            var f = d[e];
            a++;
            f.getHtmlElementObj() instanceof HTMLImageElement ? cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo, e, f.getHtmlElementObj().src, f.pixelsWidth, f.pixelsHeight) : cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_2, e, f.pixelsWidth, f.pixelsHeight);
            b += 4 * f.pixelsWidth * f.pixelsHeight
        }
        d = this._textureColorsCache;
        for (e in d) {
            var f = d[e],
                g;
            for (g in f) {
                var h = f[g];
                a++;
                cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_2, e, h.width, h.height);
                b += 4 * h.width *
                    h.height
            }
        }
        cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_3, a, b / 1024, (b / 1048576).toFixed(2))
    },
    _clear: function() {
        this._textures = {};
        this._textureColorsCache = {};
        this._textureKeySeq = 0 | 1E3 * Math.random();
        this._loadedTexturesBefore = {}
    }
};
cc._renderType === cc._RENDER_TYPE_CANVAS ? (_p = cc.textureCache, _p.handleLoadedTexture = function(a) {
    var b = this._textures,
        d = b[a];
    d || (d = b[a] = new cc.Texture2D, d.url = a);
    d.handleLoadedTexture()
}, _p.addImage = function(a, b, d) {
    cc.assert(a, cc._LogInfos.Texture2D_addImage);
    var e = this._textures,
        f = e[a] || e[cc.loader._aliases[a]];
    if (f) return f.isLoaded() ? b && b.call(d, f) : f.addEventListener("load", function() {
        b && b.call(d, f)
    }, d), f;
    f = e[a] = new cc.Texture2D;
    f.url = a;
    (cc.loader._checkIsImageURL(a) ? cc.loader.load : cc.loader.loadImg).call(cc.loader,
        a, function(f, h) {
            if (f) return b && b.call(d, f);
            cc.textureCache.handleLoadedTexture(a);
            var k = e[a];
            b && b.call(d, k)
        });
    return f
}, _p.addImageAsync = _p.addImage, _p = null) : (cc.assert(cc.isFunction(cc._tmp.WebGLTextureCache), cc._LogInfos.MissingFile, "TexturesWebGL.js"), cc._tmp.WebGLTextureCache(), delete cc._tmp.WebGLTextureCache);
cc.TextureAtlas = cc.Class.extend({
    dirty: !1,
    texture: null,
    _indices: null,
    _buffersVBO: null,
    _capacity: 0,
    _quads: null,
    _quadsArrayBuffer: null,
    _quadsWebBuffer: null,
    _quadsReader: null,
    ctor: function(a, b) {
        this._buffersVBO = [];
        cc.isString(a) ? this.initWithFile(a, b) : a instanceof cc.Texture2D && this.initWithTexture(a, b)
    },
    getTotalQuads: function() {
        return this._totalQuads
    },
    getCapacity: function() {
        return this._capacity
    },
    getTexture: function() {
        return this.texture
    },
    setTexture: function(a) {
        this.texture = a
    },
    setDirty: function(a) {
        this.dirty =
            a
    },
    isDirty: function() {
        return this.dirty
    },
    getQuads: function() {
        return this._quads
    },
    setQuads: function(a) {
        this._quads = a
    },
    _copyQuadsToTextureAtlas: function(a, b) {
        if (a)
            for (var d = 0; d < a.length; d++) this._setQuadToArray(a[d], b + d)
    },
    _setQuadToArray: function(a, b) {
        var d = this._quads;
        d[b] ? (d[b].bl = a.bl, d[b].br = a.br, d[b].tl = a.tl, d[b].tr = a.tr) : d[b] = new cc.V3F_C4B_T2F_Quad(a.tl, a.bl, a.tr, a.br, this._quadsArrayBuffer, b * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT)
    },
    description: function() {
        return "\x3ccc.TextureAtlas | totalQuads \x3d" +
            this._totalQuads + "\x3e"
    },
    _setupIndices: function() {
        if (0 !== this._capacity)
            for (var a = this._indices, b = this._capacity, d = 0; d < b; d++) cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP ? (a[6 * d + 0] = 4 * d + 0, a[6 * d + 1] = 4 * d + 0, a[6 * d + 2] = 4 * d + 2, a[6 * d + 3] = 4 * d + 1, a[6 * d + 4] = 4 * d + 3, a[6 * d + 5] = 4 * d + 3) : (a[6 * d + 0] = 4 * d + 0, a[6 * d + 1] = 4 * d + 1, a[6 * d + 2] = 4 * d + 2, a[6 * d + 3] = 4 * d + 3, a[6 * d + 4] = 4 * d + 2, a[6 * d + 5] = 4 * d + 1)
    },
    _setupVBO: function() {
        var a = cc._renderContext;
        this._buffersVBO[0] = a.createBuffer();
        this._buffersVBO[1] = a.createBuffer();
        this._quadsWebBuffer = a.createBuffer();
        this._mapBuffers()
    },
    _mapBuffers: function() {
        var a = cc._renderContext;
        a.bindBuffer(a.ARRAY_BUFFER, this._quadsWebBuffer);
        a.bufferData(a.ARRAY_BUFFER, this._quadsArrayBuffer, a.DYNAMIC_DRAW);
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
        a.bufferData(a.ELEMENT_ARRAY_BUFFER, this._indices, a.STATIC_DRAW)
    },
    initWithFile: function(a, b) {
        var d = cc.textureCache.addImage(a);
        if (d) return this.initWithTexture(d, b);
        cc.log(cc._LogInfos.TextureAtlas_initWithFile, a);
        return !1
    },
    initWithTexture: function(a, b) {
        cc.assert(a,
            cc._LogInfos.TextureAtlas_initWithTexture);
        this._capacity = b |= 0;
        this._totalQuads = 0;
        this.texture = a;
        this._quads = [];
        this._indices = new Uint16Array(6 * b);
        var d = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
        this._quadsArrayBuffer = new ArrayBuffer(d * b);
        this._quadsReader = new Uint8Array(this._quadsArrayBuffer);
        if ((!this._quads || !this._indices) && 0 < b) return !1;
        for (var e = this._quads, f = 0; f < b; f++) e[f] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, f * d);
        this._setupIndices();
        this._setupVBO();
        return this.dirty = !0
    },
    updateQuad: function(a, b) {
        cc.assert(a, cc._LogInfos.TextureAtlas_updateQuad);
        cc.assert(0 <= b && b < this._capacity, cc._LogInfos.TextureAtlas_updateQuad_2);
        this._totalQuads = Math.max(b + 1, this._totalQuads);
        this._setQuadToArray(a, b);
        this.dirty = !0
    },
    insertQuad: function(a, b) {
        cc.assert(b < this._capacity, cc._LogInfos.TextureAtlas_insertQuad_2);
        this._totalQuads++;
        if (this._totalQuads > this._capacity) cc.log(cc._LogInfos.TextureAtlas_insertQuad);
        else {
            var d = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
                e = b * d,
                f = (this._totalQuads -
                    1 - b) * d;
            this._quads[this._totalQuads - 1] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, (this._totalQuads - 1) * d);
            this._quadsReader.set(this._quadsReader.subarray(e, e + f), e + d);
            this._setQuadToArray(a, b);
            this.dirty = !0
        }
    },
    insertQuads: function(a, b, d) {
        d = d || a.length;
        cc.assert(b + d <= this._capacity, cc._LogInfos.TextureAtlas_insertQuads);
        var e = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
        this._totalQuads += d;
        if (this._totalQuads > this._capacity) cc.log(cc._LogInfos.TextureAtlas_insertQuad);
        else {
            var f = b *
                e,
                g = (this._totalQuads - 1 - b - d) * e,
                h = this._totalQuads - 1 - d,
                k;
            for (k = 0; k < d; k++) this._quads[h + k] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, (this._totalQuads - 1) * e);
            this._quadsReader.set(this._quadsReader.subarray(f, f + g), f + e * d);
            for (k = 0; k < d; k++) this._setQuadToArray(a[k], b + k);
            this.dirty = !0
        }
    },
    insertQuadFromIndex: function(a, b) {
        if (a !== b) {
            cc.assert(0 <= b || b < this._totalQuads, cc._LogInfos.TextureAtlas_insertQuadFromIndex);
            cc.assert(0 <= a || a < this._totalQuads, cc._LogInfos.TextureAtlas_insertQuadFromIndex_2);
            var d = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
                e = this._quadsReader,
                f = e.subarray(a * d, d),
                g;
            a > b ? (g = b * d, e.set(e.subarray(g, g + (a - b) * d), g + d), e.set(f, g)) : (g = (a + 1) * d, e.set(e.subarray(g, g + (b - a) * d), g - d), e.set(f, b * d));
            this.dirty = !0
        }
    },
    removeQuadAtIndex: function(a) {
        cc.assert(a < this._totalQuads, cc._LogInfos.TextureAtlas_removeQuadAtIndex);
        var b = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
        this._totalQuads--;
        this._quads.length = this._totalQuads;
        if (a !== this._totalQuads) {
            var d = (a + 1) * b;
            this._quadsReader.set(this._quadsReader.subarray(d,
                d + (this._totalQuads - a) * b), d - b)
        }
        this.dirty = !0
    },
    removeQuadsAtIndex: function(a, b) {
        cc.assert(a + b <= this._totalQuads, cc._LogInfos.TextureAtlas_removeQuadsAtIndex);
        this._totalQuads -= b;
        if (a !== this._totalQuads) {
            var d = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
                e = (a + b) * d;
            this._quadsReader.set(this._quadsReader.subarray(e, e + (this._totalQuads - a) * d), a * d)
        }
        this.dirty = !0
    },
    removeAllQuads: function() {
        this._totalQuads = this._quads.length = 0
    },
    _setDirty: function(a) {
        this.dirty = a
    },
    resizeCapacity: function(a) {
        if (a === this._capacity) return !0;
        var b = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
            d = this._capacity;
        this._totalQuads = Math.min(this._totalQuads, a);
        var e = this._capacity = 0 | a,
            f = this._totalQuads;
        if (null === this._quads) {
            this._quads = [];
            this._quadsArrayBuffer = new ArrayBuffer(b * e);
            this._quadsReader = new Uint8Array(this._quadsArrayBuffer);
            for (a = 0; a < e; a++) this._quads = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, a * b)
        } else {
            var g, h, k = this._quads;
            if (e > d) {
                g = [];
                h = new ArrayBuffer(b * e);
                for (a = 0; a < f; a++) g[a] = new cc.V3F_C4B_T2F_Quad(k[a].tl,
                    k[a].bl, k[a].tr, k[a].br, h, a * b);
                for (; a < e; a++) g[a] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, h, a * b)
            } else {
                f = Math.max(f, e);
                g = [];
                h = new ArrayBuffer(b * e);
                for (a = 0; a < f; a++) g[a] = new cc.V3F_C4B_T2F_Quad(k[a].tl, k[a].bl, k[a].tr, k[a].br, h, a * b)
            }
            this._quadsReader = new Uint8Array(h);
            this._quads = g;
            this._quadsArrayBuffer = h
        }
        null === this._indices ? this._indices = new Uint16Array(6 * e) : e > d ? (b = new Uint16Array(6 * e), b.set(this._indices, 0), this._indices = b) : this._indices = this._indices.subarray(0, 6 * e);
        this._setupIndices();
        this._mapBuffers();
        return this.dirty = !0
    },
    increaseTotalQuadsWith: function(a) {
        this._totalQuads += a
    },
    moveQuadsFromIndex: function(a, b, d) {
        if (void 0 === d) {
            if (d = b, b = this._totalQuads - a, cc.assert(d + (this._totalQuads - a) <= this._capacity, cc._LogInfos.TextureAtlas_moveQuadsFromIndex), 0 === b) return
        } else if (cc.assert(d + b <= this._totalQuads, cc._LogInfos.TextureAtlas_moveQuadsFromIndex_2), cc.assert(a < this._totalQuads, cc._LogInfos.TextureAtlas_moveQuadsFromIndex_3), a === d) return;
        var e = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
            f = a * e,
            g = b * e,
            h = this._quadsReader,
            k = h.subarray(f, f + g),
            m = d * e;
        d < a ? (b = d * e, h.set(h.subarray(b, b + (a - d) * e), b + g)) : (b = (a + b) * e, h.set(h.subarray(b, b + (d - a) * e), f));
        h.set(k, m);
        this.dirty = !0
    },
    fillWithEmptyQuadsFromIndex: function(a, b) {
        for (var d = b * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, e = new Uint8Array(this._quadsArrayBuffer, a * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, d), f = 0; f < d; f++) e[f] = 0
    },
    drawQuads: function() {
        this.drawNumberOfQuads(this._totalQuads, 0)
    },
    _releaseBuffer: function() {
        var a = cc._renderContext;
        this._buffersVBO && (this._buffersVBO[0] && a.deleteBuffer(this._buffersVBO[0]),
            this._buffersVBO[1] && a.deleteBuffer(this._buffersVBO[1]));
        this._quadsWebBuffer && a.deleteBuffer(this._quadsWebBuffer)
    }
});
_p = cc.TextureAtlas.prototype;
cc.defineGetterSetter(_p, "totalQuads", _p.getTotalQuads);
cc.defineGetterSetter(_p, "capacity", _p.getCapacity);
cc.defineGetterSetter(_p, "quads", _p.getQuads, _p.setQuads);
cc.TextureAtlas.create = function(a, b) {
    return new cc.TextureAtlas(a, b)
};
cc.TextureAtlas.createWithTexture = cc.TextureAtlas.create;
cc._renderType === cc._RENDER_TYPE_WEBGL && (cc.assert(cc.isFunction(cc._tmp.WebGLTextureAtlas), cc._LogInfos.MissingFile, "TexturesWebGL.js"), cc._tmp.WebGLTextureAtlas(), delete cc._tmp.WebGLTextureAtlas);
cc.assert(cc.isFunction(cc._tmp.PrototypeTextureAtlas), cc._LogInfos.MissingFile, "TexturesPropertyDefine.js");
cc._tmp.PrototypeTextureAtlas();
delete cc._tmp.PrototypeTextureAtlas;
cc.Scene = cc.Node.extend({
    _className: "Scene",
    ctor: function() {
        cc.Node.prototype.ctor.call(this);
        this._ignoreAnchorPointForPosition = !0;
        this.setAnchorPoint(0.5, 0.5);
        this.setContentSize(cc.director.getWinSize())
    }
});
cc.Scene.create = function() {
    return new cc.Scene
};
cc.LoaderScene = cc.Scene.extend({
    _interval: null,
    _label: null,
    _className: "LoaderScene",
    cb: null,
    target: null,
    init: function() {
        var a = this._bgLayer = new cc.LayerColor(cc.color(32, 32, 32, 255));
        this.addChild(a, 0);
        var b = new cc.Sprite(res.logo_png);
        b.setPosition(240, 480);
        this.addChild(b);
        b = this._label = new cc.LabelTTF("Loading... 0%", "Arial", 24);
        b.setPosition(cc.pAdd(cc.visibleRect.center, cc.p(0, 0)));
        b.setColor(cc.color(180, 180, 180));
        a.addChild(this._label, 10);
        b.y -= 70;
        return !0
    },
    _initStage: function(a, b) {
        var d = this._texture2d =
            new cc.Texture2D;
        d.initWithElement(a);
        d.handleLoadedTexture();
        d = this._logo = new cc.Sprite(d);
        d.setScale(cc.contentScaleFactor());
        d.x = b.x;
        d.y = b.y;
        this._bgLayer.addChild(d, 10)
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this);
        this.schedule(this._startLoading, 0.3)
    },
    onExit: function() {
        cc.Node.prototype.onExit.call(this);
        this._label.setString("Loading... 0%")
    },
    initWithResources: function(a, b, d) {
        cc.isString(a) && (a = [a]);
        this.resources = a || [];
        this.cb = b;
        this.target = d
    },
    _startLoading: function() {
        var a = this;
        a.unschedule(a._startLoading);
        cc.loader.load(a.resources, function(b, d, e) {
            b = Math.min(100 * (e / d) | 0, 100);
            a._label.setString("Loading... " + b + "%")
        }, function() {
            a.cb && a.cb.call(a.target)
        })
    }
});
cc.LoaderScene.preload = function(a, b, d) {
    var e = cc;
    e.loaderScene || (e.loaderScene = new cc.LoaderScene, e.loaderScene.init());
    e.loaderScene.initWithResources(a, b, d);
    cc.director.runScene(e.loaderScene);
    return e.loaderScene
};
cc.Layer = cc.Node.extend({
    _className: "Layer",
    ctor: function() {
        var a = cc.Node.prototype;
        a.ctor.call(this);
        this._ignoreAnchorPointForPosition = !0;
        a.setAnchorPoint.call(this, 0.5, 0.5);
        a.setContentSize.call(this, cc.winSize)
    },
    init: function() {
        this._ignoreAnchorPointForPosition = !0;
        this.setAnchorPoint(0.5, 0.5);
        this.setContentSize(cc.winSize);
        this._cascadeOpacityEnabled = this._cascadeColorEnabled = !1;
        return !0
    },
    bake: function() {
        this._renderCmd.bake()
    },
    unbake: function() {
        this._renderCmd.unbake()
    },
    isBaked: function() {
        return this._renderCmd._isBaked
    },
    addChild: function(a, b, d) {
        cc.Node.prototype.addChild.call(this, a, b, d);
        this._renderCmd._bakeForAddChild(a)
    },
    _createRenderCmd: function() {
        return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.Layer.CanvasRenderCmd(this) : new cc.Layer.WebGLRenderCmd(this)
    }
});
cc.Layer.create = function() {
    return new cc.Layer
};
cc.LayerColor = cc.Layer.extend({
    _blendFunc: null,
    _className: "LayerColor",
    getBlendFunc: function() {
        return this._blendFunc
    },
    changeWidthAndHeight: function(a, b) {
        this.width = a;
        this.height = b
    },
    changeWidth: function(a) {
        this.width = a
    },
    changeHeight: function(a) {
        this.height = a
    },
    setOpacityModifyRGB: function(a) {},
    isOpacityModifyRGB: function() {
        return !1
    },
    ctor: function(a, b, d) {
        cc.Layer.prototype.ctor.call(this);
        this._blendFunc = new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA);
        cc.LayerColor.prototype.init.call(this, a,
            b, d)
    },
    init: function(a, b, d) {
        cc._renderType !== cc._RENDER_TYPE_CANVAS && (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_COLOR));
        var e = cc.director.getWinSize();
        a = a || cc.color(0, 0, 0, 255);
        b = void 0 === b ? e.width : b;
        d = void 0 === d ? e.height : d;
        e = this._realColor;
        e.r = a.r;
        e.g = a.g;
        e.b = a.b;
        this._realOpacity = a.a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty | cc.Node._dirtyFlags.opacityDirty);
        cc.LayerColor.prototype.setContentSize.call(this, b, d);
        return !0
    },
    setBlendFunc: function(a, b) {
        var d =
            this._blendFunc;
        void 0 === b ? (d.src = a.src, d.dst = a.dst) : (d.src = a, d.dst = b);
        this._renderCmd.updateBlendFunc(d)
    },
    _setWidth: function(a) {
        cc.Node.prototype._setWidth.call(this, a);
        this._renderCmd._updateSquareVerticesWidth(a)
    },
    _setHeight: function(a) {
        cc.Node.prototype._setHeight.call(this, a);
        this._renderCmd._updateSquareVerticesHeight(a)
    },
    setContentSize: function(a, b) {
        cc.Layer.prototype.setContentSize.call(this, a, b);
        this._renderCmd._updateSquareVertices(a, b)
    },
    _createRenderCmd: function() {
        return cc._renderType ===
            cc._RENDER_TYPE_CANVAS ? new cc.LayerColor.CanvasRenderCmd(this) : new cc.LayerColor.WebGLRenderCmd(this)
    }
});
cc.LayerColor.create = function(a, b, d) {
    return new cc.LayerColor(a, b, d)
};
(function() {
    var a = cc.LayerColor.prototype;
    cc.defineGetterSetter(a, "width", a._getWidth, a._setWidth);
    cc.defineGetterSetter(a, "height", a._getHeight, a._setHeight)
})();
cc.LayerGradient = cc.LayerColor.extend({
    _endColor: null,
    _startOpacity: 255,
    _endOpacity: 255,
    _alongVector: null,
    _compressedInterpolation: !1,
    _className: "LayerGradient",
    _colorStops: [],
    ctor: function(a, b, d, e) {
        cc.LayerColor.prototype.ctor.call(this);
        this._endColor = cc.color(0, 0, 0, 255);
        this._alongVector = cc.p(0, -1);
        this._endOpacity = this._startOpacity = 255;
        e && e instanceof Array ? (this._colorStops = e, e.splice(0, 0, {
            p: 0,
            color: a || cc.color.BLACK
        }), e.push({
            p: 1,
            color: b || cc.color.BLACK
        })) : this._colorStops = [{
            p: 0,
            color: a || cc.color.BLACK
        }, {
            p: 1,
            color: b || cc.color.BLACK
        }];
        cc.LayerGradient.prototype.init.call(this, a, b, d, e)
    },
    init: function(a, b, d, e) {
        a = a || cc.color(0, 0, 0, 255);
        b = b || cc.color(0, 0, 0, 255);
        d = d || cc.p(0, -1);
        e = this._endColor;
        this._startOpacity = a.a;
        e.r = b.r;
        e.g = b.g;
        e.b = b.b;
        this._endOpacity = b.a;
        this._alongVector = d;
        this._compressedInterpolation = !0;
        cc.LayerColor.prototype.init.call(this, cc.color(a.r, a.g, a.b, 255));
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty | cc.Node._dirtyFlags.opacityDirty | cc.Node._dirtyFlags.gradientDirty);
        return !0
    },
    setContentSize: function(a, b) {
        cc.LayerColor.prototype.setContentSize.call(this, a, b);
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty)
    },
    _setWidth: function(a) {
        cc.LayerColor.prototype._setWidth.call(this, a);
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty)
    },
    _setHeight: function(a) {
        cc.LayerColor.prototype._setHeight.call(this, a);
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty)
    },
    getStartColor: function() {
        return cc.color(this._realColor)
    },
    setStartColor: function(a) {
        this.color =
            a;
        var b = this._colorStops;
        b && 0 < b.length && (b = b[0].color, b.r = a.r, b.g = a.g, b.b = a.b)
    },
    setEndColor: function(a) {
        var b = this._endColor;
        b.r = a.r;
        b.g = a.g;
        b.b = a.b;
        if ((b = this._colorStops) && 0 < b.length) b = b[b.length - 1].color, b.r = a.r, b.g = a.g, b.b = a.b;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty)
    },
    getEndColor: function() {
        return cc.color(this._endColor)
    },
    setStartOpacity: function(a) {
        this._startOpacity = a;
        var b = this._colorStops;
        b && 0 < b.length && (b[0].color.a = a);
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
    },
    getStartOpacity: function() {
        return this._startOpacity
    },
    setEndOpacity: function(a) {
        this._endOpacity = a;
        var b = this._colorStops;
        b && 0 < b.length && (b[b.length - 1].color.a = a);
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
    },
    getEndOpacity: function() {
        return this._endOpacity
    },
    setVector: function(a) {
        this._alongVector.x = a.x;
        this._alongVector.y = a.y;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty)
    },
    getVector: function() {
        return cc.p(this._alongVector.x, this._alongVector.y)
    },
    isCompressedInterpolation: function() {
        return this._compressedInterpolation
    },
    setCompressedInterpolation: function(a) {
        this._compressedInterpolation = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty)
    },
    getColorStops: function() {
        return this._colorStops
    },
    setColorStops: function(a) {
        this._colorStops = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty | cc.Node._dirtyFlags.opacityDirty | cc.Node._dirtyFlags.gradientDirty)
    },
    _createRenderCmd: function() {
        return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.LayerGradient.CanvasRenderCmd(this) : new cc.LayerGradient.WebGLRenderCmd(this)
    }
});
cc.LayerGradient.create = function(a, b, d, e) {
    return new cc.LayerGradient(a, b, d, e)
};
(function() {
    var a = cc.LayerGradient.prototype;
    cc.defineGetterSetter(a, "startColor", a.getStartColor, a.setStartColor);
    cc.defineGetterSetter(a, "endColor", a.getEndColor, a.setEndColor);
    cc.defineGetterSetter(a, "startOpacity", a.getStartOpacity, a.setStartOpacity);
    cc.defineGetterSetter(a, "endOpacity", a.getEndOpacity, a.setEndOpacity);
    cc.defineGetterSetter(a, "vector", a.getVector, a.setVector);
    cc.defineGetterSetter(a, "colorStops", a.getColorStops, a.setColorStops)
})();
cc.LayerMultiplex = cc.Layer.extend({
    _enabledLayer: 0,
    _layers: null,
    _className: "LayerMultiplex",
    ctor: function(a) {
        cc.Layer.prototype.ctor.call(this);
        a instanceof Array ? cc.LayerMultiplex.prototype.initWithLayers.call(this, a) : cc.LayerMultiplex.prototype.initWithLayers.call(this, Array.prototype.slice.call(arguments))
    },
    initWithLayers: function(a) {
        0 < a.length && null == a[a.length - 1] && cc.log(cc._LogInfos.LayerMultiplex_initWithLayers);
        this._layers = a;
        this._enabledLayer = 0;
        this.addChild(this._layers[this._enabledLayer]);
        return !0
    },
    switchTo: function(a) {
        a >= this._layers.length ? cc.log(cc._LogInfos.LayerMultiplex_switchTo) : (this.removeChild(this._layers[this._enabledLayer], !0), this._enabledLayer = a, this.addChild(this._layers[a]))
    },
    switchToAndReleaseMe: function(a) {
        a >= this._layers.length ? cc.log(cc._LogInfos.LayerMultiplex_switchToAndReleaseMe) : (this.removeChild(this._layers[this._enabledLayer], !0), this._layers[this._enabledLayer] = null, this._enabledLayer = a, this.addChild(this._layers[a]))
    },
    addLayer: function(a) {
        a ? this._layers.push(a) :
            cc.log(cc._LogInfos.LayerMultiplex_addLayer)
    }
});
cc.LayerMultiplex.create = function() {
    return new cc.LayerMultiplex(Array.prototype.slice.call(arguments))
};
(function() {
    cc.Layer.CanvasRenderCmd = function(a) {
        cc.Node.CanvasRenderCmd.call(this, a);
        this._isBaked = !1;
        this._bakeSprite = null;
        this._updateCache = 2
    };
    var a = cc.Layer.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    a.constructor = cc.Layer.CanvasRenderCmd;
    a._setCacheDirty = function(a) {
        a && 0 === this._updateCache && (this._updateCache = 2);
        !1 === this._cacheDirty && (this._cacheDirty = !0, (a = this._cachedParent) && a !== this && a._setNodeDirtyForCache && a._setNodeDirtyForCache())
    };
    a.transform = function(a,
        d) {
        var e = this._worldTransform,
            f = e.a,
            g = e.b,
            h = e.c,
            k = e.d;
        cc.Node.CanvasRenderCmd.prototype.transform.call(this, a, d);
        if ((e.a !== f || e.b !== g || e.c !== h || e.d !== k) && 0 === this._updateCache) this._updateCache = 2
    };
    a.bake = function() {
        if (!this._isBaked) {
            this._needDraw = !0;
            this._isBaked = this._cacheDirty = cc.renderer.childrenOrderDirty = !0;
            0 === this._updateCache && (this._updateCache = 2);
            for (var a = this._node._children, d = 0, e = a.length; d < e; d++) a[d]._renderCmd._setCachedParent(this);
            this._bakeSprite || (this._bakeSprite = new cc.BakeSprite,
                this._bakeSprite.setAnchorPoint(0, 0))
        }
    };
    a.unbake = function() {
        if (this._isBaked) {
            cc.renderer.childrenOrderDirty = !0;
            this._isBaked = this._needDraw = !1;
            this._cacheDirty = !0;
            0 === this._updateCache && (this._updateCache = 2);
            for (var a = this._node._children, d = 0, e = a.length; d < e; d++) a[d]._renderCmd._setCachedParent(null)
        }
    };
    a.isBaked = function() {
        return this._isBaked
    };
    a.rendering = function() {
        if (this._cacheDirty) {
            var a = this._node,
                d = a._children,
                e = this._bakeSprite;
            this.transform(this.getParentRenderCmd(), !0);
            var f = this._getBoundingBoxForBake();
            f.width = 0 | f.width + 0.5;
            f.height = 0 | f.height + 0.5;
            var g = e.getCacheContext(),
                h = g.getContext();
            e.setPosition(f.x, f.y);
            if (0 < this._updateCache) {
                e.resetCanvasSize(f.width, f.height);
                g.setOffset(0 - f.x, h.canvas.height - f.height + f.y);
                a.sortAllChildren();
                cc.renderer._turnToCacheMode(this.__instanceId);
                a = 0;
                for (f = d.length; a < f; a++) d[a].visit(this);
                cc.renderer._renderingToCacheCanvas(g, this.__instanceId);
                e.transform();
                this._updateCache--
            }
            this._cacheDirty = !1
        }
    };
    a.visit = function(a) {
        if (this._isBaked) {
            var d = this._node,
                e =
                d._children.length;
            d._visible && 0 !== e && (this._syncStatus(a), cc.renderer.pushRenderCommand(this), this._cacheDirty = !0, 0 === this._updateCache && (this._updateCache = 2), this._bakeSprite.visit(this), this._dirtyFlag = 0)
        } else cc.Node.CanvasRenderCmd.prototype.visit.call(this, a)
    };
    a._bakeForAddChild = function(a) {
        a._parent === this._node && this._isBaked && a._renderCmd._setCachedParent(this)
    };
    a._getBoundingBoxForBake = function() {
        var a = null,
            d = this._node;
        if (!d._children || 0 === d._children.length) return cc.rect(0, 0, 10, 10);
        for (var e =
            d.getNodeToWorldTransform(), d = d._children, f = 0, g = d.length; f < g; f++) {
            var h = d[f];
            h && h._visible && (a ? (h = h._getBoundingBoxToCurrentNode(e)) && (a = cc.rectUnion(a, h)) : a = h._getBoundingBoxToCurrentNode(e))
        }
        return a
    }
})();
(function() {
    cc.LayerColor.CanvasRenderCmd = function(a) {
        cc.Layer.CanvasRenderCmd.call(this, a);
        this._needDraw = !0;
        this._blendFuncStr = "source-over";
        this._bakeRenderCmd = new cc.CustomRenderCmd(this, this._bakeRendering)
    };
    var a = cc.LayerColor.CanvasRenderCmd.prototype = Object.create(cc.Layer.CanvasRenderCmd.prototype);
    a.constructor = cc.LayerColor.CanvasRenderCmd;
    a.unbake = function() {
        cc.Layer.CanvasRenderCmd.prototype.unbake.call(this);
        this._needDraw = !0
    };
    a.rendering = function(a, d, e) {
        a = a || cc._renderContext;
        var f =
            a.getContext(),
            g = this._node,
            h = this._displayedColor,
            k = this._displayedOpacity / 255,
            m = g._contentSize.width,
            g = g._contentSize.height;
        0 !== k && (a.setCompositeOperation(this._blendFuncStr), a.setGlobalAlpha(k), a.setFillStyle("rgba(" + (0 | h.r) + "," + (0 | h.g) + "," + (0 | h.b) + ", 1)"), a.setTransform(this._worldTransform, d, e), f.fillRect(0, 0, m * d, -g * e), cc.g_NumberOfDraws++)
    };
    a.updateBlendFunc = function(a) {
        this._blendFuncStr = cc.Node.CanvasRenderCmd._getCompositeOperationByBlendFunc(a)
    };
    a._updateSquareVertices = a._updateSquareVerticesWidth =
        a._updateSquareVerticesHeight = function() {};
    a._bakeRendering = function() {
        if (this._cacheDirty) {
            var a = this._node,
                d = this._bakeSprite,
                e = a._children,
                f = e.length;
            this.transform(this.getParentRenderCmd(), !0);
            var g = this._getBoundingBoxForBake();
            g.width = 0 | g.width + 0.5;
            g.height = 0 | g.height + 0.5;
            var h = d.getCacheContext(),
                k = h.getContext();
            d.setPosition(g.x, g.y);
            if (0 < this._updateCache) {
                k.fillStyle = h._currentFillStyle;
                d.resetCanvasSize(g.width, g.height);
                h.setOffset(0 - g.x, k.canvas.height - g.height + g.y);
                cc.renderer._turnToCacheMode(this.__instanceId);
                if (0 < f) {
                    a.sortAllChildren();
                    for (a = 0; a < f; a++)
                        if (g = e[a], 0 > g._localZOrder) g._renderCmd.visit(this);
                        else break;
                    for (cc.renderer.pushRenderCommand(this); a < f; a++) e[a]._renderCmd.visit(this)
                } else cc.renderer.pushRenderCommand(this);
                cc.renderer._renderingToCacheCanvas(h, this.__instanceId);
                d.transform();
                this._updateCache--
            }
            this._cacheDirty = !1
        }
    };
    a.visit = function(a) {
        this._isBaked ? this._node._visible && (this._syncStatus(a), cc.renderer.pushRenderCommand(this._bakeRenderCmd), this._bakeSprite._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty),
            this._bakeSprite.visit(this), this._dirtyFlag = 0) : cc.Node.CanvasRenderCmd.prototype.visit.call(this)
    };
    a._getBoundingBoxForBake = function() {
        var a = this._node,
            d = cc.rect(0, 0, a._contentSize.width, a._contentSize.height),
            e = a.getNodeToWorldTransform(),
            d = cc.rectApplyAffineTransform(d, a.getNodeToWorldTransform());
        if (!a._children || 0 === a._children.length) return d;
        for (var a = a._children, f = 0; f < a.length; f++) {
            var g = a[f];
            g && g._visible && (g = g._getBoundingBoxToCurrentNode(e), d = cc.rectUnion(d, g))
        }
        return d
    }
})();
(function() {
    cc.LayerGradient.RenderCmd = {
        updateStatus: function() {
            var a = cc.Node._dirtyFlags,
                b = this._dirtyFlag,
                d = b & a.colorDirty,
                e = b & a.opacityDirty;
            d && this._updateDisplayColor();
            e && this._updateDisplayOpacity();
            (d || e || b & a.gradientDirty) && this._updateColor();
            b & a.transformDirty && this.transform(this.getParentRenderCmd(), !0);
            this._dirtyFlag = 0
        }
    }
})();
(function() {
    cc.LayerGradient.CanvasRenderCmd = function(a) {
        cc.LayerColor.CanvasRenderCmd.call(this, a);
        this._needDraw = !0;
        this._startPoint = cc.p(0, 0);
        this._endPoint = cc.p(0, 0);
        this._endStopStr = this._startStopStr = null
    };
    var a = cc.LayerGradient.CanvasRenderCmd.prototype = Object.create(cc.LayerColor.CanvasRenderCmd.prototype);
    cc.inject(cc.LayerGradient.RenderCmd, a);
    a.constructor = cc.LayerGradient.CanvasRenderCmd;
    a.rendering = function(a, d, e) {
        a = a || cc._renderContext;
        var f = a.getContext(),
            g = this._node,
            h = this._displayedOpacity /
            255;
        if (0 !== h) {
            var k = g._contentSize.width,
                m = g._contentSize.height;
            a.setCompositeOperation(this._blendFuncStr);
            a.setGlobalAlpha(h);
            h = f.createLinearGradient(this._startPoint.x * d, this._startPoint.y * e, this._endPoint.x * d, this._endPoint.y * e);
            if (g._colorStops)
                for (var n = 0; n < g._colorStops.length; n++) h.addColorStop(g._colorStops[n].p, this._colorStopsStr[n]);
            else h.addColorStop(0, this._startStopStr), h.addColorStop(1, this._endStopStr);
            a.setFillStyle(h);
            a.setTransform(this._worldTransform, d, e);
            f.fillRect(0, 0, k *
                d, -m * e);
            cc.g_NumberOfDraws++
        }
    };
    a._syncStatus = function(a) {
        var d = cc.Node._dirtyFlags,
            e = this._dirtyFlag,
            f = a ? a._node : null;
        f && (f._cascadeColorEnabled && a._dirtyFlag & d.colorDirty) && (e |= d.colorDirty);
        f && (f._cascadeOpacityEnabled && a._dirtyFlag & d.opacityDirty) && (e |= d.opacityDirty);
        a && a._dirtyFlag & d.transformDirty && (e |= d.transformDirty);
        var f = e & d.colorDirty,
            g = e & d.opacityDirty;
        this._dirtyFlag = e;
        f && this._syncDisplayColor();
        g && this._syncDisplayOpacity();
        e & d.transformDirty && this.transform(a);
        (f || g || e & d.gradientDirty) &&
        this._updateColor()
    };
    a._updateColor = function() {
        var a = this._node,
            d = a._contentSize,
            e = 0.5 * d.width,
            d = 0.5 * d.height;
        this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.gradientDirty;
        var f = cc.pAngleSigned(cc.p(0, -1), a._alongVector),
            f = cc.pRotateByAngle(cc.p(0, -1), cc.p(0, 0), f),
            g = Math.min(Math.abs(1 / f.x), Math.abs(1 / f.y));
        this._startPoint.x = e * -f.x * g + e;
        this._startPoint.y = d * f.y * g - d;
        this._endPoint.x = e * f.x * g + e;
        this._endPoint.y = d * -f.y * g - d;
        e = this._displayedColor;
        d = a._endColor;
        f = a._startOpacity / 255;
        g = a._endOpacity /
            255;
        this._startStopStr = "rgba(" + Math.round(e.r) + "," + Math.round(e.g) + "," + Math.round(e.b) + "," + f.toFixed(4) + ")";
        this._endStopStr = "rgba(" + Math.round(d.r) + "," + Math.round(d.g) + "," + Math.round(d.b) + "," + g.toFixed(4) + ")";
        if (a._colorStops) {
            this._endOpacity = this._startOpacity = 0;
            this._colorStopsStr = [];
            for (e = 0; e < a._colorStops.length; e++) d = a._colorStops[e].color, f = null == d.a ? 1 : d.a / 255, this._colorStopsStr.push("rgba(" + Math.round(d.r) + "," + Math.round(d.g) + "," + Math.round(d.b) + "," + f.toFixed(4) + ")")
        }
    }
})();
(function() {
    cc.Layer.WebGLRenderCmd = function(a) {
        cc.Node.WebGLRenderCmd.call(this, a)
    };
    var a = cc.Layer.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    a.constructor = cc.Layer.WebGLRenderCmd;
    a.bake = function() {};
    a.unbake = function() {};
    a._bakeForAddChild = function() {}
})();
(function() {
    cc.LayerColor.WebGLRenderCmd = function(a) {
        cc.Layer.WebGLRenderCmd.call(this, a);
        this._needDraw = !0;
        this._squareVerticesAB = new ArrayBuffer(32);
        this._squareColorsAB = new ArrayBuffer(16);
        a = this._squareVerticesAB;
        var d = this._squareColorsAB,
            e = cc.Vertex2F.BYTES_PER_ELEMENT,
            f = cc.Color.BYTES_PER_ELEMENT;
        this._squareVertices = [new cc.Vertex2F(0, 0, a, 0), new cc.Vertex2F(0, 0, a, e), new cc.Vertex2F(0, 0, a, 2 * e), new cc.Vertex2F(0, 0, a, 3 * e)];
        this._squareColors = [cc.color(0, 0, 0, 255, d, 0), cc.color(0, 0, 0, 255, d, f), cc.color(0,
            0, 0, 255, d, 2 * f), cc.color(0, 0, 0, 255, d, 3 * f)];
        this._verticesFloat32Buffer = cc._renderContext.createBuffer();
        this._colorsUint8Buffer = cc._renderContext.createBuffer()
    };
    var a = cc.LayerColor.WebGLRenderCmd.prototype = Object.create(cc.Layer.WebGLRenderCmd.prototype);
    a.constructor = cc.LayerColor.WebGLRenderCmd;
    a.rendering = function(a) {
        a = a || cc._renderContext;
        var d = this._node;
        this._shaderProgram.use();
        this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix);
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION |
            cc.VERTEX_ATTRIB_FLAG_COLOR);
        cc.glBlendFunc(d._blendFunc.src, d._blendFunc.dst);
        a.bindBuffer(a.ARRAY_BUFFER, this._verticesFloat32Buffer);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
        a.bindBuffer(a.ARRAY_BUFFER, this._colorsUint8Buffer);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 0, 0);
        a.drawArrays(a.TRIANGLE_STRIP, 0, this._squareVertices.length)
    };
    a._updateSquareVertices = function(a, d) {
        var e = this._squareVertices;
        void 0 === d ? (e[1].x = a.width, e[2].y = a.height, e[3].x =
            a.width, e[3].y = a.height) : (e[1].x = a, e[2].y = d, e[3].x = a, e[3].y = d);
        this._bindLayerVerticesBufferData()
    };
    a._updateSquareVerticesWidth = function(a) {
        var d = this._squareVertices;
        d[1].x = a;
        d[3].x = a;
        this._bindLayerVerticesBufferData()
    };
    a._updateSquareVerticesHeight = function(a) {
        var d = this._squareVertices;
        d[2].y = a;
        d[3].y = a;
        this._bindLayerVerticesBufferData()
    };
    a._updateColor = function() {
        for (var a = this._displayedColor, d = this._displayedOpacity, e = this._squareColors, f = 0; 4 > f; f++) e[f].r = a.r, e[f].g = a.g, e[f].b = a.b, e[f].a =
            d;
        this._bindLayerColorsBufferData()
    };
    a._bindLayerVerticesBufferData = function() {
        var a = cc._renderContext;
        a.bindBuffer(a.ARRAY_BUFFER, this._verticesFloat32Buffer);
        a.bufferData(a.ARRAY_BUFFER, this._squareVerticesAB, a.STATIC_DRAW)
    };
    a._bindLayerColorsBufferData = function() {
        var a = cc._renderContext;
        a.bindBuffer(a.ARRAY_BUFFER, this._colorsUint8Buffer);
        a.bufferData(a.ARRAY_BUFFER, this._squareColorsAB, a.STATIC_DRAW)
    };
    a.updateBlendFunc = function(a) {}
})();
(function() {
    cc.LayerGradient.WebGLRenderCmd = function(a) {
        cc.LayerColor.WebGLRenderCmd.call(this, a);
        this._needDraw = !0;
        this._clipRect = new cc.Rect;
        this._clippingRectDirty = !1
    };
    var a = cc.LayerGradient.WebGLRenderCmd.prototype = Object.create(cc.LayerColor.WebGLRenderCmd.prototype);
    cc.inject(cc.LayerGradient.RenderCmd, a);
    a.constructor = cc.LayerGradient.WebGLRenderCmd;
    a._syncStatus = function(a) {
        var d = cc.Node._dirtyFlags,
            e = this._dirtyFlag,
            f = a ? a._node : null;
        f && (f._cascadeColorEnabled && a._dirtyFlag & d.colorDirty) &&
            (e |= d.colorDirty);
        f && (f._cascadeOpacityEnabled && a._dirtyFlag & d.opacityDirty) && (e |= d.opacityDirty);
        a && a._dirtyFlag & d.transformDirty && (e |= d.transformDirty);
        var f = e & d.colorDirty,
            g = e & d.opacityDirty;
        this._dirtyFlag = e;
        f && this._syncDisplayColor();
        g && this._syncDisplayOpacity();
        this.transform(a);
        (f || g || e & d.gradientDirty) && this._updateColor()
    };
    a._updateColor = function() {
        this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.gradientDirty;
        var a = this._node,
            d = a._colorStops;
        if (d && !(2 > d.length)) {
            this._clippingRectDirty = !0;
            var e = d.length,
                f = 2 * e,
                g, h = a._contentSize;
            this._squareVerticesAB = new ArrayBuffer(8 * f);
            this._squareColorsAB = new ArrayBuffer(4 * f);
            var k = this._squareVertices,
                m = this._squareColors;
            k.length = 0;
            m.length = 0;
            var n = this._squareVerticesAB,
                p = this._squareColorsAB,
                r = cc.Vertex2F.BYTES_PER_ELEMENT,
                s = cc.Color.BYTES_PER_ELEMENT;
            for (g = 0; g < f; g++) k.push(new cc.Vertex2F(0, 0, n, r * g)), m.push(cc.color(0, 0, 0, 255, p, s * g));
            p = Math.PI + cc.pAngleSigned(cc.p(0, -1), a._alongVector);
            a = cc.p(h.width / 2, h.height / 2);
            g = Math.round(cc.radiansToDegrees(p));
            f = cc.affineTransformMake(1, 0, 0, 1, a.x, a.y);
            f = cc.affineTransformRotate(f, p);
            90 > g ? (r = cc.p(-a.x, a.y), g = cc.p(a.x, a.y)) : 180 > g ? (r = cc.p(a.x, a.y), g = cc.p(a.x, -a.y)) : 270 > g ? (r = cc.p(a.x, -a.y), g = cc.p(-a.x, -a.y)) : (r = cc.p(-a.x, -a.y), g = cc.p(-a.x, a.y));
            n = Math.sin(p);
            p = Math.cos(p);
            r = Math.abs((r.x * p - r.y * n) / a.x);
            g = Math.abs((g.x * n + g.y * p) / a.y);
            f = cc.affineTransformScale(f, r, g);
            for (g = 0; g < e; g++) n = d[g].p * h.height, p = cc.pointApplyAffineTransform(-a.x, n - a.y, f), k[2 * g].x = p.x, k[2 * g].y = p.y, n = cc.pointApplyAffineTransform(h.width - a.x,
                n - a.y, f), k[2 * g + 1].x = n.x, k[2 * g + 1].y = n.y;
            h = this._displayedOpacity / 255;
            for (g = 0; g < e; g++) k = d[g].color, a = m[2 * g], f = m[2 * g + 1], a.r = k.r, a.g = k.g, a.b = k.b, a.a = k.a * h, f.r = k.r, f.g = k.g, f.b = k.b, f.a = k.a * h;
            this._bindLayerVerticesBufferData();
            this._bindLayerColorsBufferData()
        }
    };
    a.rendering = function(a) {
        a = a || cc._renderContext;
        var d = this._node,
            e = this._getClippingRect();
        a.enable(a.SCISSOR_TEST);
        cc.view.setScissorInPoints(e.x, e.y, e.width, e.height);
        this._shaderProgram.use();
        this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix);
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR);
        cc.glBlendFunc(d._blendFunc.src, d._blendFunc.dst);
        a.bindBuffer(a.ARRAY_BUFFER, this._verticesFloat32Buffer);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
        a.bindBuffer(a.ARRAY_BUFFER, this._colorsUint8Buffer);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 0, 0);
        a.drawArrays(a.TRIANGLE_STRIP, 0, this._squareVertices.length);
        a.disable(a.SCISSOR_TEST)
    };
    a._getClippingRect = function() {
        if (this._clippingRectDirty) {
            var a =
                this._node,
                d = cc.rect(0, 0, a._contentSize.width, a._contentSize.height),
                a = a.getNodeToWorldTransform();
            this._clipRect = cc._rectApplyAffineTransformIn(d, a)
        }
        return this._clipRect
    }
})();
cc._tmp.PrototypeSprite = function() {
    var a = cc.Sprite.prototype;
    cc.defineGetterSetter(a, "opacityModifyRGB", a.isOpacityModifyRGB, a.setOpacityModifyRGB);
    cc.defineGetterSetter(a, "opacity", a.getOpacity, a.setOpacity);
    cc.defineGetterSetter(a, "color", a.getColor, a.setColor);
    cc.defineGetterSetter(a, "flippedX", a.isFlippedX, a.setFlippedX);
    cc.defineGetterSetter(a, "flippedY", a.isFlippedY, a.setFlippedY);
    cc.defineGetterSetter(a, "offsetX", a._getOffsetX);
    cc.defineGetterSetter(a, "offsetY", a._getOffsetY);
    cc.defineGetterSetter(a,
        "texture", a.getTexture, a.setTexture);
    cc.defineGetterSetter(a, "textureRectRotated", a.isTextureRectRotated);
    cc.defineGetterSetter(a, "batchNode", a.getBatchNode, a.setBatchNode);
    cc.defineGetterSetter(a, "quad", a.getQuad)
};
cc.Sprite = cc.Node.extend({
    dirty: !1,
    atlasIndex: 0,
    textureAtlas: null,
    _batchNode: null,
    _recursiveDirty: null,
    _hasChildren: null,
    _shouldBeHidden: !1,
    _transformToBatch: null,
    _blendFunc: null,
    _texture: null,
    _rect: null,
    _rectRotated: !1,
    _offsetPosition: null,
    _unflippedOffsetPositionFromCenter: null,
    _opacityModifyRGB: !1,
    _flippedX: !1,
    _flippedY: !1,
    _textureLoaded: !1,
    _className: "Sprite",
    ctor: function(a, b, d) {
        cc.Node.prototype.ctor.call(this);
        this._shouldBeHidden = !1;
        this._offsetPosition = cc.p(0, 0);
        this._unflippedOffsetPositionFromCenter =
            cc.p(0, 0);
        this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        };
        this._rect = cc.rect(0, 0, 0, 0);
        this._softInit(a, b, d)
    },
    textureLoaded: function() {
        return this._textureLoaded
    },
    addLoadedEventListener: function(a, b) {
        this.addEventListener("load", a, b)
    },
    isDirty: function() {
        return this.dirty
    },
    setDirty: function(a) {
        this.dirty = a
    },
    isTextureRectRotated: function() {
        return this._rectRotated
    },
    getAtlasIndex: function() {
        return this.atlasIndex
    },
    setAtlasIndex: function(a) {
        this.atlasIndex = a
    },
    getTextureRect: function() {
        return cc.rect(this._rect)
    },
    getTextureAtlas: function() {
        return this.textureAtlas
    },
    setTextureAtlas: function(a) {
        this.textureAtlas = a
    },
    getOffsetPosition: function() {
        return cc.p(this._offsetPosition)
    },
    _getOffsetX: function() {
        return this._offsetPosition.x
    },
    _getOffsetY: function() {
        return this._offsetPosition.y
    },
    getBlendFunc: function() {
        return this._blendFunc
    },
    initWithSpriteFrame: function(a) {
        cc.assert(a, cc._LogInfos.Sprite_initWithSpriteFrame);
        a.textureLoaded() || (this._textureLoaded = !1, a.addEventListener("load", this._renderCmd._spriteFrameLoadedCallback,
            this));
        var b = cc._renderType === cc._RENDER_TYPE_CANVAS ? !1 : a._rotated,
            b = this.initWithTexture(a.getTexture(), a.getRect(), b);
        this.setSpriteFrame(a);
        return b
    },
    initWithSpriteFrameName: function(a) {
        cc.assert(a, cc._LogInfos.Sprite_initWithSpriteFrameName);
        var b = cc.spriteFrameCache.getSpriteFrame(a);
        cc.assert(b, a + cc._LogInfos.Sprite_initWithSpriteFrameName1);
        return this.initWithSpriteFrame(b)
    },
    useBatchNode: function(a) {
        this.textureAtlas = a.getTextureAtlas();
        this._batchNode = a
    },
    setVertexRect: function(a) {
        var b = this._rect;
        b.x = a.x;
        b.y = a.y;
        b.width = a.width;
        b.height = a.height
    },
    sortAllChildren: function() {
        if (this._reorderChildDirty) {
            var a = this._children,
                b = a.length,
                d, e, f;
            for (d = 1; d < b; d++) {
                f = a[d];
                for (e = d - 1; 0 <= e;) {
                    if (f._localZOrder < a[e]._localZOrder) a[e + 1] = a[e];
                    else if (f._localZOrder === a[e]._localZOrder && f.arrivalOrder < a[e].arrivalOrder) a[e + 1] = a[e];
                    else break;
                    e--
                }
                a[e + 1] = f
            }
            this._batchNode && this._arrayMakeObjectsPerformSelector(a, cc.Node._stateCallbackType.sortAllChildren);
            this._reorderChildDirty = !1
        }
    },
    reorderChild: function(a, b) {
        cc.assert(a,
            cc._LogInfos.Sprite_reorderChild_2); - 1 === this._children.indexOf(a) ? cc.log(cc._LogInfos.Sprite_reorderChild) : b !== a.zIndex && (this._batchNode && !this._reorderChildDirty && (this._setReorderChildDirtyRecursively(), this._batchNode.reorderBatch(!0)), cc.Node.prototype.reorderChild.call(this, a, b))
    },
    removeChild: function(a, b) {
        this._batchNode && this._batchNode.removeSpriteFromAtlas(a);
        cc.Node.prototype.removeChild.call(this, a, b)
    },
    setVisible: function(a) {
        cc.Node.prototype.setVisible.call(this, a);
        this._renderCmd.setDirtyRecursively(!0)
    },
    removeAllChildren: function(a) {
        var b = this._children,
            d = this._batchNode;
        if (d && null != b)
            for (var e = 0, f = b.length; e < f; e++) d.removeSpriteFromAtlas(b[e]);
        cc.Node.prototype.removeAllChildren.call(this, a);
        this._hasChildren = !1
    },
    ignoreAnchorPointForPosition: function(a) {
        this._batchNode ? cc.log(cc._LogInfos.Sprite_ignoreAnchorPointForPosition) : cc.Node.prototype.ignoreAnchorPointForPosition.call(this, a)
    },
    setFlippedX: function(a) {
        this._flippedX !== a && (this._flippedX = a, this.setTextureRect(this._rect, this._rectRotated,
            this._contentSize), this.setNodeDirty(!0))
    },
    setFlippedY: function(a) {
        this._flippedY !== a && (this._flippedY = a, this.setTextureRect(this._rect, this._rectRotated, this._contentSize), this.setNodeDirty(!0))
    },
    isFlippedX: function() {
        return this._flippedX
    },
    isFlippedY: function() {
        return this._flippedY
    },
    setOpacityModifyRGB: function(a) {
        this._opacityModifyRGB !== a && (this._opacityModifyRGB = a, this._renderCmd._setColorDirty())
    },
    isOpacityModifyRGB: function() {
        return this._opacityModifyRGB
    },
    setDisplayFrameWithAnimationName: function(a,
        b) {
        cc.assert(a, cc._LogInfos.Sprite_setDisplayFrameWithAnimationName_3);
        var d = cc.animationCache.getAnimation(a);
        d ? (d = d.getFrames()[b]) ? this.setSpriteFrame(d.getSpriteFrame()) : cc.log(cc._LogInfos.Sprite_setDisplayFrameWithAnimationName_2) : cc.log(cc._LogInfos.Sprite_setDisplayFrameWithAnimationName)
    },
    getBatchNode: function() {
        return this._batchNode
    },
    _setReorderChildDirtyRecursively: function() {
        if (!this._reorderChildDirty) {
            this._reorderChildDirty = !0;
            for (var a = this._parent; a && a !== this._batchNode;) a._setReorderChildDirtyRecursively(),
                a = a.parent
        }
    },
    getTexture: function() {
        return this._texture
    },
    _softInit: function(a, b, d) {
        if (void 0 === a) cc.Sprite.prototype.init.call(this);
        else if (cc.isString(a)) "#" === a[0] ? (b = a.substr(1, a.length - 1), (b = cc.spriteFrameCache.getSpriteFrame(b)) ? this.initWithSpriteFrame(b) : cc.log("%s does not exist", a)) : cc.Sprite.prototype.init.call(this, a, b);
        else if ("object" === typeof a)
            if (a instanceof cc.Texture2D) this.initWithTexture(a, b, d);
            else if (a instanceof cc.SpriteFrame) this.initWithSpriteFrame(a);
        else if (a instanceof HTMLImageElement || a instanceof HTMLCanvasElement) b = new cc.Texture2D, b.initWithElement(a), b.handleLoadedTexture(), this.initWithTexture(b)
    },
    getQuad: function() {
        return this._renderCmd.getQuad()
    },
    setBlendFunc: function(a, b) {
        var d = this._blendFunc;
        void 0 === b ? (d.src = a.src, d.dst = a.dst) : (d.src = a, d.dst = b);
        this._renderCmd.updateBlendFunc(d)
    },
    init: function() {
        if (0 < arguments.length) return this.initWithFile(arguments[0], arguments[1]);
        cc.Node.prototype.init.call(this);
        this.dirty = this._recursiveDirty = !1;
        this._blendFunc.src =
            cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;
        this.texture = null;
        this._flippedX = this._flippedY = !1;
        this.anchorY = this.anchorX = 0.5;
        this._offsetPosition.x = 0;
        this._offsetPosition.y = 0;
        this._hasChildren = !1;
        this._renderCmd._init();
        this.setTextureRect(cc.rect(0, 0, 0, 0), !1, cc.size(0, 0));
        return !0
    },
    initWithFile: function(a, b) {
        cc.assert(a, cc._LogInfos.Sprite_initWithFile);
        var d = cc.textureCache.getTextureForKey(a);
        if (d) {
            if (!b) {
                var e = d.getContentSize();
                b = cc.rect(0, 0, e.width, e.height)
            }
            return this.initWithTexture(d,
                b)
        }
        d = cc.textureCache.addImage(a);
        return this.initWithTexture(d, b || cc.rect(0, 0, d._contentSize.width, d._contentSize.height))
    },
    initWithTexture: function(a, b, d, e) {
        cc.assert(0 !== arguments.length, cc._LogInfos.CCSpriteBatchNode_initWithTexture);
        d = d || !1;
        a = this._renderCmd._handleTextureForRotatedTexture(a, b, d, e);
        if (!cc.Node.prototype.init.call(this)) return !1;
        this._batchNode = null;
        this.dirty = this._recursiveDirty = !1;
        this._opacityModifyRGB = !0;
        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;
        this._flippedX =
            this._flippedY = !1;
        this.setAnchorPoint(0.5, 0.5);
        this._offsetPosition.x = 0;
        this._offsetPosition.y = 0;
        this._hasChildren = !1;
        this._renderCmd._init();
        var f = a.isLoaded();
        this._textureLoaded = f;
        if (!f) return this._rectRotated = d, b && (this._rect.x = b.x, this._rect.y = b.y, this._rect.width = b.width, this._rect.height = b.height), this.texture && this.texture.removeEventListener("load", this), a.addEventListener("load", this._renderCmd._textureLoadedCallback, this), this.texture = a, !0;
        b || (b = cc.rect(0, 0, a.width, a.height));
        this._renderCmd._checkTextureBoundary(a,
            b, d);
        this.setTexture(a);
        this.setTextureRect(b, d);
        this.setBatchNode(null);
        return !0
    },
    setTextureRect: function(a, b, d, e) {
        this._rectRotated = b || !1;
        this.setContentSize(d || a);
        this.setVertexRect(a);
        this._renderCmd._setTextureCoords(a, e);
        a = this._unflippedOffsetPositionFromCenter.x;
        b = this._unflippedOffsetPositionFromCenter.y;
        this._flippedX && (a = -a);
        this._flippedY && (b = -b);
        d = this._rect;
        this._offsetPosition.x = a + (this._contentSize.width - d.width) / 2;
        this._offsetPosition.y = b + (this._contentSize.height - d.height) / 2;
        this._batchNode ?
            this.dirty = !0 : this._renderCmd._resetForBatchNode()
    },
    updateTransform: function() {
        this._renderCmd.updateTransform()
    },
    addChild: function(a, b, d) {
        cc.assert(a, cc._LogInfos.CCSpriteBatchNode_addChild_2);
        null == b && (b = a._localZOrder);
        null == d && (d = a.tag);
        this._renderCmd._setBatchNodeForAddChild(a) && (cc.Node.prototype.addChild.call(this, a, b, d), this._hasChildren = !0)
    },
    setSpriteFrame: function(a) {
        var b = this;
        cc.isString(a) && (a = cc.spriteFrameCache.getSpriteFrame(a), cc.assert(a, cc._LogInfos.Sprite_setSpriteFrame));
        this.setNodeDirty(!0);
        var d = a.getOffset();
        b._unflippedOffsetPositionFromCenter.x = d.x;
        b._unflippedOffsetPositionFromCenter.y = d.y;
        d = a.getTexture();
        a.textureLoaded() ? (d !== b._texture && (b.texture = d), b.setTextureRect(a.getRect(), a.isRotated(), a.getOriginalSize())) : (b._textureLoaded = !1, a.addEventListener("load", function(a) {
            b._textureLoaded = !0;
            var d = a.getTexture();
            d !== b._texture && (b.texture = d);
            b.setTextureRect(a.getRect(), a.isRotated(), a.getOriginalSize());
            b.dispatchEvent("load");
            b.setColor(b.color)
        }, b));
        this._renderCmd._updateForSetSpriteFrame(d)
    },
    setDisplayFrame: function(a) {
        cc.log(cc._LogInfos.Sprite_setDisplayFrame);
        this.setSpriteFrame(a)
    },
    isFrameDisplayed: function(a) {
        return this._renderCmd.isFrameDisplayed(a)
    },
    displayFrame: function() {
        return this.getSpriteFrame()
    },
    getSpriteFrame: function() {
        return new cc.SpriteFrame(this._texture, cc.rectPointsToPixels(this._rect), this._rectRotated, cc.pointPointsToPixels(this._unflippedOffsetPositionFromCenter), cc.sizePointsToPixels(this._contentSize))
    },
    setBatchNode: function(a) {
        (this._batchNode = a) ? (this._transformToBatch =
            cc.affineTransformIdentity(), this.textureAtlas = this._batchNode.getTextureAtlas()) : (this.atlasIndex = cc.Sprite.INDEX_NOT_INITIALIZED, this.textureAtlas = null, this.dirty = this._recursiveDirty = !1, this._renderCmd._resetForBatchNode())
    },
    setTexture: function(a) {
        if (!a) return this._renderCmd._setTexture(null);
        var b = this._texture;
        cc.isString(a) ? (a = cc.textureCache.addImage(a), a._textureLoaded ? (this._renderCmd._setTexture(a), this._changeRectWithTexture(a, b), this.setColor(this._realColor), this._textureLoaded = !0) :
            a.addEventListener("load", function() {
                this._renderCmd._setTexture(a);
                this._changeRectWithTexture(a, b);
                this.setColor(this._realColor);
                this._textureLoaded = !0
            }, this)) : (cc.assert(a instanceof cc.Texture2D, cc._LogInfos.Sprite_setTexture_2), this._changeRectWithTexture(a, b), this._renderCmd._setTexture(a))
    },
    _changeRectWithTexture: function(a, b) {
        var d = cc.rect(0, 0, a._contentSize.width, a._contentSize.height),
            e = b ? b._contentSize : cc.size(),
            f = this._contentSize,
            g = d.width,
            h = d.height,
            k = e.width,
            e = e.height,
            m = f.width,
            f =
            f.height;
        if (d && (g || h)) {
            var n = this._rect;
            if (!(0 !== m && 0 !== f) || !(m !== k && f !== e) || !(k === g && e === h) || !(0 !== n.height || 0 !== n.width)) d.x = d.x || 0, d.y = d.y || 0, d.width = d.width || 0, d.height = d.height || 0, this.setTextureRect(d)
        }
    },
    _createRenderCmd: function() {
        return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.Sprite.CanvasRenderCmd(this) : new cc.Sprite.WebGLRenderCmd(this)
    }
});
cc.Sprite.create = function(a, b, d) {
    return new cc.Sprite(a, b, d)
};
cc.Sprite.createWithTexture = cc.Sprite.create;
cc.Sprite.createWithSpriteFrameName = cc.Sprite.create;
cc.Sprite.createWithSpriteFrame = cc.Sprite.create;
cc.Sprite.INDEX_NOT_INITIALIZED = -1;
cc.EventHelper.prototype.apply(cc.Sprite.prototype);
cc.assert(cc.isFunction(cc._tmp.PrototypeSprite), cc._LogInfos.MissingFile, "SpritesPropertyDefine.js");
cc._tmp.PrototypeSprite();
delete cc._tmp.PrototypeSprite;
(function() {
    cc.Sprite.CanvasRenderCmd = function(a) {
        cc.Node.CanvasRenderCmd.call(this, a);
        this._needDraw = !0;
        this._textureCoord = {
            renderX: 0,
            renderY: 0,
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            validRect: !1
        };
        this._blendFuncStr = "source-over";
        this._colorized = !1;
        this._originalTexture = null
    };
    var a = cc.Sprite.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    a.constructor = cc.Sprite.CanvasRenderCmd;
    a._init = function() {};
    a.setDirtyRecursively = function(a) {};
    a._resetForBatchNode = function() {};
    a._setTexture = function(a) {
        var d =
            this._node;
        d._texture !== a && (a ? (a.getHtmlElementObj() instanceof HTMLImageElement && (this._originalTexture = a), d._textureLoaded = a._textureLoaded) : d._textureLoaded = !1, d._texture = a)
    };
    a._setColorDirty = function() {
        this.setDirtyFlag(cc.Node._dirtyFlags.colorDirty | cc.Node._dirtyFlags.opacityDirty)
    };
    a.isFrameDisplayed = function(a) {
        var d = this._node;
        return a.getTexture() !== d._texture ? !1 : cc.rectEqualToRect(a.getRect(), d._rect)
    };
    a.updateBlendFunc = function(a) {
        this._blendFuncStr = cc.Node.CanvasRenderCmd._getCompositeOperationByBlendFunc(a)
    };
    a._setBatchNodeForAddChild = function(a) {
        return !0
    };
    a._handleTextureForRotatedTexture = function(a, d, e, f) {
        e && a.isLoaded() && (a = a.getHtmlElementObj(), a = cc.Sprite.CanvasRenderCmd._cutRotateImageToCanvas(a, d, f), f = new cc.Texture2D, f.initWithElement(a), f.handleLoadedTexture(), a = f, d.x = d.y = 0, this._node._rect = cc.rect(0, 0, d.width, d.height));
        return a
    };
    a._checkTextureBoundary = function(a, d, e) {
        a && a.url && (e = d.y + d.height, d.x + d.width > a.width && cc.error(cc._LogInfos.RectWidth, a.url), e > a.height && cc.error(cc._LogInfos.RectHeight,
            a.url));
        this._node._originalTexture = a
    };
    a.rendering = function(a, d, e) {
        var f = this._node,
            g = this._textureCoord,
            h = this._displayedOpacity / 255;
        if (!(f._texture && (0 === g.width || 0 === g.height || !f._texture._textureLoaded) || 0 === h)) {
            a = a || cc._renderContext;
            var k = a.getContext(),
                m = f._offsetPosition.x,
                n = f._rect.height,
                p = f._rect.width,
                r = -f._offsetPosition.y - n;
            a.setTransform(this._worldTransform, d, e);
            a.setCompositeOperation(this._blendFuncStr);
            a.setGlobalAlpha(h);
            (f._flippedX || f._flippedY) && a.save();
            f._flippedX && (m = -m -
                p, k.scale(-1, 1));
            f._flippedY && (r = f._offsetPosition.y, k.scale(1, -1));
            f._texture ? (h = f._texture._htmlElementObj, "" !== f._texture._pattern ? (a.setFillStyle(k.createPattern(h, f._texture._pattern)), k.fillRect(m * d, r * e, p * d, n * e)) : this._colorized ? k.drawImage(h, 0, 0, g.width, g.height, m * d, r * e, p * d, n * e) : k.drawImage(h, g.renderX, g.renderY, g.width, g.height, m * d, r * e, p * d, n * e)) : (h = f._contentSize, g.validRect && (g = this._displayedColor, a.setFillStyle("rgba(" + g.r + "," + g.g + "," + g.b + ",1)"), k.fillRect(m * d, r * e, h.width * d, h.height * e)));
            (f._flippedX || f._flippedY) && a.restore();
            cc.g_NumberOfDraws++
        }
    };
    a._updateColor = cc.sys._supportCanvasNewBlendModes ? function() {
        var a = this._node,
            d = this._displayedColor;
        if (255 === d.r && 255 === d.g && 255 === d.b) this._setOriginalTexture();
        else {
            var e, f = a._texture,
                g = this._textureCoord;
            if (f && (g.validRect && this._originalTexture) && (e = f.getHtmlElementObj())) this._colorized = !0, e instanceof HTMLCanvasElement && !this._rectRotated && !this._newTextureWhenChangeColor && this._originalTexture._htmlElementObj !== e ? cc.Sprite.CanvasRenderCmd._generateTintImageWithMultiply(this._originalTexture._htmlElementObj,
                d, g, e) : (e = cc.Sprite.CanvasRenderCmd._generateTintImageWithMultiply(this._originalTexture._htmlElementObj, d, g), f = new cc.Texture2D, f.initWithElement(e), f.handleLoadedTexture(), a.setTexture(f))
        }
    } : function() {
        var a = this._node,
            d = this._displayedColor;
        if (255 === d.r && 255 === d.g && 255 === d.b) this._setOriginalTexture();
        else {
            var e, f = a._texture,
                g = this._textureCoord;
            if (f && (g.validRect && this._originalTexture) && (e = f.getHtmlElementObj()))
                if (f = cc.textureCache.getTextureColors(this._originalTexture.getHtmlElementObj())) this._colorized = !0, e instanceof HTMLCanvasElement && !this._rectRotated && !this._newTextureWhenChangeColor ? cc.Sprite.CanvasRenderCmd._generateTintImage(e, f, d, g, e) : (e = cc.Sprite.CanvasRenderCmd._generateTintImage(e, f, d, g), f = new cc.Texture2D, f.initWithElement(e), f.handleLoadedTexture(), a.texture = f)
        }
    };
    a._setOriginalTexture = function() {
        if (this._colorized) {
            this._colorized = !1;
            var a = this._node,
                d = cc.rect(a._rect),
                e = cc.size(a._contentSize),
                f = a._rectRotated;
            a.setTexture(this._originalTexture);
            a.setTextureRect(d, f, e)
        }
    };
    a.getQuad =
        function() {
            return null
        };
    a._updateForSetSpriteFrame = function(a, d) {
        this._originalTexture = a;
        this._colorized = !1;
        this._textureCoord.renderX = this._textureCoord.x;
        this._textureCoord.renderY = this._textureCoord.y;
        if (d = d || a._textureLoaded) {
            var e = this._node.getColor();
            (255 !== e.r || 255 !== e.g || 255 !== e.b) && this._updateColor()
        }
    };
    a.updateTransform = function() {
        var a = this._node;
        if (a.dirty) {
            var d = a._parent;
            !a._visible || d && d !== a._batchNode && d._shouldBeHidden ? a._shouldBeHidden = !0 : (a._shouldBeHidden = !1, a._transformToBatch = !d || d === a._batchNode ? this.getNodeToParentTransform() : cc.affineTransformConcat(this.getNodeToParentTransform(), d._transformToBatch));
            a._recursiveDirty = !1;
            a.dirty = !1
        }
        a._hasChildren && a._arrayMakeObjectsPerformSelector(a._children, cc.Node._stateCallbackType.updateTransform)
    };
    a._updateDisplayColor = function(a) {
        cc.Node.CanvasRenderCmd.prototype._updateDisplayColor.call(this, a)
    };
    a._spriteFrameLoadedCallback = function(a) {
        this.setTextureRect(a.getRect(), a.isRotated(), a.getOriginalSize());
        this._renderCmd._updateColor();
        this.dispatchEvent("load")
    };
    a._textureLoadedCallback = function(a) {
        if (!this._textureLoaded) {
            this._textureLoaded = !0;
            var d = this._rect,
                e = this._renderCmd;
            d ? cc._rectEqualToZero(d) && (d.width = a.width, d.height = a.height) : d = cc.rect(0, 0, a.width, a.height);
            this.texture = e._originalTexture = a;
            this.setTextureRect(d, this._rectRotated);
            a = e._displayedColor;
            (255 !== a.r || 255 !== a.g || 255 !== a.b) && e._updateColor();
            this.setBatchNode(this._batchNode);
            this.dispatchEvent("load")
        }
    };
    a._setTextureCoords = function(a, d) {
        void 0 === d && (d = !0);
        var e = this._textureCoord,
            f = d ? cc.contentScaleFactor() : 1;
        e.renderX = e.x = 0 | a.x * f;
        e.renderY = e.y = 0 | a.y * f;
        e.width = 0 | a.width * f;
        e.height = 0 | a.height * f;
        e.validRect = !(0 === e.width || 0 === e.height || 0 > e.x || 0 > e.y)
    };
    cc.Sprite.CanvasRenderCmd._generateTintImageWithMultiply = function(a, d, e, f) {
        f = f || cc.newElement("canvas");
        e = e || cc.rect(0, 0, a.width, a.height);
        var g = f.getContext("2d");
        f.width !== e.width || f.height !== e.height ? (f.width = e.width, f.height = e.height) : g.globalCompositeOperation = "source-over";
        g.fillStyle = "rgb(" + (0 |
            d.r) + "," + (0 | d.g) + "," + (0 | d.b) + ")";
        g.fillRect(0, 0, e.width, e.height);
        g.globalCompositeOperation = "multiply";
        g.drawImage(a, e.x, e.y, e.width, e.height, 0, 0, e.width, e.height);
        g.globalCompositeOperation = "destination-atop";
        g.drawImage(a, e.x, e.y, e.width, e.height, 0, 0, e.width, e.height);
        return f
    };
    cc.Sprite.CanvasRenderCmd._generateTintImage = function(a, d, e, f, g) {
        f || (f = cc.rect(0, 0, a.width, a.height));
        a = e.r / 255;
        var h = e.g / 255;
        e = e.b / 255;
        var k = Math.min(f.width, d[0].width),
            m = Math.min(f.height, d[0].height),
            n;
        g ? (n = g.getContext("2d"),
            n.clearRect(0, 0, k, m)) : (g = cc.newElement("canvas"), g.width = k, g.height = m, n = g.getContext("2d"));
        n.save();
        n.globalCompositeOperation = "lighter";
        var p = n.globalAlpha;
        0 < a && (n.globalAlpha = a * p, n.drawImage(d[0], f.x, f.y, k, m, 0, 0, k, m));
        0 < h && (n.globalAlpha = h * p, n.drawImage(d[1], f.x, f.y, k, m, 0, 0, k, m));
        0 < e && (n.globalAlpha = e * p, n.drawImage(d[2], f.x, f.y, k, m, 0, 0, k, m));
        1 > a + h + e && (n.globalAlpha = p, n.drawImage(d[3], f.x, f.y, k, m, 0, 0, k, m));
        n.restore();
        return g
    };
    cc.Sprite.CanvasRenderCmd._generateTextureCacheForColor = function(a) {
        function d() {
            var d =
                cc.Sprite.CanvasRenderCmd._generateTextureCacheForColor,
                f = a.width,
                k = a.height;
            e[0].width = f;
            e[0].height = k;
            e[1].width = f;
            e[1].height = k;
            e[2].width = f;
            e[2].height = k;
            e[3].width = f;
            e[3].height = k;
            d.canvas.width = f;
            d.canvas.height = k;
            var m = d.canvas.getContext("2d");
            m.drawImage(a, 0, 0);
            d.tempCanvas.width = f;
            d.tempCanvas.height = k;
            for (var m = m.getImageData(0, 0, f, k).data, n = 0; 4 > n; n++) {
                var p = e[n].getContext("2d");
                p.getImageData(0, 0, f, k).data;
                d.tempCtx.drawImage(a, 0, 0);
                for (var r = d.tempCtx.getImageData(0, 0, f, k), s = r.data,
                    t = 0; t < m.length; t += 4) s[t] = 0 === n ? m[t] : 0, s[t + 1] = 1 === n ? m[t + 1] : 0, s[t + 2] = 2 === n ? m[t + 2] : 0, s[t + 3] = m[t + 3];
                p.putImageData(r, 0, 0)
            }
            a.onload = null
        }
        if (a.channelCache) return a.channelCache;
        var e = [cc.newElement("canvas"), cc.newElement("canvas"), cc.newElement("canvas"), cc.newElement("canvas")];
        try {
            d()
        } catch (f) {
            a.onload = d
        }
        return a.channelCache = e
    };
    cc.Sprite.CanvasRenderCmd._generateTextureCacheForColor.canvas = cc.newElement("canvas");
    cc.Sprite.CanvasRenderCmd._generateTextureCacheForColor.tempCanvas = cc.newElement("canvas");
    cc.Sprite.CanvasRenderCmd._generateTextureCacheForColor.tempCtx = cc.Sprite.CanvasRenderCmd._generateTextureCacheForColor.tempCanvas.getContext("2d");
    cc.Sprite.CanvasRenderCmd._cutRotateImageToCanvas = function(a, d, e) {
        if (!a) return null;
        if (!d) return a;
        e = null == e ? !0 : e;
        var f = cc.newElement("canvas");
        f.width = d.width;
        f.height = d.height;
        var g = f.getContext("2d");
        g.translate(f.width / 2, f.height / 2);
        e ? g.rotate(-1.5707963267948966) : g.rotate(1.5707963267948966);
        g.drawImage(a, d.x, d.y, d.height, d.width, -d.height / 2, -d.width /
            2, d.height, d.width);
        return f
    }
})();
(function() {
    cc.Sprite.WebGLRenderCmd = function(a) {
        cc.Node.WebGLRenderCmd.call(this, a);
        this._needDraw = !0;
        this._quad = new cc.V3F_C4B_T2F_Quad;
        this._quadWebBuffer = cc._renderContext.createBuffer();
        this._quadDirty = !0;
        this._recursiveDirty = this._dirty = !1
    };
    var a = cc.Sprite.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    a.constructor = cc.Sprite.WebGLRenderCmd;
    a.updateBlendFunc = function(a) {};
    a.setDirtyFlag = function(a) {
        cc.Node.WebGLRenderCmd.prototype.setDirtyFlag.call(this, a);
        this._dirty = !0
    };
    a.setDirtyRecursively = function(a) {
        this._dirty = this._recursiveDirty = a;
        for (var d = this._node._children, e, f = d ? d.length : 0, g = 0; g < f; g++) e = d[g], e instanceof cc.Sprite && e._renderCmd.setDirtyRecursively(a)
    };
    a._setBatchNodeForAddChild = function(a) {
        var d = this._node;
        if (d._batchNode) {
            if (!(a instanceof cc.Sprite)) return cc.log(cc._LogInfos.Sprite_addChild), !1;
            a.texture._webTextureObj !== d.textureAtlas.texture._webTextureObj && cc.log(cc._LogInfos.Sprite_addChild_2);
            d._batchNode.appendChild(a);
            d._reorderChildDirty ||
                d._setReorderChildDirtyRecursively()
        }
        return !0
    };
    a._handleTextureForRotatedTexture = function(a) {
        return a
    };
    a.isFrameDisplayed = function(a) {
        var d = this._node;
        return cc.rectEqualToRect(a.getRect(), d._rect) && a.getTexture().getName() === d._texture.getName() && cc.pointEqualToPoint(a.getOffset(), d._unflippedOffsetPositionFromCenter)
    };
    a._init = function() {
        var a = {
                r: 255,
                g: 255,
                b: 255,
                a: 255
            },
            d = this._quad;
        d.bl.colors = a;
        d.br.colors = a;
        d.tl.colors = a;
        d.tr.colors = a;
        this._quadDirty = !0
    };
    a._resetForBatchNode = function() {
        var a = this._node,
            d = a._offsetPosition.x,
            e = a._offsetPosition.y,
            f = d + a._rect.width,
            a = e + a._rect.height,
            g = this._quad;
        g.bl.vertices = {
            x: d,
            y: e,
            z: 0
        };
        g.br.vertices = {
            x: f,
            y: e,
            z: 0
        };
        g.tl.vertices = {
            x: d,
            y: a,
            z: 0
        };
        g.tr.vertices = {
            x: f,
            y: a,
            z: 0
        };
        this._quadDirty = !0
    };
    a.getQuad = function() {
        return this._quad
    };
    a._updateForSetSpriteFrame = function() {};
    a._spriteFrameLoadedCallback = function(a) {
        this.setTextureRect(a.getRect(), a.isRotated(), a.getOriginalSize());
        this.dispatchEvent("load")
    };
    a._textureLoadedCallback = function(a) {
        var d = this._renderCmd;
        if (!this._textureLoaded) {
            this._textureLoaded = !0;
            var e = this._rect;
            e ? cc._rectEqualToZero(e) && (e.width = a.width, e.height = a.height) : e = cc.rect(0, 0, a.width, a.height);
            this.texture = a;
            this.setTextureRect(e, this._rectRotated);
            this.setBatchNode(this._batchNode);
            d._quadDirty = !0;
            this.dispatchEvent("load")
        }
    };
    a._setTextureCoords = function(a, d) {
        void 0 === d && (d = !0);
        d && (a = cc.rectPointsToPixels(a));
        var e = this._node,
            f = e._batchNode ? e.textureAtlas.texture : e._texture;
        if (f) {
            var g = f.pixelsWidth,
                h = f.pixelsHeight,
                k, m, n = this._quad;
            e._rectRotated ? (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (f = (2 * a.x + 1) / (2 * g), g = f + (2 * a.height - 2) / (2 * g), k = (2 * a.y + 1) / (2 * h), h = k + (2 * a.width - 2) / (2 * h)) : (f = a.x / g, g = (a.x + a.height) / g, k = a.y / h, h = (a.y + a.width) / h), e._flippedX && (m = k, k = h, h = m), e._flippedY && (m = f, f = g, g = m), n.bl.texCoords.u = f, n.bl.texCoords.v = k, n.br.texCoords.u = f, n.br.texCoords.v = h, n.tl.texCoords.u = g, n.tl.texCoords.v = k, n.tr.texCoords.u = g, n.tr.texCoords.v = h) : (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (f = (2 * a.x + 1) / (2 * g), g = f + (2 * a.width - 2) / (2 * g), k = (2 * a.y + 1) / (2 * h), h =
                k + (2 * a.height - 2) / (2 * h)) : (f = a.x / g, g = (a.x + a.width) / g, k = a.y / h, h = (a.y + a.height) / h), e._flippedX && (m = f, f = g, g = m), e._flippedY && (m = k, k = h, h = m), n.bl.texCoords.u = f, n.bl.texCoords.v = h, n.br.texCoords.u = g, n.br.texCoords.v = h, n.tl.texCoords.u = f, n.tl.texCoords.v = k, n.tr.texCoords.u = g, n.tr.texCoords.v = k);
            this._quadDirty = !0
        }
    };
    a.transform = function(a, d) {
        cc.Node.WebGLRenderCmd.prototype.transform.call(this, a, d);
        this._dirty = !0
    };
    a._setColorDirty = function() {};
    a._updateColor = function() {
        var a = this._displayedColor,
            d = this._displayedOpacity,
            e = this._node,
            a = {
                r: a.r,
                g: a.g,
                b: a.b,
                a: d
            };
        e._opacityModifyRGB && (a.r *= d / 255, a.g *= d / 255, a.b *= d / 255);
        d = this._quad;
        d.bl.colors = a;
        d.br.colors = a;
        d.tl.colors = a;
        d.tr.colors = a;
        e._batchNode && (e.atlasIndex !== cc.Sprite.INDEX_NOT_INITIALIZED ? e.textureAtlas.updateQuad(d, e.atlasIndex) : this._dirty = !0);
        this._quadDirty = !0
    };
    a._updateBlendFunc = function() {
        if (this._batchNode) cc.log(cc._LogInfos.Sprite__updateBlendFunc);
        else {
            var a = this._node;
            !a._texture || !a._texture.hasPremultipliedAlpha() ? (a._blendFunc.src = cc.SRC_ALPHA, a._blendFunc.dst =
                cc.ONE_MINUS_SRC_ALPHA, a.opacityModifyRGB = !1) : (a._blendFunc.src = cc.BLEND_SRC, a._blendFunc.dst = cc.BLEND_DST, a.opacityModifyRGB = !0)
        }
    };
    a._setTexture = function(a) {
        var d = this._node;
        if (d._batchNode) {
            if (d._batchNode.texture !== a) {
                cc.log(cc._LogInfos.Sprite_setTexture);
                return
            }
        } else d._texture !== a && (d._textureLoaded = a ? a._textureLoaded : !1, d._texture = a, this._updateBlendFunc());
        this._shaderProgram = a ? cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR) : cc.shaderCache.programForKey(cc.SHADER_POSITION_COLOR)
    };
    a.updateTransform = function() {
        var a = this._node;
        if (this._dirty) {
            var d = this._quad,
                e = a._parent;
            if (!a._visible || e && e !== a._batchNode && e._shouldBeHidden) d.br.vertices = d.tl.vertices = d.tr.vertices = d.bl.vertices = {
                x: 0,
                y: 0,
                z: 0
            }, a._shouldBeHidden = !0;
            else {
                a._shouldBeHidden = !1;
                0 !== this._dirtyFlag && (this.updateStatus(), this._dirtyFlag = 0);
                a._transformToBatch = !e || e === a._batchNode ? this.getNodeToParentTransform() : cc.affineTransformConcat(this.getNodeToParentTransform(), e._transformToBatch);
                var f = a._transformToBatch,
                    g = a._rect,
                    e = a._offsetPosition.x,
                    h = a._offsetPosition.y,
                    k = e + g.width,
                    m = h + g.height,
                    n = f.tx,
                    p = f.ty,
                    r = f.a,
                    s = f.b,
                    t = f.d,
                    u = -f.c,
                    f = e * r - h * u + n,
                    g = e * s + h * t + p,
                    v = k * r - h * u + n,
                    h = k * s + h * t + p,
                    w = k * r - m * u + n,
                    k = k * s + m * t + p,
                    n = e * r - m * u + n,
                    e = e * s + m * t + p,
                    m = a._vertexZ;
                cc.SPRITEBATCHNODE_RENDER_SUBPIXEL || (f |= 0, g |= 0, v |= 0, h |= 0, w |= 0, k |= 0, n |= 0, e |= 0);
                d.bl.vertices = {
                    x: f,
                    y: g,
                    z: m
                };
                d.br.vertices = {
                    x: v,
                    y: h,
                    z: m
                };
                d.tl.vertices = {
                    x: n,
                    y: e,
                    z: m
                };
                d.tr.vertices = {
                    x: w,
                    y: k,
                    z: m
                }
            }
            a.textureAtlas.updateQuad(d, a.atlasIndex);
            this._dirty = a._recursiveDirty = !1
        }
        a._hasChildren &&
            a._arrayMakeObjectsPerformSelector(a._children, cc.Node._stateCallbackType.updateTransform)
    };
    a._checkTextureBoundary = function(a, d, e) {
        a && a.url && (e ? (e = d.x + d.height, d = d.y + d.width) : (e = d.x + d.width, d = d.y + d.height), e > a.width && cc.error(cc._LogInfos.RectWidth, a.url), d > a.height && cc.error(cc._LogInfos.RectHeight, a.url))
    };
    a.rendering = function(a) {
        var d = this._node,
            e = d._texture;
        if (!(e && !e._textureLoaded || 0 === this._displayedOpacity))
            if (a = a || cc._renderContext, e ? e._textureLoaded && (this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix),
                    cc.glBlendFunc(d._blendFunc.src, d._blendFunc.dst), cc.glBindTexture2DN(0, e), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), a.bindBuffer(a.ARRAY_BUFFER, this._quadWebBuffer), this._quadDirty && (a.bufferData(a.ARRAY_BUFFER, this._quad.arrayBuffer, a.DYNAMIC_DRAW), this._quadDirty = !1), a.vertexAttribPointer(0, 3, a.FLOAT, !1, 24, 0), a.vertexAttribPointer(1, 4, a.UNSIGNED_BYTE, !0, 24, 12), a.vertexAttribPointer(2, 2, a.FLOAT, !1, 24, 16), a.drawArrays(a.TRIANGLE_STRIP, 0, 4)) : (this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix),
                    cc.glBlendFunc(d._blendFunc.src, d._blendFunc.dst), cc.glBindTexture2D(null), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR), a.bindBuffer(a.ARRAY_BUFFER, this._quadWebBuffer), this._quadDirty && (a.bufferData(a.ARRAY_BUFFER, this._quad.arrayBuffer, a.STATIC_DRAW), this._quadDirty = !1), a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, a.FLOAT, !1, 24, 0), a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 24, 12), a.drawArrays(a.TRIANGLE_STRIP, 0, 4)), cc.g_NumberOfDraws++,
                0 !== cc.SPRITE_DEBUG_DRAW || d._showNode) cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW), cc.current_stack.stack.push(cc.current_stack.top), cc.current_stack.top = this._stackMatrix, 1 === cc.SPRITE_DEBUG_DRAW || d._showNode ? (d = this._quad, d = [cc.p(d.tl.vertices.x, d.tl.vertices.y), cc.p(d.bl.vertices.x, d.bl.vertices.y), cc.p(d.br.vertices.x, d.br.vertices.y), cc.p(d.tr.vertices.x, d.tr.vertices.y)], cc._drawingUtil.drawPoly(d, 4, !0)) : 2 === cc.SPRITE_DEBUG_DRAW && (e = d.getTextureRect(), d = d.getOffsetPosition(), d = [cc.p(d.x, d.y), cc.p(d.x +
                e.width, d.y), cc.p(d.x + e.width, d.y + e.height), cc.p(d.x, d.y + e.height)], cc._drawingUtil.drawPoly(d, 4, !0)), cc.current_stack.top = cc.current_stack.stack.pop()
    }
})();
cc.SpriteBatchNode = cc.Node.extend({
    _blendFunc: null,
    _descendants: null,
    _className: "SpriteBatchNode",
    ctor: function(a, b) {
        cc.Node.prototype.ctor.call(this);
        this._descendants = [];
        this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
        var d;
        b = b || cc.SpriteBatchNode.DEFAULT_CAPACITY;
        cc.isString(a) ? (d = cc.textureCache.getTextureForKey(a)) || (d = cc.textureCache.addImage(a)) : a instanceof cc.Texture2D && (d = a);
        d && this.initWithTexture(d, b)
    },
    addSpriteWithoutQuad: function(a, b, d) {
        cc.assert(a, cc._LogInfos.SpriteBatchNode_addSpriteWithoutQuad_2);
        if (!(a instanceof cc.Sprite)) return cc.log(cc._LogInfos.SpriteBatchNode_addSpriteWithoutQuad), null;
        a.atlasIndex = b;
        var e = 0,
            f, g = this._descendants;
        if (g && 0 < g.length) {
            e = 0;
            for (f = g.length; e < f; e++) {
                var h = g[e];
                if (h && h.atlasIndex >= b) break
            }
        }
        g.splice(e, 0, a);
        cc.Node.prototype.addChild.call(this, a, b, d);
        this.reorderBatch(!1);
        return this
    },
    getTextureAtlas: function() {
        return this._renderCmd.getTextureAtlas()
    },
    setTextureAtlas: function(a) {
        this._renderCmd.getTextureAtlas(a)
    },
    getDescendants: function() {
        return this._descendants
    },
    initWithFile: function(a, b) {
        var d = cc.textureCache.getTextureForKey(a);
        d || (d = cc.textureCache.addImage(a));
        return this.initWithTexture(d, b)
    },
    _setNodeDirtyForCache: function() {
        this._renderCmd && this._renderCmd._setNodeDirtyForCache && this._renderCmd._setNodeDirtyForCache()
    },
    init: function(a, b) {
        var d = cc.textureCache.getTextureForKey(a);
        d || (d = cc.textureCache.addImage(a));
        return this.initWithTexture(d, b)
    },
    increaseAtlasCapacity: function() {
        this._renderCmd.increaseAtlasCapacity()
    },
    removeChildAtIndex: function(a,
        b) {
        this.removeChild(this._children[a], b)
    },
    rebuildIndexInOrder: function(a, b) {
        var d = a.children;
        if (d && 0 < d.length)
            for (var e = 0; e < d.length; e++) {
                var f = d[e];
                f && 0 > f.zIndex && (b = this.rebuildIndexInOrder(f, b))
            }!a === this && (a.atlasIndex = b, b++);
        if (d && 0 < d.length)
            for (e = 0; e < d.length; e++)(f = d[e]) && 0 <= f.zIndex && (b = this.rebuildIndexInOrder(f, b));
        return b
    },
    highestAtlasIndexInChild: function(a) {
        var b = a.children;
        return !b || 0 === b.length ? a.atlasIndex : this.highestAtlasIndexInChild(b[b.length - 1])
    },
    lowestAtlasIndexInChild: function(a) {
        var b =
            a.children;
        return !b || 0 === b.length ? a.atlasIndex : this.lowestAtlasIndexInChild(b[b.length - 1])
    },
    atlasIndexForChild: function(a, b) {
        var d = a.parent,
            e = d.children,
            f = e.indexOf(a),
            g = null;
        0 < f && f < cc.UINT_MAX && (g = e[f - 1]);
        return d === this ? 0 === f ? 0 : this.highestAtlasIndexInChild(g) + 1 : 0 === f ? 0 > b ? d.atlasIndex : d.atlasIndex + 1 : 0 > g.zIndex && 0 > b || 0 <= g.zIndex && 0 <= b ? this.highestAtlasIndexInChild(g) + 1 : d.atlasIndex + 1
    },
    reorderBatch: function(a) {
        this._reorderChildDirty = a
    },
    setBlendFunc: function(a, b) {
        this._blendFunc = void 0 === b ? a : {
            src: a,
            dst: b
        }
    },
    getBlendFunc: function() {
        return new cc.BlendFunc(this._blendFunc.src, this._blendFunc.dst)
    },
    reorderChild: function(a, b) {
        cc.assert(a, cc._LogInfos.SpriteBatchNode_reorderChild_2); - 1 === this._children.indexOf(a) ? cc.log(cc._LogInfos.SpriteBatchNode_reorderChild) : b !== a.zIndex && cc.Node.prototype.reorderChild.call(this, a, b)
    },
    removeChild: function(a, b) {
        null != a && (-1 === this._children.indexOf(a) ? cc.log(cc._LogInfos.SpriteBatchNode_removeChild) : (this.removeSpriteFromAtlas(a), cc.Node.prototype.removeChild.call(this,
            a, b)))
    },
    updateQuadFromSprite: function(a, b) {
        cc.assert(a, cc._LogInfos.CCSpriteBatchNode_updateQuadFromSprite_2);
        a instanceof cc.Sprite ? (this._renderCmd.checkAtlasCapacity(), a.batchNode = this, a.atlasIndex = b, a.dirty = !0, a.updateTransform()) : cc.log(cc._LogInfos.CCSpriteBatchNode_updateQuadFromSprite)
    },
    insertQuadFromSprite: function(a, b) {
        cc.assert(a, cc._LogInfos.CCSpriteBatchNode_insertQuadFromSprite_2);
        a instanceof cc.Sprite ? (this._renderCmd.insertQuad(a, b), a.batchNode = this, a.atlasIndex = b, a.dirty = !0, a.updateTransform(),
            this._renderCmd.cutting(a, b)) : cc.log(cc._LogInfos.CCSpriteBatchNode_insertQuadFromSprite)
    },
    initWithTexture: function(a, b) {
        this._children.length = 0;
        this._descendants.length = 0;
        b = b || cc.SpriteBatchNode.DEFAULT_CAPACITY;
        this._renderCmd.initWithTexture(a, b);
        return !0
    },
    insertChild: function(a, b) {
        a.batchNode = this;
        a.atlasIndex = b;
        a.dirty = !0;
        this._renderCmd.insertQuad(a, b);
        this._descendants.splice(b, 0, a);
        var d = b + 1,
            e = this._descendants;
        if (e && 0 < e.length)
            for (; d < e.length; d++) e[d].atlasIndex++;
        var e = a.children,
            f, g;
        if (e) {
            d =
                0;
            for (g = e.length || 0; d < g; d++)
                if (f = e[d]) {
                    var h = this.atlasIndexForChild(f, f.zIndex);
                    this.insertChild(f, h)
                }
        }
    },
    appendChild: function(a) {
        this._reorderChildDirty = !0;
        a.batchNode = this;
        a.dirty = !0;
        this._descendants.push(a);
        var b = this._descendants.length - 1;
        a.atlasIndex = b;
        this._renderCmd.insertQuad(a, b);
        a = a.children;
        for (var b = 0, d = a.length || 0; b < d; b++) this.appendChild(a[b])
    },
    removeSpriteFromAtlas: function(a) {
        this._renderCmd.removeQuadAtIndex(a.atlasIndex);
        a.batchNode = null;
        var b = this._descendants,
            d = b.indexOf(a);
        if (-1 !==
            d) {
            b.splice(d, 1);
            for (var e = b.length; d < e; ++d) b[d].atlasIndex--
        }
        if (a = a.children) {
            b = 0;
            for (d = a.length || 0; b < d; b++) a[b] && this.removeSpriteFromAtlas(a[b])
        }
    },
    getTexture: function() {
        return this._renderCmd.getTexture()
    },
    setTexture: function(a) {
        this._renderCmd.setTexture(a)
    },
    addChild: function(a, b, d) {
        cc.assert(null != a, cc._LogInfos.CCSpriteBatchNode_addChild_3);
        this._renderCmd.isValidChild(a) && (b = null == b ? a.zIndex : b, d = null == d ? a.tag : d, cc.Node.prototype.addChild.call(this, a, b, d), this.appendChild(a))
    },
    removeAllChildren: function(a) {
        var b =
            this._descendants;
        if (b && 0 < b.length)
            for (var d = 0, e = b.length; d < e; d++) b[d] && (b[d].batchNode = null);
        cc.Node.prototype.removeAllChildren.call(this, a);
        this._descendants.length = 0;
        this._renderCmd.removeAllQuads()
    },
    sortAllChildren: function() {
        if (this._reorderChildDirty) {
            var a = this._children,
                b, d = 0,
                e = a.length,
                f;
            for (b = 1; b < e; b++) {
                var g = a[b],
                    d = b - 1;
                for (f = a[d]; 0 <= d && (g._localZOrder < f._localZOrder || g._localZOrder === f._localZOrder && g.arrivalOrder < f.arrivalOrder);) a[d + 1] = f, d -= 1, f = a[d];
                a[d + 1] = g
            }
            0 < a.length && (this._arrayMakeObjectsPerformSelector(a,
                cc.Node._stateCallbackType.sortAllChildren), this._renderCmd.updateChildrenAtlasIndex(a));
            this._reorderChildDirty = !1
        }
    },
    _createRenderCmd: function() {
        return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.SpriteBatchNode.CanvasRenderCmd(this) : new cc.SpriteBatchNode.WebGLRenderCmd(this)
    }
});
_p = cc.SpriteBatchNode.prototype;
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.defineGetterSetter(_p, "textureAtlas", _p.getTextureAtlas, _p.setTextureAtlas);
cc.defineGetterSetter(_p, "descendants", _p.getDescendants);
cc.SpriteBatchNode.DEFAULT_CAPACITY = 29;
cc.SpriteBatchNode.create = function(a, b) {
    return new cc.SpriteBatchNode(a, b)
};
cc.SpriteBatchNode.createWithTexture = cc.SpriteBatchNode.create;
(function() {
    cc.SpriteBatchNode.CanvasRenderCmd = function(a) {
        cc.Node.CanvasRenderCmd.call(this, a);
        this._originalTexture = this._texture = null
    };
    var a = cc.SpriteBatchNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    a.constructor = cc.SpriteBatchNode.CanvasRenderCmd;
    a.checkAtlasCapacity = function() {};
    a.isValidChild = function(a) {
        return !(a instanceof cc.Sprite) ? (cc.log(cc._LogInfos.Sprite_addChild_4), !1) : !0
    };
    a.initWithTexture = function(a, d) {
        this._texture = this._originalTexture = a
    };
    a.insertQuad =
        function(a, d) {};
    a.increaseAtlasCapacity = function() {};
    a.removeQuadAtIndex = function() {};
    a.removeAllQuads = function() {};
    a.getTexture = function() {
        return this._texture
    };
    a.setTexture = function(a) {
        this._texture = a;
        for (var d = this._node._children, e = 0; e < d.length; e++) d[e].setTexture(a)
    };
    a.updateChildrenAtlasIndex = function(a) {
        for (var d = this._node._descendants.length = 0, e = a.length; d < e; d++) this._updateAtlasIndex(a[d])
    };
    a._updateAtlasIndex = function(a) {
        var d = this._node._descendants,
            e = a.children,
            f, g = e.length;
        for (f = 0; f <
            g; f++)
            if (0 > e[f]._localZOrder) d.push(e[f]);
            else break;
        for (d.push(a); f < g; f++) d.push(e[f])
    };
    a.getTextureAtlas = function() {};
    a.setTextureAtlas = function(a) {};
    a.cutting = function(a, d) {
        this._node._children.splice(d, 0, a)
    }
})();
(function() {
    cc.SpriteBatchNode.WebGLRenderCmd = function(a) {
        cc.Node.WebGLRenderCmd.call(this, a);
        this._needDraw = !0;
        this._textureAtlas = null
    };
    var a = cc.SpriteBatchNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    a.constructor = cc.SpriteBatchNode.WebGLRenderCmd;
    a.isValidChild = function(a) {
        return !(a instanceof cc.Sprite) ? (cc.log(cc._LogInfos.Sprite_addChild_4), !1) : a.texture != this.getTexture() ? (cc.log(cc._LogInfos.Sprite_addChild_5), !1) : !0
    };
    a.rendering = function() {
        var a = this._node;
        0 !== this._textureAtlas.totalQuads && (this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix), a._arrayMakeObjectsPerformSelector(a._children, cc.Node._stateCallbackType.updateTransform), cc.glBlendFunc(a._blendFunc.src, a._blendFunc.dst), this._textureAtlas.drawQuads())
    };
    a.visit = function(a) {
        var d = this._node;
        if (d._visible) {
            d._parent && d._parent._renderCmd && (this._curLevel = d._parent._renderCmd._curLevel + 1);
            var e = cc.current_stack;
            e.stack.push(e.top);
            this._dirtyFlag &
                cc.Node._dirtyFlags.transformDirty || this.transform(a);
            this.updateStatus(a);
            e.top = this._stackMatrix;
            d.sortAllChildren();
            cc.renderer.pushRenderCommand(this);
            this._dirtyFlag = 0;
            e.top = e.stack.pop()
        }
    };
    a.checkAtlasCapacity = function(a) {
        for (var d = this._textureAtlas; a >= d.capacity || d.capacity === d.totalQuads;) this.increaseAtlasCapacity()
    };
    a.increaseAtlasCapacity = function() {
        var a = this._textureAtlas.capacity,
            d = Math.floor(4 * (a + 1) / 3);
        cc.log(cc._LogInfos.SpriteBatchNode_increaseAtlasCapacity, a, d);
        this._textureAtlas.resizeCapacity(d) ||
            cc.log(cc._LogInfos.SpriteBatchNode_increaseAtlasCapacity_2)
    };
    a.initWithTexture = function(a, d) {
        this._textureAtlas = new cc.TextureAtlas;
        this._textureAtlas.initWithTexture(a, d);
        this._updateBlendFunc();
        this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)
    };
    a.insertQuad = function(a, d) {
        var e = this._textureAtlas;
        e.totalQuads >= e.capacity && this.increaseAtlasCapacity();
        e.insertQuad(a.quad, d)
    };
    a.removeQuadAtIndex = function(a) {
        this._textureAtlas.removeQuadAtIndex(a)
    };
    a.getTexture = function() {
        return this._textureAtlas.texture
    };
    a.setTexture = function(a) {
        this._textureAtlas.setTexture(a);
        a && this._updateBlendFunc()
    };
    a.removeAllQuads = function() {
        this._textureAtlas.removeAllQuads()
    };
    a._swap = function(a, d) {
        var e = this._node._descendants,
            f = this._textureAtlas,
            g = f.quads,
            h = e[a],
            k = cc.V3F_C4B_T2F_QuadCopy(g[a]);
        e[d].atlasIndex = a;
        e[a] = e[d];
        f.updateQuad(g[d], a);
        e[d] = h;
        f.updateQuad(k, d)
    };
    a._updateAtlasIndex = function(a, d) {
        var e = 0,
            f = a.children;
        f && (e = f.length);
        var g = 0;
        if (0 === e) g = a.atlasIndex, a.atlasIndex = d, a.arrivalOrder = 0, g !== d && this._swap(g,
            d), d++;
        else {
            g = !0;
            0 <= f[0].zIndex && (g = a.atlasIndex, a.atlasIndex = d, a.arrivalOrder = 0, g !== d && this._swap(g, d), d++, g = !1);
            for (e = 0; e < f.length; e++) {
                var h = f[e];
                g && 0 <= h.zIndex && (g = a.atlasIndex, a.atlasIndex = d, a.arrivalOrder = 0, g !== d && this._swap(g, d), d++, g = !1);
                d = this._updateAtlasIndex(h, d)
            }
            g && (g = a.atlasIndex, a.atlasIndex = d, a.arrivalOrder = 0, g !== d && this._swap(g, d), d++)
        }
        return d
    };
    a.updateChildrenAtlasIndex = function(a) {
        for (var d = 0, e = 0; e < a.length; e++) d = this._updateAtlasIndex(a[e], d)
    };
    a._updateBlendFunc = function() {
        if (!this._textureAtlas.texture.hasPremultipliedAlpha()) {
            var a =
                this._node._blendFunc;
            a.src = cc.SRC_ALPHA;
            a.dst = cc.ONE_MINUS_SRC_ALPHA
        }
    };
    a.getTextureAtlas = function() {
        return this._textureAtlas
    };
    a.setTextureAtlas = function(a) {
        a !== this._textureAtlas && (this._textureAtlas = a)
    };
    a.cutting = function() {}
})();
cc.BakeSprite = cc.Sprite.extend({
    _cacheCanvas: null,
    _cacheContext: null,
    ctor: function() {
        cc.Sprite.prototype.ctor.call(this);
        var a = document.createElement("canvas");
        a.width = a.height = 10;
        this._cacheCanvas = a;
        this._cacheContext = new cc.CanvasContextWrapper(a.getContext("2d"));
        var b = new cc.Texture2D;
        b.initWithElement(a);
        b.handleLoadedTexture();
        this.setTexture(b)
    },
    getCacheContext: function() {
        return this._cacheContext
    },
    getCacheCanvas: function() {
        return this._cacheCanvas
    },
    resetCanvasSize: function(a, b) {
        var d = this._cacheCanvas,
            e = this._cacheContext,
            f = e._context.strokeStyle,
            g = e._context.fillStyle;
        void 0 === b && (b = a.height, a = a.width);
        d.width = a;
        d.height = b;
        f !== e._context.strokeStyle && (e._context.strokeStyle = f);
        g !== e._context.fillStyle && (e._context.fillStyle = g);
        this.getTexture().handleLoadedTexture();
        this.setTextureRect(cc.rect(0, 0, a, b), !1)
    }
});
cc.AnimationFrame = cc.Class.extend({
    _spriteFrame: null,
    _delayPerUnit: 0,
    _userInfo: null,
    ctor: function(a, b, d) {
        this._spriteFrame = a || null;
        this._delayPerUnit = b || 0;
        this._userInfo = d || null
    },
    clone: function() {
        var a = new cc.AnimationFrame;
        a.initWithSpriteFrame(this._spriteFrame.clone(), this._delayPerUnit, this._userInfo);
        return a
    },
    copyWithZone: function(a) {
        return cc.clone(this)
    },
    copy: function(a) {
        a = new cc.AnimationFrame;
        a.initWithSpriteFrame(this._spriteFrame.clone(), this._delayPerUnit, this._userInfo);
        return a
    },
    initWithSpriteFrame: function(a,
        b, d) {
        this._spriteFrame = a;
        this._delayPerUnit = b;
        this._userInfo = d;
        return !0
    },
    getSpriteFrame: function() {
        return this._spriteFrame
    },
    setSpriteFrame: function(a) {
        this._spriteFrame = a
    },
    getDelayUnits: function() {
        return this._delayPerUnit
    },
    setDelayUnits: function(a) {
        this._delayPerUnit = a
    },
    getUserInfo: function() {
        return this._userInfo
    },
    setUserInfo: function(a) {
        this._userInfo = a
    }
});
cc.AnimationFrame.create = function(a, b, d) {
    return new cc.AnimationFrame(a, b, d)
};
cc.Animation = cc.Class.extend({
    _frames: null,
    _loops: 0,
    _restoreOriginalFrame: !1,
    _duration: 0,
    _delayPerUnit: 0,
    _totalDelayUnits: 0,
    ctor: function(a, b, d) {
        this._frames = [];
        if (void 0 === a) this.initWithSpriteFrames(null, 0);
        else {
            var e = a[0];
            e && (e instanceof cc.SpriteFrame ? this.initWithSpriteFrames(a, b, d) : e instanceof cc.AnimationFrame && this.initWithAnimationFrames(a, b, d))
        }
    },
    getFrames: function() {
        return this._frames
    },
    setFrames: function(a) {
        this._frames = a
    },
    addSpriteFrame: function(a) {
        var b = new cc.AnimationFrame;
        b.initWithSpriteFrame(a,
            1, null);
        this._frames.push(b);
        this._totalDelayUnits++
    },
    addSpriteFrameWithFile: function(a) {
        a = cc.textureCache.addImage(a);
        var b = cc.rect(0, 0, 0, 0);
        b.width = a.width;
        b.height = a.height;
        a = new cc.SpriteFrame(a, b);
        this.addSpriteFrame(a)
    },
    addSpriteFrameWithTexture: function(a, b) {
        var d = new cc.SpriteFrame(a, b);
        this.addSpriteFrame(d)
    },
    initWithAnimationFrames: function(a, b, d) {
        cc.arrayVerifyType(a, cc.AnimationFrame);
        this._delayPerUnit = b;
        this._loops = void 0 === d ? 1 : d;
        this._totalDelayUnits = 0;
        b = this._frames;
        for (d = b.length =
            0; d < a.length; d++) {
            var e = a[d];
            b.push(e);
            this._totalDelayUnits += e.getDelayUnits()
        }
        return !0
    },
    clone: function() {
        var a = new cc.Animation;
        a.initWithAnimationFrames(this._copyFrames(), this._delayPerUnit, this._loops);
        a.setRestoreOriginalFrame(this._restoreOriginalFrame);
        return a
    },
    copyWithZone: function(a) {
        a = new cc.Animation;
        a.initWithAnimationFrames(this._copyFrames(), this._delayPerUnit, this._loops);
        a.setRestoreOriginalFrame(this._restoreOriginalFrame);
        return a
    },
    _copyFrames: function() {
        for (var a = [], b = 0; b < this._frames.length; b++) a.push(this._frames[b].clone());
        return a
    },
    copy: function(a) {
        return this.copyWithZone(null)
    },
    getLoops: function() {
        return this._loops
    },
    setLoops: function(a) {
        this._loops = a
    },
    setRestoreOriginalFrame: function(a) {
        this._restoreOriginalFrame = a
    },
    getRestoreOriginalFrame: function() {
        return this._restoreOriginalFrame
    },
    getDuration: function() {
        return this._totalDelayUnits * this._delayPerUnit
    },
    getDelayPerUnit: function() {
        return this._delayPerUnit
    },
    setDelayPerUnit: function(a) {
        this._delayPerUnit = a
    },
    getTotalDelayUnits: function() {
        return this._totalDelayUnits
    },
    initWithSpriteFrames: function(a, b, d) {
        cc.arrayVerifyType(a, cc.SpriteFrame);
        this._loops = void 0 === d ? 1 : d;
        this._delayPerUnit = b || 0;
        this._totalDelayUnits = 0;
        b = this._frames;
        b.length = 0;
        if (a) {
            for (d = 0; d < a.length; d++) {
                var e = a[d],
                    f = new cc.AnimationFrame;
                f.initWithSpriteFrame(e, 1, null);
                b.push(f)
            }
            this._totalDelayUnits += a.length
        }
        return !0
    },
    retain: function() {},
    release: function() {}
});
cc.Animation.create = function(a, b, d) {
    return new cc.Animation(a, b, d)
};
cc.Animation.createWithAnimationFrames = cc.Animation.create;
cc.animationCache = {
    _animations: {},
    addAnimation: function(a, b) {
        this._animations[b] = a
    },
    removeAnimation: function(a) {
        a && this._animations[a] && delete this._animations[a]
    },
    getAnimation: function(a) {
        return this._animations[a] ? this._animations[a] : null
    },
    _addAnimationsWithDictionary: function(a, b) {
        var d = a.animations;
        if (d) {
            var e = 1,
                f = a.properties;
            if (f)
                for (var e = null != f.format ? parseInt(f.format) : e, f = f.spritesheets, g = cc.spriteFrameCache, h = cc.path, k = 0; k < f.length; k++) g.addSpriteFrames(h.changeBasename(b, f[k]));
            switch (e) {
                case 1:
                    this._parseVersion1(d);
                    break;
                case 2:
                    this._parseVersion2(d);
                    break;
                default:
                    cc.log(cc._LogInfos.animationCache__addAnimationsWithDictionary_2)
            }
        } else cc.log(cc._LogInfos.animationCache__addAnimationsWithDictionary)
    },
    addAnimations: function(a) {
        cc.assert(a, cc._LogInfos.animationCache_addAnimations_2);
        var b = cc.loader.getRes(a);
        b ? this._addAnimationsWithDictionary(b, a) : cc.log(cc._LogInfos.animationCache_addAnimations)
    },
    _parseVersion1: function(a) {
        var b = cc.spriteFrameCache,
            d;
        for (d in a) {
            var e = a[d],
                f = e.frames,
                e = parseFloat(e.delay) ||
                0,
                g = null;
            if (f) {
                for (var g = [], h = 0; h < f.length; h++) {
                    var k = b.getSpriteFrame(f[h]);
                    if (k) {
                        var m = new cc.AnimationFrame;
                        m.initWithSpriteFrame(k, 1, null);
                        g.push(m)
                    } else cc.log(cc._LogInfos.animationCache__parseVersion1_2, d, f[h])
                }
                0 === g.length ? cc.log(cc._LogInfos.animationCache__parseVersion1_3, d) : (g.length !== f.length && cc.log(cc._LogInfos.animationCache__parseVersion1_4, d), g = new cc.Animation(g, e, 1), cc.animationCache.addAnimation(g, d))
            } else cc.log(cc._LogInfos.animationCache__parseVersion1, d)
        }
    },
    _parseVersion2: function(a) {
        var b =
            cc.spriteFrameCache,
            d;
        for (d in a) {
            var e = a[d],
                f = e.loop,
                g = parseInt(e.loops),
                f = f ? cc.REPEAT_FOREVER : isNaN(g) ? 1 : g,
                g = e.restoreOriginalFrame && !0 == e.restoreOriginalFrame ? !0 : !1,
                h = e.frames;
            if (h) {
                for (var k = [], m = 0; m < h.length; m++) {
                    var n = h[m],
                        p = n.spriteframe,
                        r = b.getSpriteFrame(p);
                    if (r) {
                        var p = parseFloat(n.delayUnits) || 0,
                            n = n.notification,
                            s = new cc.AnimationFrame;
                        s.initWithSpriteFrame(r, p, n);
                        k.push(s)
                    } else cc.log(cc._LogInfos.animationCache__parseVersion2_2, d, p)
                }
                e = parseFloat(e.delayPerUnit) || 0;
                h = new cc.Animation;
                h.initWithAnimationFrames(k,
                    e, f);
                h.setRestoreOriginalFrame(g);
                cc.animationCache.addAnimation(h, d)
            } else cc.log(cc._LogInfos.animationCache__parseVersion2, d)
        }
    },
    _clear: function() {
        this._animations = {}
    }
};
cc.SpriteFrame = cc.Class.extend({
    _offset: null,
    _originalSize: null,
    _rectInPixels: null,
    _rotated: !1,
    _rect: null,
    _offsetInPixels: null,
    _originalSizeInPixels: null,
    _texture: null,
    _textureFilename: "",
    _textureLoaded: !1,
    ctor: function(a, b, d, e, f) {
        this._offset = cc.p(0, 0);
        this._offsetInPixels = cc.p(0, 0);
        this._originalSize = cc.size(0, 0);
        this._rotated = !1;
        this._originalSizeInPixels = cc.size(0, 0);
        this._textureFilename = "";
        this._texture = null;
        this._textureLoaded = !1;
        void 0 !== a && void 0 !== b && (void 0 === d || void 0 === e || void 0 === f ?
            this.initWithTexture(a, b) : this.initWithTexture(a, b, d, e, f))
    },
    textureLoaded: function() {
        return this._textureLoaded
    },
    addLoadedEventListener: function(a, b) {
        this.addEventListener("load", a, b)
    },
    getRectInPixels: function() {
        var a = this._rectInPixels;
        return cc.rect(a.x, a.y, a.width, a.height)
    },
    setRectInPixels: function(a) {
        this._rectInPixels || (this._rectInPixels = cc.rect(0, 0, 0, 0));
        this._rectInPixels.x = a.x;
        this._rectInPixels.y = a.y;
        this._rectInPixels.width = a.width;
        this._rectInPixels.height = a.height;
        this._rect = cc.rectPixelsToPoints(a)
    },
    isRotated: function() {
        return this._rotated
    },
    setRotated: function(a) {
        this._rotated = a
    },
    getRect: function() {
        var a = this._rect;
        return cc.rect(a.x, a.y, a.width, a.height)
    },
    setRect: function(a) {
        this._rect || (this._rect = cc.rect(0, 0, 0, 0));
        this._rect.x = a.x;
        this._rect.y = a.y;
        this._rect.width = a.width;
        this._rect.height = a.height;
        this._rectInPixels = cc.rectPointsToPixels(this._rect)
    },
    getOffsetInPixels: function() {
        return cc.p(this._offsetInPixels)
    },
    setOffsetInPixels: function(a) {
        this._offsetInPixels.x = a.x;
        this._offsetInPixels.y =
            a.y;
        cc._pointPixelsToPointsOut(this._offsetInPixels, this._offset)
    },
    getOriginalSizeInPixels: function() {
        return cc.size(this._originalSizeInPixels)
    },
    setOriginalSizeInPixels: function(a) {
        this._originalSizeInPixels.width = a.width;
        this._originalSizeInPixels.height = a.height
    },
    getOriginalSize: function() {
        return cc.size(this._originalSize)
    },
    setOriginalSize: function(a) {
        this._originalSize.width = a.width;
        this._originalSize.height = a.height
    },
    getTexture: function() {
        if (this._texture) return this._texture;
        if ("" !== this._textureFilename) {
            var a =
                cc.textureCache.addImage(this._textureFilename);
            a && (this._textureLoaded = a.isLoaded());
            return a
        }
        return null
    },
    setTexture: function(a) {
        if (this._texture !== a) {
            var b = a.isLoaded();
            this._textureLoaded = b;
            this._texture = a;
            b || a.addEventListener("load", function(a) {
                this._textureLoaded = !0;
                if (this._rotated && cc._renderType === cc._RENDER_TYPE_CANVAS) {
                    var b = a.getHtmlElementObj(),
                        b = cc.Sprite.CanvasRenderCmd._cutRotateImageToCanvas(b, this.getRect()),
                        f = new cc.Texture2D;
                    f.initWithElement(b);
                    f.handleLoadedTexture();
                    this.setTexture(f);
                    b = this.getRect();
                    this.setRect(cc.rect(0, 0, b.width, b.height))
                }
                b = this._rect;
                0 === b.width && 0 === b.height && (b = a.width, a = a.height, this._rect.width = b, this._rect.height = a, this._rectInPixels = cc.rectPointsToPixels(this._rect), this._originalSizeInPixels.width = this._rectInPixels.width, this._originalSizeInPixels.height = this._rectInPixels.height, this._originalSize.width = b, this._originalSize.height = a);
                this.dispatchEvent("load")
            }, this)
        }
    },
    getOffset: function() {
        return cc.p(this._offset)
    },
    setOffset: function(a) {
        this._offset.x =
            a.x;
        this._offset.y = a.y
    },
    clone: function() {
        var a = new cc.SpriteFrame;
        a.initWithTexture(this._textureFilename, this._rectInPixels, this._rotated, this._offsetInPixels, this._originalSizeInPixels);
        a.setTexture(this._texture);
        return a
    },
    copyWithZone: function() {
        var a = new cc.SpriteFrame;
        a.initWithTexture(this._textureFilename, this._rectInPixels, this._rotated, this._offsetInPixels, this._originalSizeInPixels);
        a.setTexture(this._texture);
        return a
    },
    copy: function() {
        return this.copyWithZone()
    },
    initWithTexture: function(a,
        b, d, e, f) {
        2 === arguments.length && (b = cc.rectPointsToPixels(b));
        e = e || cc.p(0, 0);
        f = f || b;
        d = d || !1;
        cc.isString(a) ? (this._texture = null, this._textureFilename = a) : a instanceof cc.Texture2D && this.setTexture(a);
        a = this.getTexture();
        this._rectInPixels = b;
        b = this._rect = cc.rectPixelsToPoints(b);
        if (a && a.url && a.isLoaded()) {
            var g, h;
            d ? (g = b.x + b.height, h = b.y + b.width) : (g = b.x + b.width, h = b.y + b.height);
            g > a.getPixelsWide() && cc.error(cc._LogInfos.RectWidth, a.url);
            h > a.getPixelsHigh() && cc.error(cc._LogInfos.RectHeight, a.url)
        }
        this._offsetInPixels.x =
            e.x;
        this._offsetInPixels.y = e.y;
        cc._pointPixelsToPointsOut(e, this._offset);
        this._originalSizeInPixels.width = f.width;
        this._originalSizeInPixels.height = f.height;
        cc._sizePixelsToPointsOut(f, this._originalSize);
        this._rotated = d;
        return !0
    }
});
cc.EventHelper.prototype.apply(cc.SpriteFrame.prototype);
cc.SpriteFrame.create = function(a, b, d, e, f) {
    return new cc.SpriteFrame(a, b, d, e, f)
};
cc.SpriteFrame.createWithTexture = cc.SpriteFrame.create;
cc.SpriteFrame._frameWithTextureForCanvas = function(a, b, d, e, f) {
    var g = new cc.SpriteFrame;
    g._texture = a;
    g._rectInPixels = b;
    g._rect = cc.rectPixelsToPoints(b);
    g._offsetInPixels.x = e.x;
    g._offsetInPixels.y = e.y;
    cc._pointPixelsToPointsOut(g._offsetInPixels, g._offset);
    g._originalSizeInPixels.width = f.width;
    g._originalSizeInPixels.height = f.height;
    cc._sizePixelsToPointsOut(g._originalSizeInPixels, g._originalSize);
    g._rotated = d;
    return g
};
cc.spriteFrameCache = {
    _CCNS_REG1: /^\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*$/,
    _CCNS_REG2: /^\s*\{\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*,\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*\}\s*$/,
    _spriteFrames: {},
    _spriteFramesAliases: {},
    _frameConfigCache: {},
    _rectFromString: function(a) {
        a = this._CCNS_REG2.exec(a);
        return !a ? cc.rect(0, 0, 0, 0) : cc.rect(parseFloat(a[1]), parseFloat(a[2]), parseFloat(a[3]), parseFloat(a[4]))
    },
    _pointFromString: function(a) {
        a = this._CCNS_REG1.exec(a);
        return !a ? cc.p(0, 0) : cc.p(parseFloat(a[1]), parseFloat(a[2]))
    },
    _sizeFromString: function(a) {
        a = this._CCNS_REG1.exec(a);
        return !a ? cc.size(0, 0) : cc.size(parseFloat(a[1]), parseFloat(a[2]))
    },
    _getFrameConfig: function(a) {
        var b = cc.loader.getRes(a);
        cc.assert(b, cc._LogInfos.spriteFrameCache__getFrameConfig_2, a);
        cc.loader.release(a);
        if (b._inited) return this._frameConfigCache[a] = b;
        this._frameConfigCache[a] = this._parseFrameConfig(b);
        return this._frameConfigCache[a]
    },
    _getFrameConfigByJsonObject: function(a, b) {
        cc.assert(b,
            cc._LogInfos.spriteFrameCache__getFrameConfig_2, a);
        this._frameConfigCache[a] = this._parseFrameConfig(b);
        return this._frameConfigCache[a]
    },
    _parseFrameConfig: function(a) {
        var b = a.frames,
            d = a.metadata || a.meta;
        a = {};
        var e = {},
            f = 0;
        d && (f = d.format, f = 1 >= f.length ? parseInt(f) : f, e.image = d.textureFileName || d.textureFileName || d.image);
        for (var g in b) {
            var h = b[g];
            if (h) {
                d = {};
                if (0 == f) {
                    d.rect = cc.rect(h.x, h.y, h.width, h.height);
                    d.rotated = !1;
                    d.offset = cc.p(h.offsetX, h.offsetY);
                    var k = h.originalWidth,
                        h = h.originalHeight;
                    (!k ||
                        !h) && cc.log(cc._LogInfos.spriteFrameCache__getFrameConfig);
                    k = Math.abs(k);
                    h = Math.abs(h);
                    d.size = cc.size(k, h)
                } else if (1 == f || 2 == f) d.rect = this._rectFromString(h.frame), d.rotated = h.rotated || !1, d.offset = this._pointFromString(h.offset), d.size = this._sizeFromString(h.sourceSize);
                else if (3 == f) {
                    var k = this._sizeFromString(h.spriteSize),
                        m = this._rectFromString(h.textureRect);
                    k && (m = cc.rect(m.x, m.y, k.width, k.height));
                    d.rect = m;
                    d.rotated = h.textureRotated || !1;
                    d.offset = this._pointFromString(h.spriteOffset);
                    d.size = this._sizeFromString(h.spriteSourceSize);
                    d.aliases = h.aliases
                } else k = h.frame, m = h.sourceSize, g = h.filename || g, d.rect = cc.rect(k.x, k.y, k.w, k.h), d.rotated = h.rotated || !1, d.offset = cc.p(0, 0), d.size = cc.size(m.w, m.h);
                a[g] = d
            }
        }
        return {
            _inited: !0,
            frames: a,
            meta: e
        }
    },
    _addSpriteFramesByObject: function(a, b, d) {
        cc.assert(a, cc._LogInfos.spriteFrameCache_addSpriteFrames_2);
        b && b.frames && (b = this._frameConfigCache[a] || this._getFrameConfigByJsonObject(a, b), this._createSpriteFrames(a, b, d))
    },
    _createSpriteFrames: function(a, b, d) {
        var e = b.frames;
        b = b.meta;
        d ? d instanceof cc.Texture2D ||
            (cc.isString(d) ? d = cc.textureCache.addImage(d) : cc.assert(0, cc._LogInfos.spriteFrameCache_addSpriteFrames_3)) : (d = cc.path.changeBasename(a, b.image || ".png"), d = cc.textureCache.addImage(d));
        a = this._spriteFramesAliases;
        b = this._spriteFrames;
        for (var f in e) {
            var g = e[f],
                h = b[f];
            if (!h) {
                h = new cc.SpriteFrame(d, g.rect, g.rotated, g.offset, g.size);
                if (g = g.aliases)
                    for (var k = 0, m = g.length; k < m; k++) {
                        var n = g[k];
                        a[n] && cc.log(cc._LogInfos.spriteFrameCache_addSpriteFrames, n);
                        a[n] = f
                    }
                cc._renderType === cc._RENDER_TYPE_CANVAS && h.isRotated() &&
                    h.getTexture().isLoaded() && (g = h.getTexture().getHtmlElementObj(), g = cc.Sprite.CanvasRenderCmd._cutRotateImageToCanvas(g, h.getRectInPixels()), k = new cc.Texture2D, k.initWithElement(g), k.handleLoadedTexture(), h.setTexture(k), g = h._rect, h.setRect(cc.rect(0, 0, g.width, g.height)));
                b[f] = h
            }
        }
    },
    addSpriteFrames: function(a, b) {
        cc.assert(a, cc._LogInfos.spriteFrameCache_addSpriteFrames_2);
        var d = this._frameConfigCache[a] || cc.loader.getRes(a);
        d && d.frames && (d = this._frameConfigCache[a] || this._getFrameConfig(a), this._createSpriteFrames(a,
            d, b))
    },
    _checkConflict: function(a) {
        a = a.frames;
        for (var b in a) this._spriteFrames[b] && cc.log(cc._LogInfos.spriteFrameCache__checkConflict, b)
    },
    addSpriteFrame: function(a, b) {
        this._spriteFrames[b] = a
    },
    removeSpriteFrames: function() {
        this._spriteFrames = {};
        this._spriteFramesAliases = {}
    },
    removeSpriteFrameByName: function(a) {
        a && (this._spriteFramesAliases[a] && delete this._spriteFramesAliases[a], this._spriteFrames[a] && delete this._spriteFrames[a])
    },
    removeSpriteFramesFromFile: function(a) {
        var b = this._spriteFrames,
            d =
            this._spriteFramesAliases;
        if (a = this._frameConfigCache[a]) {
            a = a.frames;
            for (var e in a)
                if (b[e]) {
                    delete b[e];
                    for (var f in d) d[f] === e && delete d[f]
                }
        }
    },
    removeSpriteFramesFromTexture: function(a) {
        var b = this._spriteFrames,
            d = this._spriteFramesAliases,
            e;
        for (e in b) {
            var f = b[e];
            if (f && f.getTexture() === a) {
                delete b[e];
                for (var g in d) d[g] === e && delete d[g]
            }
        }
    },
    getSpriteFrame: function(a) {
        var b = this._spriteFrames[a];
        if (!b) {
            var d = this._spriteFramesAliases[a];
            d && ((b = this._spriteFrames[d.toString()]) || delete this._spriteFramesAliases[a])
        }
        return b
    },
    _clear: function() {
        this._spriteFrames = {};
        this._spriteFramesAliases = {};
        this._frameConfigCache = {}
    }
};
cc.configuration = {
    ERROR: 0,
    STRING: 1,
    INT: 2,
    DOUBLE: 3,
    BOOLEAN: 4,
    _maxTextureSize: 0,
    _maxModelviewStackDepth: 0,
    _supportsPVRTC: !1,
    _supportsNPOT: !1,
    _supportsBGRA8888: !1,
    _supportsDiscardFramebuffer: !1,
    _supportsShareableVAO: !1,
    _maxSamplesAllowed: 0,
    _maxTextureUnits: 0,
    _GlExtensions: "",
    _valueDict: {},
    _inited: !1,
    _init: function() {
        var a = this._valueDict;
        a["cocos2d.x.version"] = cc.ENGINE_VERSION;
        a["cocos2d.x.compiled_with_profiler"] = !1;
        a["cocos2d.x.compiled_with_gl_state_cache"] = cc.ENABLE_GL_STATE_CACHE;
        this._inited = !0
    },
    getMaxTextureSize: function() {
        return this._maxTextureSize
    },
    getMaxModelviewStackDepth: function() {
        return this._maxModelviewStackDepth
    },
    getMaxTextureUnits: function() {
        return this._maxTextureUnits
    },
    supportsNPOT: function() {
        return this._supportsNPOT
    },
    supportsPVRTC: function() {
        return this._supportsPVRTC
    },
    supportsETC: function() {
        return !1
    },
    supportsS3TC: function() {
        return !1
    },
    supportsATITC: function() {
        return !1
    },
    supportsBGRA8888: function() {
        return this._supportsBGRA8888
    },
    supportsDiscardFramebuffer: function() {
        return this._supportsDiscardFramebuffer
    },
    supportsShareableVAO: function() {
        return this._supportsShareableVAO
    },
    checkForGLExtension: function(a) {
        return -1 < this._GlExtensions.indexOf(a)
    },
    getValue: function(a, b) {
        this._inited || this._init();
        var d = this._valueDict;
        return d[a] ? d[a] : b
    },
    setValue: function(a, b) {
        this._valueDict[a] = b
    },
    dumpInfo: function() {
        0 === cc.ENABLE_GL_STATE_CACHE && (cc.log(""), cc.log(cc._LogInfos.configuration_dumpInfo), cc.log(""))
    },
    gatherGPUInfo: function() {
        if (cc._renderType !== cc._RENDER_TYPE_CANVAS) {
            this._inited || this._init();
            var a = cc._renderContext,
                b = this._valueDict;
            b["gl.vendor"] = a.getParameter(a.VENDOR);
            b["gl.renderer"] = a.getParameter(a.RENDERER);
            b["gl.version"] = a.getParameter(a.VERSION);
            this._GlExtensions = "";
            for (var d = a.getSupportedExtensions(), e = 0; e < d.length; e++) this._GlExtensions += d[e] + " ";
            this._maxTextureSize = a.getParameter(a.MAX_TEXTURE_SIZE);
            b["gl.max_texture_size"] = this._maxTextureSize;
            this._maxTextureUnits = a.getParameter(a.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
            b["gl.max_texture_units"] = this._maxTextureUnits;
            this._supportsPVRTC = this.checkForGLExtension("GL_IMG_texture_compression_pvrtc");
            b["gl.supports_PVRTC"] = this._supportsPVRTC;
            this._supportsNPOT = !1;
            b["gl.supports_NPOT"] = this._supportsNPOT;
            this._supportsBGRA8888 = this.checkForGLExtension("GL_IMG_texture_format_BGRA888");
            b["gl.supports_BGRA8888"] = this._supportsBGRA8888;
            this._supportsDiscardFramebuffer = this.checkForGLExtension("GL_EXT_discard_framebuffer");
            b["gl.supports_discard_framebuffer"] = this._supportsDiscardFramebuffer;
            this._supportsShareableVAO = this.checkForGLExtension("vertex_array_object");
            b["gl.supports_vertex_array_object"] =
                this._supportsShareableVAO;
            cc.checkGLErrorDebug()
        }
    },
    loadConfigFile: function(a) {
        this._inited || this._init();
        var b = cc.loader.getRes(a);
        if (!b) throw Error("Please load the resource first : " + a);
        cc.assert(b, cc._LogInfos.configuration_loadConfigFile_2, a);
        if (b = b.data)
            for (var d in b) this._valueDict[d] = b[d];
        else cc.log(cc._LogInfos.configuration_loadConfigFile, a)
    }
};
cc.g_NumberOfDraws = 0;
cc.GLToClipTransform = function(a) {
    cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, a);
    var b = new cc.math.Matrix4;
    cc.kmGLGetMatrix(cc.KM_GL_MODELVIEW, b);
    a.multiply(b)
};
cc.Director = cc.Class.extend({
    _landscape: !1,
    _nextDeltaTimeZero: !1,
    _paused: !1,
    _purgeDirectorInNextLoop: !1,
    _sendCleanupToScene: !1,
    _animationInterval: 0,
    _oldAnimationInterval: 0,
    _projection: 0,
    _accumDt: 0,
    _contentScaleFactor: 1,
    _displayStats: !1,
    _deltaTime: 0,
    _frameRate: 0,
    _FPSLabel: null,
    _SPFLabel: null,
    _drawsLabel: null,
    _winSizeInPoints: null,
    _lastUpdate: null,
    _nextScene: null,
    _notificationNode: null,
    _openGLView: null,
    _scenesStack: null,
    _projectionDelegate: null,
    _runningScene: null,
    _frames: 0,
    _totalFrames: 0,
    _secondsPerFrame: 0,
    _dirtyRegion: null,
    _scheduler: null,
    _actionManager: null,
    _eventProjectionChanged: null,
    _eventAfterDraw: null,
    _eventAfterVisit: null,
    _eventAfterUpdate: null,
    ctor: function() {
        var a = this;
        a._lastUpdate = Date.now();
        cc.eventManager.addCustomListener(cc.game.EVENT_SHOW, function() {
            a._lastUpdate = Date.now()
        })
    },
    init: function() {
        this._oldAnimationInterval = this._animationInterval = 1 / cc.defaultFPS;
        this._scenesStack = [];
        this._projection = cc.Director.PROJECTION_DEFAULT;
        this._projectionDelegate = null;
        this._frameRate = this._accumDt =
            0;
        this._displayStats = !1;
        this._totalFrames = this._frames = 0;
        this._lastUpdate = Date.now();
        this._purgeDirectorInNextLoop = this._paused = !1;
        this._winSizeInPoints = cc.size(0, 0);
        this._openGLView = null;
        this._contentScaleFactor = 1;
        this._scheduler = new cc.Scheduler;
        cc.ActionManager ? (this._actionManager = new cc.ActionManager, this._scheduler.scheduleUpdate(this._actionManager, cc.Scheduler.PRIORITY_SYSTEM, !1)) : this._actionManager = null;
        this._eventAfterDraw = new cc.EventCustom(cc.Director.EVENT_AFTER_DRAW);
        this._eventAfterDraw.setUserData(this);
        this._eventAfterVisit = new cc.EventCustom(cc.Director.EVENT_AFTER_VISIT);
        this._eventAfterVisit.setUserData(this);
        this._eventAfterUpdate = new cc.EventCustom(cc.Director.EVENT_AFTER_UPDATE);
        this._eventAfterUpdate.setUserData(this);
        this._eventProjectionChanged = new cc.EventCustom(cc.Director.EVENT_PROJECTION_CHANGED);
        this._eventProjectionChanged.setUserData(this);
        return !0
    },
    calculateDeltaTime: function() {
        var a = Date.now();
        this._nextDeltaTimeZero ? (this._deltaTime = 0, this._nextDeltaTimeZero = !1) : this._deltaTime =
            (a - this._lastUpdate) / 1E3;
        0 < cc.game.config[cc.game.CONFIG_KEY.debugMode] && 0.2 < this._deltaTime && (this._deltaTime = 1 / 60);
        this._lastUpdate = a
    },
    convertToGL: null,
    convertToUI: null,
    drawScene: function() {
        var a = cc.renderer;
        this.calculateDeltaTime();
        this._paused || (this._scheduler.update(this._deltaTime), cc.eventManager.dispatchEvent(this._eventAfterUpdate));
        a.clear();
        this._nextScene && this.setNextScene();
        this._beforeVisitScene && this._beforeVisitScene();
        this._runningScene && (!0 === a.childrenOrderDirty ? (cc.renderer.clearRenderCommands(),
            this._runningScene._renderCmd._curLevel = 0, this._runningScene.visit(), a.resetFlag()) : !0 === a.transformDirty() && a.transform(), cc.eventManager.dispatchEvent(this._eventAfterVisit));
        this._notificationNode && this._notificationNode.visit();
        this._displayStats && this._showStats();
        this._afterVisitScene && this._afterVisitScene();
        a.rendering(cc._renderContext);
        cc.eventManager.dispatchEvent(this._eventAfterDraw);
        this._totalFrames++;
        this._displayStats && this._calculateMPF()
    },
    _beforeVisitScene: null,
    _afterVisitScene: null,
    end: function() {
        this._purgeDirectorInNextLoop = !0
    },
    getContentScaleFactor: function() {
        return this._contentScaleFactor
    },
    getNotificationNode: function() {
        return this._notificationNode
    },
    getWinSize: function() {
        return cc.size(this._winSizeInPoints)
    },
    getWinSizeInPixels: function() {
        return cc.size(this._winSizeInPoints.width * this._contentScaleFactor, this._winSizeInPoints.height * this._contentScaleFactor)
    },
    getVisibleSize: null,
    getVisibleOrigin: null,
    getZEye: null,
    pause: function() {
        this._paused || (this._oldAnimationInterval =
            this._animationInterval, this.setAnimationInterval(0.25), this._paused = !0)
    },
    popScene: function() {
        cc.assert(this._runningScene, cc._LogInfos.Director_popScene);
        this._scenesStack.pop();
        var a = this._scenesStack.length;
        0 === a ? this.end() : (this._sendCleanupToScene = !0, this._nextScene = this._scenesStack[a - 1])
    },
    purgeCachedData: function() {
        cc.animationCache._clear();
        cc.spriteFrameCache._clear();
        cc.textureCache._clear()
    },
    purgeDirector: function() {
        this.getScheduler().unscheduleAll();
        cc.eventManager && cc.eventManager.setEnabled(!1);
        this._runningScene && (this._runningScene.onExitTransitionDidStart(), this._runningScene.onExit(), this._runningScene.cleanup());
        this._nextScene = this._runningScene = null;
        this._scenesStack.length = 0;
        this.stopAnimation();
        this.purgeCachedData();
        cc.checkGLErrorDebug()
    },
    pushScene: function(a) {
        cc.assert(a, cc._LogInfos.Director_pushScene);
        this._sendCleanupToScene = !1;
        this._scenesStack.push(a);
        this._nextScene = a
    },
    runScene: function(a) {
        cc.assert(a, cc._LogInfos.Director_pushScene);
        if (this._runningScene) {
            var b = this._scenesStack.length;
            0 === b ? (this._sendCleanupToScene = !0, this._scenesStack[b] = a) : (this._sendCleanupToScene = !0, this._scenesStack[b - 1] = a);
            this._nextScene = a
        } else this.pushScene(a), this.startAnimation()
    },
    resume: function() {
        this._paused && (this.setAnimationInterval(this._oldAnimationInterval), (this._lastUpdate = Date.now()) || cc.log(cc._LogInfos.Director_resume), this._paused = !1, this._deltaTime = 0)
    },
    setContentScaleFactor: function(a) {
        a !== this._contentScaleFactor && (this._contentScaleFactor = a, this._createStatsLabel())
    },
    setDepthTest: null,
    setClearColor: null,
    setDefaultValues: function() {},
    setNextDeltaTimeZero: function(a) {
        this._nextDeltaTimeZero = a
    },
    setNextScene: function() {
        var a = !1,
            b = !1;
        cc.TransitionScene && (a = this._runningScene ? this._runningScene instanceof cc.TransitionScene : !1, b = this._nextScene ? this._nextScene instanceof cc.TransitionScene : !1);
        if (!b) {
            if (b = this._runningScene) b.onExitTransitionDidStart(), b.onExit();
            this._sendCleanupToScene && b && b.cleanup()
        }
        this._runningScene = this._nextScene;
        cc.renderer.childrenOrderDirty = !0;
        this._nextScene =
            null;
        !a && null !== this._runningScene && (this._runningScene.onEnter(), this._runningScene.onEnterTransitionDidFinish())
    },
    setNotificationNode: function(a) {
        this._notificationNode = a
    },
    getDelegate: function() {
        return this._projectionDelegate
    },
    setDelegate: function(a) {
        this._projectionDelegate = a
    },
    setOpenGLView: null,
    setProjection: null,
    setViewport: null,
    getOpenGLView: null,
    getProjection: null,
    setAlphaBlending: null,
    _showStats: function() {
        this._frames++;
        this._accumDt += this._deltaTime;
        this._FPSLabel && this._SPFLabel && this._drawsLabel ?
            (this._accumDt > cc.DIRECTOR_FPS_INTERVAL && (this._SPFLabel.string = this._secondsPerFrame.toFixed(3), this._frameRate = this._frames / this._accumDt, this._accumDt = this._frames = 0, this._FPSLabel.string = this._frameRate.toFixed(1), this._drawsLabel.string = (0 | cc.g_NumberOfDraws).toString()), this._FPSLabel.visit(), this._SPFLabel.visit(), this._drawsLabel.visit()) : this._createStatsLabel();
        cc.g_NumberOfDraws = 0
    },
    isSendCleanupToScene: function() {
        return this._sendCleanupToScene
    },
    getRunningScene: function() {
        return this._runningScene
    },
    getAnimationInterval: function() {
        return this._animationInterval
    },
    isDisplayStats: function() {
        return this._displayStats
    },
    setDisplayStats: function(a) {
        this._displayStats = a
    },
    getSecondsPerFrame: function() {
        return this._secondsPerFrame
    },
    isNextDeltaTimeZero: function() {
        return this._nextDeltaTimeZero
    },
    isPaused: function() {
        return this._paused
    },
    getTotalFrames: function() {
        return this._totalFrames
    },
    popToRootScene: function() {
        this.popToSceneStackLevel(1)
    },
    popToSceneStackLevel: function(a) {
        cc.assert(this._runningScene,
            cc._LogInfos.Director_popToSceneStackLevel_2);
        var b = this._scenesStack,
            d = b.length;
        if (0 === d) this.end();
        else if (!(a > d)) {
            for (; d > a;) {
                var e = b.pop();
                e.running && (e.onExitTransitionDidStart(), e.onExit());
                e.cleanup();
                d--
            }
            this._nextScene = b[b.length - 1];
            this._sendCleanupToScene = !1
        }
    },
    getScheduler: function() {
        return this._scheduler
    },
    setScheduler: function(a) {
        this._scheduler !== a && (this._scheduler = a)
    },
    getActionManager: function() {
        return this._actionManager
    },
    setActionManager: function(a) {
        this._actionManager !== a && (this._actionManager =
            a)
    },
    getDeltaTime: function() {
        return this._deltaTime
    },
    _createStatsLabel: null,
    _calculateMPF: function() {
        this._secondsPerFrame = (Date.now() - this._lastUpdate) / 1E3
    }
});
cc.Director.EVENT_PROJECTION_CHANGED = "director_projection_changed";
cc.Director.EVENT_AFTER_DRAW = "director_after_draw";
cc.Director.EVENT_AFTER_VISIT = "director_after_visit";
cc.Director.EVENT_AFTER_UPDATE = "director_after_update";
cc.DisplayLinkDirector = cc.Director.extend({
    invalid: !1,
    startAnimation: function() {
        this._nextDeltaTimeZero = !0;
        this.invalid = !1
    },
    mainLoop: function() {
        this._purgeDirectorInNextLoop ? (this._purgeDirectorInNextLoop = !1, this.purgeDirector()) : this.invalid || this.drawScene()
    },
    stopAnimation: function() {
        this.invalid = !0
    },
    setAnimationInterval: function(a) {
        this._animationInterval = a;
        this.invalid || (this.stopAnimation(), this.startAnimation())
    }
});
cc.Director.sharedDirector = null;
cc.Director.firstUseDirector = !0;
cc.Director._getInstance = function() {
    cc.Director.firstUseDirector && (cc.Director.firstUseDirector = !1, cc.Director.sharedDirector = new cc.DisplayLinkDirector, cc.Director.sharedDirector.init());
    return cc.Director.sharedDirector
};
cc.defaultFPS = 60;
cc.Director.PROJECTION_2D = 0;
cc.Director.PROJECTION_3D = 1;
cc.Director.PROJECTION_CUSTOM = 3;
cc.Director.PROJECTION_DEFAULT = cc.Director.PROJECTION_3D;
cc._renderType === cc._RENDER_TYPE_CANVAS ? (_p = cc.Director.prototype, _p.setProjection = function(a) {
        this._projection = a;
        cc.eventManager.dispatchEvent(this._eventProjectionChanged)
    }, _p.setDepthTest = function() {}, _p.setClearColor = function(a) {
        cc.renderer._clearColor = a;
        cc.renderer._clearFillStyle = "rgb(" + a.r + "," + a.g + "," + a.b + ")"
    }, _p.setOpenGLView = function(a) {
        this._winSizeInPoints.width = cc._canvas.width;
        this._winSizeInPoints.height = cc._canvas.height;
        this._openGLView = a || cc.view;
        cc.eventManager && cc.eventManager.setEnabled(!0)
    },
    _p._createStatsLabel = function() {
        var a = 0,
            a = this._winSizeInPoints.width > this._winSizeInPoints.height ? 0 | 24 * (this._winSizeInPoints.height / 320) : 0 | 24 * (this._winSizeInPoints.width / 320);
        this._FPSLabel = new cc.LabelTTF("000.0", "Arial", a);
        this._SPFLabel = new cc.LabelTTF("0.000", "Arial", a);
        this._drawsLabel = new cc.LabelTTF("0000", "Arial", a);
        a = cc.DIRECTOR_STATS_POSITION;
        this._drawsLabel.setPosition(this._drawsLabel.width / 2 + a.x, 5 * this._drawsLabel.height / 2 + a.y);
        this._SPFLabel.setPosition(this._SPFLabel.width / 2 + a.x,
            3 * this._SPFLabel.height / 2 + a.y);
        this._FPSLabel.setPosition(this._FPSLabel.width / 2 + a.x, this._FPSLabel.height / 2 + a.y)
    }, _p.getVisibleSize = function() {
        return this.getWinSize()
    }, _p.getVisibleOrigin = function() {
        return cc.p(0, 0)
    }) : (cc.Director._fpsImage = new Image, cc._addEventListener(cc.Director._fpsImage, "load", function() {
    cc.Director._fpsImageLoaded = !0
}), cc._fpsImage && (cc.Director._fpsImage.src = cc._fpsImage));
cc._renderType === cc._RENDER_TYPE_WEBGL && function() {
    cc.DirectorDelegate = cc.Class.extend({
        updateProjection: function() {}
    });
    var a = cc.Director.prototype;
    a.setProjection = function(a) {
        var d = this._winSizeInPoints;
        this.setViewport();
        var e = this._openGLView,
            f = e._viewPortRect.x / e._scaleX,
            g = e._viewPortRect.y / e._scaleY;
        switch (a) {
            case cc.Director.PROJECTION_2D:
                cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
                cc.kmGLLoadIdentity();
                e = cc.math.Matrix4.createOrthographicProjection(-f, d.width - f, -g, d.height - g, -1024, 1024);
                cc.kmGLMultMatrix(e);
                cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
                cc.kmGLLoadIdentity();
                break;
            case cc.Director.PROJECTION_3D:
                var h = this.getZEye(),
                    k = new cc.math.Matrix4,
                    e = new cc.math.Matrix4;
                cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
                cc.kmGLLoadIdentity();
                k = cc.math.Matrix4.createPerspectiveProjection(60, d.width / d.height, 0.1, 2 * h);
                cc.kmGLMultMatrix(k);
                cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
                cc.kmGLLoadIdentity();
                h = new cc.math.Vec3(-f + d.width / 2, -g + d.height / 2, h);
                d = new cc.math.Vec3(-f + d.width / 2, -g + d.height / 2, 0);
                f = new cc.math.Vec3(0, 1, 0);
                e.lookAt(h, d, f);
                cc.kmGLMultMatrix(e);
                break;
            case cc.Director.PROJECTION_CUSTOM:
                this._projectionDelegate && this._projectionDelegate.updateProjection();
                break;
            default:
                cc.log(cc._LogInfos.Director_setProjection)
        }
        this._projection = a;
        cc.eventManager.dispatchEvent(this._eventProjectionChanged);
        cc.setProjectionMatrixDirty();
        cc.renderer.childrenOrderDirty = !0
    };
    a.setDepthTest = function(a) {
        var d = cc._renderContext;
        a ? (d.clearDepth(1), d.enable(d.DEPTH_TEST), d.depthFunc(d.LEQUAL)) : d.disable(d.DEPTH_TEST)
    };
    a.setClearColor =
        function(a) {
            cc.renderer._clearColor = a
        };
    a.setOpenGLView = function(a) {
        this._winSizeInPoints.width = cc._canvas.width;
        this._winSizeInPoints.height = cc._canvas.height;
        this._openGLView = a || cc.view;
        a = cc.configuration;
        a.gatherGPUInfo();
        a.dumpInfo();
        this._createStatsLabel();
        this.setGLDefaultValues();
        cc.eventManager && cc.eventManager.setEnabled(!0)
    };
    a._clear = function() {
        var a = cc._renderContext;
        a.clear(a.COLOR_BUFFER_BIT | a.DEPTH_BUFFER_BIT)
    };
    a._beforeVisitScene = function() {
        cc.kmGLPushMatrix()
    };
    a._afterVisitScene = function() {
        cc.kmGLPopMatrix()
    };
    a._createStatsLabel = function() {
        if (cc.LabelAtlas) {
            if (!(null == cc.Director._fpsImageLoaded || !1 === cc.Director._fpsImageLoaded)) {
                var a = new cc.Texture2D;
                a.initWithElement(cc.Director._fpsImage);
                a.handleLoadedTexture();
                var d = cc.view.getDesignResolutionSize().height / 320;
                0 === d && (d = this._winSizeInPoints.height / 320);
                var e = new cc.LabelAtlas;
                e._setIgnoreContentScaleFactor(!0);
                e.initWithString("00.0", a, 12, 32, ".");
                e.scale = d;
                this._FPSLabel = e;
                e = new cc.LabelAtlas;
                e._setIgnoreContentScaleFactor(!0);
                e.initWithString("0.000",
                    a, 12, 32, ".");
                e.scale = d;
                this._SPFLabel = e;
                e = new cc.LabelAtlas;
                e._setIgnoreContentScaleFactor(!0);
                e.initWithString("000", a, 12, 32, ".");
                e.scale = d;
                this._drawsLabel = e;
                a = cc.DIRECTOR_STATS_POSITION;
                this._drawsLabel.setPosition(a.x, 34 * d + a.y);
                this._SPFLabel.setPosition(a.x, 17 * d + a.y);
                this._FPSLabel.setPosition(a)
            }
        } else this._createStatsLabelForCanvas()
    };
    a._createStatsLabelForCanvas = function() {
        var a = 0,
            a = this._winSizeInPoints.width > this._winSizeInPoints.height ? 0 | 24 * (this._winSizeInPoints.height / 320) : 0 | 24 * (this._winSizeInPoints.width /
                320);
        this._FPSLabel = new cc.LabelTTF("000.0", "Arial", a);
        this._SPFLabel = new cc.LabelTTF("0.000", "Arial", a);
        this._drawsLabel = new cc.LabelTTF("0000", "Arial", a);
        a = cc.DIRECTOR_STATS_POSITION;
        this._drawsLabel.setPosition(this._drawsLabel.width / 2 + a.x, 5 * this._drawsLabel.height / 2 + a.y);
        this._SPFLabel.setPosition(this._SPFLabel.width / 2 + a.x, 3 * this._SPFLabel.height / 2 + a.y);
        this._FPSLabel.setPosition(this._FPSLabel.width / 2 + a.x, this._FPSLabel.height / 2 + a.y)
    };
    a.convertToGL = function(a) {
        var d = new cc.math.Matrix4;
        cc.GLToClipTransform(d);
        var e = d.inverse(),
            d = d.mat[14] / d.mat[15],
            f = this._openGLView.getDesignResolutionSize();
        a = new cc.math.Vec3(2 * a.x / f.width - 1, 1 - 2 * a.y / f.height, d);
        a.transformCoord(e);
        return cc.p(a.x, a.y)
    };
    a.convertToUI = function(a) {
        var d = new cc.math.Matrix4;
        cc.GLToClipTransform(d);
        a = new cc.math.Vec3(a.x, a.y, 0);
        a.transformCoord(d);
        d = this._openGLView.getDesignResolutionSize();
        return cc.p(d.width * (0.5 * a.x + 0.5), d.height * (0.5 * -a.y + 0.5))
    };
    a.getVisibleSize = function() {
        return this._openGLView.getVisibleSize()
    };
    a.getVisibleOrigin =
        function() {
            return this._openGLView.getVisibleOrigin()
        };
    a.getZEye = function() {
        return this._winSizeInPoints.height / 1.1566
    };
    a.setViewport = function() {
        var a = this._openGLView;
        if (a) {
            var d = this._winSizeInPoints;
            a.setViewPortInPoints(-a._viewPortRect.x / a._scaleX, -a._viewPortRect.y / a._scaleY, d.width, d.height)
        }
    };
    a.getOpenGLView = function() {
        return this._openGLView
    };
    a.getProjection = function() {
        return this._projection
    };
    a.setAlphaBlending = function(a) {
        a ? cc.glBlendFunc(cc.BLEND_SRC, cc.BLEND_DST) : cc.glBlendFunc(cc._renderContext.ONE,
            cc._renderContext.ZERO)
    };
    a.setGLDefaultValues = function() {
        this.setAlphaBlending(!0);
        this.setDepthTest(!1);
        this.setProjection(this._projection);
        cc._renderContext.clearColor(0, 0, 0, 0)
    }
}();
cc.Camera = cc.Class.extend({
    _eyeX: null,
    _eyeY: null,
    _eyeZ: null,
    _centerX: null,
    _centerY: null,
    _centerZ: null,
    _upX: null,
    _upY: null,
    _upZ: null,
    _dirty: !1,
    _lookupMatrix: null,
    ctor: function() {
        this._lookupMatrix = new cc.math.Matrix4;
        this.restore()
    },
    description: function() {
        return "\x3cCCCamera | center \x3d(" + this._centerX + "," + this._centerY + "," + this._centerZ + ")\x3e"
    },
    setDirty: function(a) {
        this._dirty = a
    },
    isDirty: function() {
        return this._dirty
    },
    restore: function() {
        this._eyeX = this._eyeY = 0;
        this._eyeZ = cc.Camera.getZEye();
        this._upX =
            this._centerX = this._centerY = this._centerZ = 0;
        this._upY = 1;
        this._upZ = 0;
        this._lookupMatrix.identity();
        this._dirty = !1
    },
    locate: function() {
        if (this._dirty) {
            var a = new cc.math.Vec3(this._eyeX, this._eyeY, this._eyeZ),
                b = new cc.math.Vec3(this._centerX, this._centerY, this._centerZ),
                d = new cc.math.Vec3(this._upX, this._upY, this._upZ);
            this._lookupMatrix.lookAt(a, b, d);
            this._dirty = !1
        }
        cc.kmGLMultMatrix(this._lookupMatrix)
    },
    _locateForRenderer: function(a) {
        if (this._dirty) {
            var b = new cc.math.Vec3(this._eyeX, this._eyeY, this._eyeZ),
                d = new cc.math.Vec3(this._centerX, this._centerY, this._centerZ),
                e = new cc.math.Vec3(this._upX, this._upY, this._upZ);
            this._lookupMatrix.lookAt(b, d, e);
            this._dirty = !1
        }
        a.multiply(this._lookupMatrix)
    },
    setEyeXYZ: function(a, b, d) {
        this.setEye(a, b, d)
    },
    setEye: function(a, b, d) {
        this._eyeX = a;
        this._eyeY = b;
        this._eyeZ = d;
        this._dirty = !0
    },
    setCenterXYZ: function(a, b, d) {
        this.setCenter(a, b, d)
    },
    setCenter: function(a, b, d) {
        this._centerX = a;
        this._centerY = b;
        this._centerZ = d;
        this._dirty = !0
    },
    setUpXYZ: function(a, b, d) {
        this.setUp(a, b, d)
    },
    setUp: function(a, b, d) {
        this._upX = a;
        this._upY = b;
        this._upZ = d;
        this._dirty = !0
    },
    getEyeXYZ: function(a, b, d) {
        return {
            x: this._eyeX,
            y: this._eyeY,
            z: this._eyeZ
        }
    },
    getEye: function() {
        return {
            x: this._eyeX,
            y: this._eyeY,
            z: this._eyeZ
        }
    },
    getCenterXYZ: function(a, b, d) {
        return {
            x: this._centerX,
            y: this._centerY,
            z: this._centerZ
        }
    },
    getCenter: function() {
        return {
            x: this._centerX,
            y: this._centerY,
            z: this._centerZ
        }
    },
    getUpXYZ: function(a, b, d) {
        return {
            x: this._upX,
            y: this._upY,
            z: this._upZ
        }
    },
    getUp: function() {
        return {
            x: this._upX,
            y: this._upY,
            z: this._upZ
        }
    },
    _DISALLOW_COPY_AND_ASSIGN: function(a) {}
});
cc.Camera.getZEye = function() {
    return cc.FLT_EPSILON
};
cc.PRIORITY_NON_SYSTEM = cc.PRIORITY_SYSTEM + 1;
cc.ListEntry = function(a, b, d, e, f, g, h) {
    this.prev = a;
    this.next = b;
    this.callback = d;
    this.target = e;
    this.priority = f;
    this.paused = g;
    this.markedForDeletion = h
};
cc.HashUpdateEntry = function(a, b, d, e, f) {
    this.list = a;
    this.entry = b;
    this.target = d;
    this.callback = e;
    this.hh = f
};
cc.HashTimerEntry = cc.hashSelectorEntry = function(a, b, d, e, f, g, h) {
    this.timers = a;
    this.target = b;
    this.timerIndex = d;
    this.currentTimer = e;
    this.currentTimerSalvaged = f;
    this.paused = g;
    this.hh = h
};
cc.Timer = cc.Class.extend({
    _scheduler: null,
    _elapsed: 0,
    _runForever: !1,
    _useDelay: !1,
    _timesExecuted: 0,
    _repeat: 0,
    _delay: 0,
    _interval: 0,
    getInterval: function() {
        return this._interval
    },
    setInterval: function(a) {
        this._interval = a
    },
    setupTimerWithInterval: function(a, b, d) {
        this._elapsed = -1;
        this._interval = a;
        this._delay = d;
        this._useDelay = 0 < this._delay;
        this._repeat = b;
        this._runForever = this._repeat === cc.REPEAT_FOREVER
    },
    trigger: function() {
        return 0
    },
    cancel: function() {
        return 0
    },
    ctor: function() {
        this._scheduler = null;
        this._elapsed = -1;
        this._useDelay = this._runForever = !1;
        this._interval = this._delay = this._repeat = this._timesExecuted = 0
    },
    update: function(a) {
        -1 === this._elapsed ? this._timesExecuted = this._elapsed = 0 : (this._elapsed += a, this._runForever && !this._useDelay ? this._elapsed >= this._interval && (this.trigger(), this._elapsed = 0) : (this._useDelay ? this._elapsed >= this._delay && (this.trigger(), this._elapsed -= this._delay, this._timesExecuted += 1, this._useDelay = !1) : this._elapsed >= this._interval && (this.trigger(), this._elapsed = 0, this._timesExecuted +=
            1), !this._runForever && this._timesExecuted > this._repeat && this.cancel()))
    }
});
cc.TimerTargetSelector = cc.Timer.extend({
    _target: null,
    _selector: null,
    ctor: function() {
        this._selector = this._target = null
    },
    initWithSelector: function(a, b, d, e, f, g) {
        this._scheduler = a;
        this._target = d;
        this._selector = b;
        this.setupTimerWithInterval(e, f, g);
        return !0
    },
    getSelector: function() {
        return this._selector
    },
    trigger: function() {
        this._target && this._selector && this._target.call(this._selector, this._elapsed)
    },
    cancel: function() {
        this._scheduler.unschedule(this._selector, this._target)
    }
});
cc.TimerTargetCallback = cc.Timer.extend({
    _target: null,
    _callback: null,
    _key: null,
    ctor: function() {
        this._callback = this._target = null
    },
    initWithCallback: function(a, b, d, e, f, g, h) {
        this._scheduler = a;
        this._target = d;
        this._callback = b;
        this._key = e;
        this.setupTimerWithInterval(f, g, h);
        return !0
    },
    getCallback: function() {
        return this._callback
    },
    getKey: function() {
        return this._key
    },
    trigger: function() {
        this._callback && this._callback.call(this._target, this._elapsed)
    },
    cancel: function() {
        this._scheduler.unschedule(this._callback,
            this._target)
    }
});
cc.Scheduler = cc.Class.extend({
    _timeScale: 1,
    _updatesNegList: null,
    _updates0List: null,
    _updatesPosList: null,
    _hashForTimers: null,
    _arrayForTimers: null,
    _hashForUpdates: null,
    _currentTarget: null,
    _currentTargetSalvaged: !1,
    _updateHashLocked: !1,
    ctor: function() {
        this._timeScale = 1;
        this._updatesNegList = [];
        this._updates0List = [];
        this._updatesPosList = [];
        this._hashForUpdates = {};
        this._hashForTimers = {};
        this._currentTarget = null;
        this._updateHashLocked = this._currentTargetSalvaged = !1;
        this._arrayForTimers = []
    },
    _schedulePerFrame: function(a,
        b, d, e) {
        var f = this._hashForUpdates[b.__instanceId];
        if (f && f.entry)
            if (f.entry.priority !== d) {
                if (this._updateHashLocked) {
                    cc.log("warning: you CANNOT change update priority in scheduled function");
                    f.entry.markedForDeletion = !1;
                    f.entry.paused = e;
                    return
                }
                this.unscheduleUpdate(b)
            } else {
                f.entry.markedForDeletion = !1;
                f.entry.paused = e;
                return
            }
        0 === d ? this._appendIn(this._updates0List, a, b, e) : 0 > d ? this._priorityIn(this._updatesNegList, a, b, d, e) : this._priorityIn(this._updatesPosList, a, b, d, e)
    },
    _removeHashElement: function(a) {
        delete this._hashForTimers[a.target.__instanceId];
        cc.arrayRemoveObject(this._arrayForTimers, a);
        a.Timer = null;
        a.target = null
    },
    _removeUpdateFromHash: function(a) {
        if (a = this._hashForUpdates[a.target.__instanceId]) cc.arrayRemoveObject(a.list, a.entry), delete this._hashForUpdates[a.target.__instanceId], a.entry = null, a.target = null
    },
    _priorityIn: function(a, b, d, e, f) {
        b = new cc.ListEntry(null, null, b, d, e, f, !1);
        if (a) {
            f = a.length - 1;
            for (var g = 0; g <= f && !(e < a[g].priority); g++);
            a.splice(g, 0, b)
        } else a = [], a.push(b);
        this._hashForUpdates[d.__instanceId] = new cc.HashUpdateEntry(a,
            b, d, null);
        return a
    },
    _appendIn: function(a, b, d, e) {
        b = new cc.ListEntry(null, null, b, d, 0, e, !1);
        a.push(b);
        this._hashForUpdates[d.__instanceId] = new cc.HashUpdateEntry(a, b, d, null, null)
    },
    setTimeScale: function(a) {
        this._timeScale = a
    },
    getTimeScale: function() {
        return this._timeScale
    },
    update: function(a) {
        this._updateHashLocked = !0;
        1 !== this._timeScale && (a *= this._timeScale);
        var b, d, e, f;
        b = 0;
        d = this._updatesNegList;
        for (e = d.length; b < e; b++) f = d[b], !f.paused && !f.markedForDeletion && f.callback(a);
        b = 0;
        d = this._updates0List;
        for (e =
            d.length; b < e; b++) f = d[b], !f.paused && !f.markedForDeletion && f.callback(a);
        b = 0;
        d = this._updatesPosList;
        for (e = d.length; b < e; b++) f = d[b], !f.paused && !f.markedForDeletion && f.callback(a);
        e = this._arrayForTimers;
        for (b = 0; b < e.length; b++) {
            this._currentTarget = d = e[b];
            this._currentTargetSalvaged = !1;
            if (!d.paused)
                for (d.timerIndex = 0; d.timerIndex < d.timers.length; ++d.timerIndex) d.currentTimer = d.timers[d.timerIndex], d.currentTimerSalvaged = !1, d.currentTimer.update(a), d.currentTimer = null;
            this._currentTargetSalvaged && 0 === this._currentTarget.timers.length &&
                this._removeHashElement(this._currentTarget)
        }
        b = 0;
        for (d = this._updatesNegList; b < d.length;) f = d[b], f.markedForDeletion ? this._removeUpdateFromHash(f) : b++;
        b = 0;
        for (d = this._updates0List; b < d.length;) f = d[b], f.markedForDeletion ? this._removeUpdateFromHash(f) : b++;
        b = 0;
        for (d = this._updatesPosList; b < d.length;) f = d[b], f.markedForDeletion ? this._removeUpdateFromHash(f) : b++;
        this._updateHashLocked = !1;
        this._currentTarget = null
    },
    scheduleCallbackForTarget: function(a, b, d, e, f, g) {
        this.schedule(b, a, d, e, f, g, a.__instanceId + "")
    },
    schedule: function(a, b, d, e, f, g, h) {
        var k = !1;
        if ("function" !== typeof a) var m = a,
            k = !0;
        !1 === k ? 5 === arguments.length && (h = f, g = e, f = 0, e = cc.REPEAT_FOREVER) : 4 === arguments.length && (g = e, e = cc.REPEAT_FOREVER, f = 0);
        cc.assert(b, cc._LogInfos.Scheduler_scheduleCallbackForTarget_3);
        !1 === k && cc.assert(h, "key should not be empty!");
        var n = this._hashForTimers[b.__instanceId];
        n ? cc.assert(n.paused === g, "") : (n = new cc.HashTimerEntry(null, b, 0, null, null, g, null), this._arrayForTimers.push(n), this._hashForTimers[b.__instanceId] = n);
        var p,
            r;
        if (null == n.timers) n.timers = [];
        else if (!1 === k)
            for (r = 0; r < n.timers.length; r++) {
                if (p = n.timers[r], a === p._callback) {
                    cc.log(cc._LogInfos.Scheduler_scheduleCallbackForTarget, p.getInterval().toFixed(4), d.toFixed(4));
                    p._interval = d;
                    return
                }
            } else
                for (r = 0; r < n.timers.length; ++r)
                    if ((p = n.timers[r]) && m === p.getSelector()) {
                        cc.log("CCScheduler#scheduleSelector. Selector already scheduled. Updating interval from: %.4f to %.4f", p.getInterval(), d);
                        p.setInterval(d);
                        return
                    }!1 === k ? (p = new cc.TimerTargetCallback, p.initWithCallback(this,
            a, b, h, d, e, f)) : (p = new cc.TimerTargetSelector, p.initWithSelector(this, m, b, d, e, f));
        n.timers.push(p)
    },
    scheduleUpdate: function(a, b, d) {
        this._schedulePerFrame(function(d) {
            a.update(d)
        }, a, b, d)
    },
    _getUnscheduleMark: function(a, b) {
        switch (typeof a) {
            case "number":
            case "string":
                return a === b.getKey();
            case "function":
                return a === b._callback;
            default:
                return a === b.getSelector()
        }
    },
    unschedule: function(a, b) {
        if (b && a) {
            var d = this._hashForTimers[b.__instanceId];
            if (d)
                for (var e = d.timers, f = 0, g = e.length; f < g; f++) {
                    var h = e[f];
                    if (this._getUnscheduleMark(a,
                        h)) {
                        h === d.currentTimer && !d.currentTimerSalvaged && (d.currentTimerSalvaged = !0);
                        e.splice(f, 1);
                        d.timerIndex >= f && d.timerIndex--;
                        0 === e.length && (this._currentTarget === d ? this._currentTargetSalvaged = !0 : this._removeHashElement(d));
                        break
                    }
                }
        }
    },
    unscheduleUpdate: function(a) {
        if (null != a && (a = this._hashForUpdates[a.__instanceId])) this._updateHashLocked ? a.entry.markedForDeletion = !0 : this._removeUpdateFromHash(a.entry)
    },
    unscheduleAllForTarget: function(a) {
        if (null != a) {
            var b = this._hashForTimers[a.__instanceId];
            b && (-1 < b.timers.indexOf(b.currentTimer) &&
                !b.currentTimerSalvaged && (b.currentTimerSalvaged = !0), b.timers.length = 0, this._currentTarget === b ? this._currentTargetSalvaged = !0 : this._removeHashElement(b));
            this.unscheduleUpdate(a)
        }
    },
    unscheduleAll: function() {
        this.unscheduleAllWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM)
    },
    unscheduleAllWithMinPriority: function(a) {
        var b, d, e = this._arrayForTimers;
        for (b = e.length - 1; 0 <= b; b--) d = e[b], this.unscheduleAllForTarget(d.target);
        e = 0;
        if (0 > a)
            for (b = 0; b < this._updatesNegList.length;) e = this._updatesNegList.length, (d = this._updatesNegList[b]) &&
                d.priority >= a && this.unscheduleUpdate(d.target), e == this._updatesNegList.length && b++;
        if (0 >= a)
            for (b = 0; b < this._updates0List.length;) e = this._updates0List.length, (d = this._updates0List[b]) && this.unscheduleUpdate(d.target), e == this._updates0List.length && b++;
        for (b = 0; b < this._updatesPosList.length;) e = this._updatesPosList.length, (d = this._updatesPosList[b]) && d.priority >= a && this.unscheduleUpdate(d.target), e == this._updatesPosList.length && b++
    },
    isScheduled: function(a, b) {
        cc.assert(a, "Argument key must not be empty");
        cc.assert(b, "Argument target must be non-nullptr");
        var d = this._hashForUpdates[b.__instanceId];
        if (!d) return !1;
        if (null != d.timers)
            for (var d = d.timers, e = 0; e < d.length; ++e)
                if (a === d[e].getKey()) return !0;
        return !1
    },
    pauseAllTargets: function() {
        return this.pauseAllTargetsWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM)
    },
    pauseAllTargetsWithMinPriority: function(a) {
        var b = [],
            d, e = this._arrayForTimers,
            f, g;
        f = 0;
        for (g = e.length; f < g; f++)
            if (d = e[f]) d.paused = !0, b.push(d.target);
        if (0 > a)
            for (f = 0; f < this._updatesNegList.length; f++)
                if ((d =
                    this._updatesNegList[f]) && d.priority >= a) d.paused = !0, b.push(d.target);
        if (0 >= a)
            for (f = 0; f < this._updates0List.length; f++)
                if (d = this._updates0List[f]) d.paused = !0, b.push(d.target);
        for (f = 0; f < this._updatesPosList.length; f++)
            if ((d = this._updatesPosList[f]) && d.priority >= a) d.paused = !0, b.push(d.target);
        return b
    },
    resumeTargets: function(a) {
        if (a)
            for (var b = 0; b < a.length; b++) this.resumeTarget(a[b])
    },
    pauseTarget: function(a) {
        cc.assert(a, cc._LogInfos.Scheduler_pauseTarget);
        var b = this._hashForTimers[a.__instanceId];
        b && (b.paused = !0);
        if (a = this._hashForUpdates[a.__instanceId]) a.entry.paused = !0
    },
    resumeTarget: function(a) {
        cc.assert(a, cc._LogInfos.Scheduler_resumeTarget);
        var b = this._hashForTimers[a.__instanceId];
        b && (b.paused = !1);
        if (a = this._hashForUpdates[a.__instanceId]) a.entry.paused = !1
    },
    isTargetPaused: function(a) {
        cc.assert(a, cc._LogInfos.Scheduler_isTargetPaused);
        var b = this._hashForTimers[a.__instanceId];
        return b ? b.paused : (a = this._hashForUpdates[a.__instanceId]) ? a.entry.paused : !1
    },
    scheduleUpdateForTarget: function(a, b, d) {
        this.scheduleUpdate(a,
            b, d)
    },
    unscheduleCallbackForTarget: function(a, b) {
        this.unschedule(b, a)
    },
    unscheduleUpdateForTarget: function(a) {
        this.unscheduleUpdate(a)
    },
    unscheduleAllCallbacksForTarget: function(a) {
        this.unschedule(a.__instanceId + "", a)
    },
    unscheduleAllCallbacks: function() {
        this.unscheduleAllWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM)
    },
    unscheduleAllCallbacksWithMinPriority: function(a) {
        this.unscheduleAllWithMinPriority(a)
    }
});
cc.Scheduler.PRIORITY_SYSTEM = -2147483648;
cc.PI2 = 2 * Math.PI;
cc.DrawingPrimitiveCanvas = cc.Class.extend({
    _cacheArray: [],
    _renderContext: null,
    ctor: function(a) {
        this._renderContext = a
    },
    drawPoint: function(a, b) {
        b || (b = 1);
        var d = cc.view.getScaleX(),
            e = cc.view.getScaleY(),
            e = cc.p(a.x * d, a.y * e),
            f = this._renderContext.getContext();
        f.beginPath();
        f.arc(e.x, -e.y, b * d, 0, 2 * Math.PI, !1);
        f.closePath();
        f.fill()
    },
    drawPoints: function(a, b, d) {
        if (null != a) {
            d || (d = 1);
            b = this._renderContext.getContext();
            var e = cc.view.getScaleX(),
                f = cc.view.getScaleY();
            b.beginPath();
            for (var g = 0, h = a.length; g < h; g++) b.arc(a[g].x *
                e, -a[g].y * f, d * e, 0, 2 * Math.PI, !1);
            b.closePath();
            b.fill()
        }
    },
    drawLine: function(a, b) {
        var d = this._renderContext.getContext(),
            e = cc.view.getScaleX(),
            f = cc.view.getScaleY();
        d.beginPath();
        d.moveTo(a.x * e, -a.y * f);
        d.lineTo(b.x * e, -b.y * f);
        d.closePath();
        d.stroke()
    },
    drawRect: function(a, b) {
        this.drawLine(cc.p(a.x, a.y), cc.p(b.x, a.y));
        this.drawLine(cc.p(b.x, a.y), cc.p(b.x, b.y));
        this.drawLine(cc.p(b.x, b.y), cc.p(a.x, b.y));
        this.drawLine(cc.p(a.x, b.y), cc.p(a.x, a.y))
    },
    drawSolidRect: function(a, b, d) {
        a = [a, cc.p(b.x, a.y), b, cc.p(a.x,
            b.y)];
        this.drawSolidPoly(a, 4, d)
    },
    drawPoly: function(a, b, d, e) {
        e = e || !1;
        if (null != a) {
            if (3 > a.length) throw Error("Polygon's point must greater than 2");
            var f = a[0];
            b = this._renderContext.getContext();
            var g = cc.view.getScaleX(),
                h = cc.view.getScaleY();
            b.beginPath();
            b.moveTo(f.x * g, -f.y * h);
            for (var f = 1, k = a.length; f < k; f++) b.lineTo(a[f].x * g, -a[f].y * h);
            d && b.closePath();
            e ? b.fill() : b.stroke()
        }
    },
    drawSolidPoly: function(a, b, d) {
        this.setDrawColor(d.r, d.g, d.b, d.a);
        this.drawPoly(a, b, !0, !0)
    },
    drawCircle: function(a, b, d, e, f) {
        f =
            f || !1;
        e = this._renderContext.getContext();
        var g = cc.view.getScaleX(),
            h = cc.view.getScaleY();
        e.beginPath();
        e.arc(0 | a.x * g, 0 | -(a.y * h), b * g, -d, -(d - 2 * Math.PI), !1);
        f && e.lineTo(0 | a.x * g, 0 | -(a.y * h));
        e.stroke()
    },
    drawQuadBezier: function(a, b, d, e) {
        for (var f = this._cacheArray, g = f.length = 0, h = 0; h < e; h++) {
            var k = Math.pow(1 - g, 2) * a.x + 2 * (1 - g) * g * b.x + g * g * d.x,
                m = Math.pow(1 - g, 2) * a.y + 2 * (1 - g) * g * b.y + g * g * d.y;
            f.push(cc.p(k, m));
            g += 1 / e
        }
        f.push(cc.p(d.x, d.y));
        this.drawPoly(f, e + 1, !1, !1)
    },
    drawCubicBezier: function(a, b, d, e, f) {
        for (var g = this._cacheArray,
            h = g.length = 0, k = 0; k < f; k++) {
            var m = Math.pow(1 - h, 3) * a.x + 3 * Math.pow(1 - h, 2) * h * b.x + 3 * (1 - h) * h * h * d.x + h * h * h * e.x,
                n = Math.pow(1 - h, 3) * a.y + 3 * Math.pow(1 - h, 2) * h * b.y + 3 * (1 - h) * h * h * d.y + h * h * h * e.y;
            g.push(cc.p(m, n));
            h += 1 / f
        }
        g.push(cc.p(e.x, e.y));
        this.drawPoly(g, f + 1, !1, !1)
    },
    drawCatmullRom: function(a, b) {
        this.drawCardinalSpline(a, 0.5, b)
    },
    drawCardinalSpline: function(a, b, d) {
        cc._renderContext.setStrokeStyle("rgba(255,255,255,1)");
        var e = this._cacheArray;
        e.length = 0;
        for (var f, g, h = 1 / a.length, k = 0; k < d + 1; k++) g = k / d, 1 === g ? (f = a.length - 1,
            g = 1) : (f = 0 | g / h, g = (g - h * f) / h), f = cc.CardinalSplineAt(cc.getControlPointAt(a, f - 1), cc.getControlPointAt(a, f - 0), cc.getControlPointAt(a, f + 1), cc.getControlPointAt(a, f + 2), b, g), e.push(f);
        this.drawPoly(e, d + 1, !1, !1)
    },
    drawImage: function(a, b, d, e, f) {
        var g = arguments.length,
            h = this._renderContext.getContext();
        switch (g) {
            case 2:
                h.drawImage(a, b.x, -(b.y + a.height));
                break;
            case 3:
                h.drawImage(a, b.x, -(b.y + d.height), d.width, d.height);
                break;
            case 5:
                h.drawImage(a, b.x, b.y, d.width, d.height, e.x, -(e.y + f.height), f.width, f.height);
                break;
            default:
                throw Error("Argument must be non-nil");
        }
    },
    drawStar: function(a, b, d) {
        a = a || this._renderContext;
        var e = a.getContext();
        b *= cc.view.getScaleX();
        d = "rgba(" + (0 | d.r) + "," + (0 | d.g) + "," + (0 | d.b);
        a.setFillStyle(d + ",1)");
        var f = b / 10;
        e.beginPath();
        e.moveTo(-b, b);
        e.lineTo(0, f);
        e.lineTo(b, b);
        e.lineTo(f, 0);
        e.lineTo(b, -b);
        e.lineTo(0, -f);
        e.lineTo(-b, -b);
        e.lineTo(-f, 0);
        e.lineTo(-b, b);
        e.closePath();
        e.fill();
        var g = e.createRadialGradient(0, 0, f, 0, 0, b);
        g.addColorStop(0, d + ", 1)");
        g.addColorStop(0.3, d + ", 0.8)");
        g.addColorStop(1,
            d + ", 0.0)");
        a.setFillStyle(g);
        e.beginPath();
        e.arc(0, 0, b - f, 0, cc.PI2, !1);
        e.closePath();
        e.fill()
    },
    drawColorBall: function(a, b, d) {
        a = a || this._renderContext;
        var e = a.getContext();
        b *= cc.view.getScaleX();
        d = "rgba(" + (0 | d.r) + "," + (0 | d.g) + "," + (0 | d.b);
        var f = e.createRadialGradient(0, 0, b / 10, 0, 0, b);
        f.addColorStop(0, d + ", 1)");
        f.addColorStop(0.3, d + ", 0.8)");
        f.addColorStop(0.6, d + ", 0.4)");
        f.addColorStop(1, d + ", 0.0)");
        a.setFillStyle(f);
        e.beginPath();
        e.arc(0, 0, b, 0, cc.PI2, !1);
        e.closePath();
        e.fill()
    },
    fillText: function(a, b,
        d) {
        this._renderContext.getContext().fillText(a, b, -d)
    },
    setDrawColor: function(a, b, d, e) {
        this._renderContext.setFillStyle("rgba(" + a + "," + b + "," + d + "," + e / 255 + ")");
        this._renderContext.setStrokeStyle("rgba(" + a + "," + b + "," + d + "," + e / 255 + ")")
    },
    setPointSize: function(a) {},
    setLineWidth: function(a) {
        this._renderContext.getContext().lineWidth = a * cc.view.getScaleX()
    }
});
cc.DrawingPrimitiveWebGL = cc.Class.extend({
    _renderContext: null,
    _initialized: !1,
    _shader: null,
    _colorLocation: -1,
    _colorArray: null,
    _pointSizeLocation: -1,
    _pointSize: -1,
    ctor: function(a) {
        null == a && (a = cc._renderContext);
        if (!a instanceof WebGLRenderingContext) throw Error("Can't initialise DrawingPrimitiveWebGL. context need is WebGLRenderingContext");
        this._renderContext = a;
        this._colorArray = new Float32Array([1, 1, 1, 1])
    },
    lazy_init: function() {
        this._initialized || (this._shader = cc.shaderCache.programForKey(cc.SHADER_POSITION_UCOLOR),
            this._colorLocation = this._renderContext.getUniformLocation(this._shader.getProgram(), "u_color"), this._pointSizeLocation = this._renderContext.getUniformLocation(this._shader.getProgram(), "u_pointSize"), this._initialized = !0)
    },
    drawInit: function() {
        this._initialized = !1
    },
    drawPoint: function(a) {
        this.lazy_init();
        var b = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        b.uniform4fv(this._colorLocation,
            this._colorArray);
        this._shader.setUniformLocationWith1f(this._pointSizeLocation, this._pointSize);
        var d = b.createBuffer();
        b.bindBuffer(b.ARRAY_BUFFER, d);
        b.bufferData(b.ARRAY_BUFFER, new Float32Array([a.x, a.y]), b.STATIC_DRAW);
        b.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, b.FLOAT, !1, 0, 0);
        b.drawArrays(b.POINTS, 0, 1);
        b.deleteBuffer(d);
        cc.incrementGLDraws(1)
    },
    drawPoints: function(a, b) {
        if (a && 0 !== a.length) {
            this.lazy_init();
            var d = this._renderContext;
            this._shader.use();
            this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
            d.uniform4fv(this._colorLocation, this._colorArray);
            this._shader.setUniformLocationWith1f(this._pointSizeLocation, this._pointSize);
            var e = d.createBuffer();
            d.bindBuffer(d.ARRAY_BUFFER, e);
            d.bufferData(d.ARRAY_BUFFER, this._pointsToTypeArray(a), d.STATIC_DRAW);
            d.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, d.FLOAT, !1, 0, 0);
            d.drawArrays(d.POINTS, 0, a.length);
            d.deleteBuffer(e);
            cc.incrementGLDraws(1)
        }
    },
    _pointsToTypeArray: function(a) {
        for (var b = new Float32Array(2 *
            a.length), d = 0; d < a.length; d++) b[2 * d] = a[d].x, b[2 * d + 1] = a[d].y;
        return b
    },
    drawLine: function(a, b) {
        this.lazy_init();
        var d = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        d.uniform4fv(this._colorLocation, this._colorArray);
        var e = d.createBuffer();
        d.bindBuffer(d.ARRAY_BUFFER, e);
        d.bufferData(d.ARRAY_BUFFER, this._pointsToTypeArray([a, b]), d.STATIC_DRAW);
        d.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION,
            2, d.FLOAT, !1, 0, 0);
        d.drawArrays(d.LINES, 0, 2);
        d.deleteBuffer(e);
        cc.incrementGLDraws(1)
    },
    drawRect: function(a, b) {
        this.drawLine(cc.p(a.x, a.y), cc.p(b.x, a.y));
        this.drawLine(cc.p(b.x, a.y), cc.p(b.x, b.y));
        this.drawLine(cc.p(b.x, b.y), cc.p(a.x, b.y));
        this.drawLine(cc.p(a.x, b.y), cc.p(a.x, a.y))
    },
    drawSolidRect: function(a, b, d) {
        a = [a, cc.p(b.x, a.y), b, cc.p(a.x, b.y)];
        this.drawSolidPoly(a, 4, d)
    },
    drawPoly: function(a, b, d) {
        this.lazy_init();
        b = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        b.uniform4fv(this._colorLocation, this._colorArray);
        var e = b.createBuffer();
        b.bindBuffer(b.ARRAY_BUFFER, e);
        b.bufferData(b.ARRAY_BUFFER, this._pointsToTypeArray(a), b.STATIC_DRAW);
        b.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, b.FLOAT, !1, 0, 0);
        d ? b.drawArrays(b.LINE_LOOP, 0, a.length) : b.drawArrays(b.LINE_STRIP, 0, a.length);
        b.deleteBuffer(e);
        cc.incrementGLDraws(1)
    },
    drawSolidPoly: function(a, b, d) {
        this.lazy_init();
        d && this.setDrawColor(d.r, d.g, d.b, d.a);
        b = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        b.uniform4fv(this._colorLocation, this._colorArray);
        d = b.createBuffer();
        b.bindBuffer(b.ARRAY_BUFFER, d);
        b.bufferData(b.ARRAY_BUFFER, this._pointsToTypeArray(a), b.STATIC_DRAW);
        b.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, b.FLOAT, !1, 0, 0);
        b.drawArrays(b.TRIANGLE_FAN, 0, a.length);
        b.deleteBuffer(d);
        cc.incrementGLDraws(1)
    },
    drawCircle: function(a,
        b, d, e, f) {
        this.lazy_init();
        var g = 1;
        f && g++;
        var h = 2 * Math.PI / e;
        if (f = new Float32Array(2 * (e + 2))) {
            for (var k = 0; k <= e; k++) {
                var m = k * h,
                    n = b * Math.cos(m + d) + a.x,
                    m = b * Math.sin(m + d) + a.y;
                f[2 * k] = n;
                f[2 * k + 1] = m
            }
            f[2 * (e + 1)] = a.x;
            f[2 * (e + 1) + 1] = a.y;
            a = this._renderContext;
            this._shader.use();
            this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
            a.uniform4fv(this._colorLocation, this._colorArray);
            b = a.createBuffer();
            a.bindBuffer(a.ARRAY_BUFFER, b);
            a.bufferData(a.ARRAY_BUFFER,
                f, a.STATIC_DRAW);
            a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
            a.drawArrays(a.LINE_STRIP, 0, e + g);
            a.deleteBuffer(b);
            cc.incrementGLDraws(1)
        }
    },
    drawQuadBezier: function(a, b, d, e) {
        this.lazy_init();
        for (var f = new Float32Array(2 * (e + 1)), g = 0, h = 0; h < e; h++) f[2 * h] = Math.pow(1 - g, 2) * a.x + 2 * (1 - g) * g * b.x + g * g * d.x, f[2 * h + 1] = Math.pow(1 - g, 2) * a.y + 2 * (1 - g) * g * b.y + g * g * d.y, g += 1 / e;
        f[2 * e] = d.x;
        f[2 * e + 1] = d.y;
        a = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        a.uniform4fv(this._colorLocation, this._colorArray);
        b = a.createBuffer();
        a.bindBuffer(a.ARRAY_BUFFER, b);
        a.bufferData(a.ARRAY_BUFFER, f, a.STATIC_DRAW);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
        a.drawArrays(a.LINE_STRIP, 0, e + 1);
        a.deleteBuffer(b);
        cc.incrementGLDraws(1)
    },
    drawCubicBezier: function(a, b, d, e, f) {
        this.lazy_init();
        for (var g = new Float32Array(2 * (f + 1)), h = 0, k = 0; k < f; k++) g[2 * k] = Math.pow(1 - h, 3) * a.x + 3 * Math.pow(1 - h, 2) * h * b.x + 3 * (1 - h) * h * h * d.x + h * h * h * e.x, g[2 * k + 1] = Math.pow(1 - h, 3) * a.y + 3 * Math.pow(1 -
            h, 2) * h * b.y + 3 * (1 - h) * h * h * d.y + h * h * h * e.y, h += 1 / f;
        g[2 * f] = e.x;
        g[2 * f + 1] = e.y;
        a = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        a.uniform4fv(this._colorLocation, this._colorArray);
        b = a.createBuffer();
        a.bindBuffer(a.ARRAY_BUFFER, b);
        a.bufferData(a.ARRAY_BUFFER, g, a.STATIC_DRAW);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
        a.drawArrays(a.LINE_STRIP, 0, f + 1);
        a.deleteBuffer(b);
        cc.incrementGLDraws(1)
    },
    drawCatmullRom: function(a, b) {
        this.drawCardinalSpline(a, 0.5, b)
    },
    drawCardinalSpline: function(a, b, d) {
        this.lazy_init();
        for (var e = new Float32Array(2 * (d + 1)), f, g, h = 1 / a.length, k = 0; k < d + 1; k++) g = k / d, 1 === g ? (f = a.length - 1, g = 1) : (f = 0 | g / h, g = (g - h * f) / h), f = cc.cardinalSplineAt(cc.getControlPointAt(a, f - 1), cc.getControlPointAt(a, f), cc.getControlPointAt(a, f + 1), cc.getControlPointAt(a, f + 2), b, g), e[2 * k] = f.x, e[2 * k + 1] = f.y;
        a = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        a.uniform4fv(this._colorLocation, this._colorArray);
        b = a.createBuffer();
        a.bindBuffer(a.ARRAY_BUFFER, b);
        a.bufferData(a.ARRAY_BUFFER, e, a.STATIC_DRAW);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
        a.drawArrays(a.LINE_STRIP, 0, d + 1);
        a.deleteBuffer(b);
        cc.incrementGLDraws(1)
    },
    setDrawColor: function(a, b, d, e) {
        this._colorArray[0] = a / 255;
        this._colorArray[1] = b / 255;
        this._colorArray[2] = d / 255;
        this._colorArray[3] = e / 255
    },
    setPointSize: function(a) {
        this._pointSize =
            a * cc.contentScaleFactor()
    },
    setLineWidth: function(a) {
        this._renderContext.lineWidth && this._renderContext.lineWidth(a)
    }
});
cc._tmp.PrototypeLabelTTF = function() {
    var a = cc.LabelTTF.prototype;
    cc.defineGetterSetter(a, "color", a.getColor, a.setColor);
    cc.defineGetterSetter(a, "opacity", a.getOpacity, a.setOpacity);
    cc.defineGetterSetter(a, "string", a.getString, a.setString);
    cc.defineGetterSetter(a, "textAlign", a.getHorizontalAlignment, a.setHorizontalAlignment);
    cc.defineGetterSetter(a, "verticalAlign", a.getVerticalAlignment, a.setVerticalAlignment);
    cc.defineGetterSetter(a, "fontSize", a.getFontSize, a.setFontSize);
    cc.defineGetterSetter(a,
        "fontName", a.getFontName, a.setFontName);
    cc.defineGetterSetter(a, "font", a._getFont, a._setFont);
    cc.defineGetterSetter(a, "boundingWidth", a._getBoundingWidth, a._setBoundingWidth);
    cc.defineGetterSetter(a, "boundingHeight", a._getBoundingHeight, a._setBoundingHeight);
    cc.defineGetterSetter(a, "fillStyle", a._getFillStyle, a.setFontFillColor);
    cc.defineGetterSetter(a, "strokeStyle", a._getStrokeStyle, a._setStrokeStyle);
    cc.defineGetterSetter(a, "lineWidth", a._getLineWidth, a._setLineWidth);
    cc.defineGetterSetter(a, "shadowOffsetX",
        a._getShadowOffsetX, a._setShadowOffsetX);
    cc.defineGetterSetter(a, "shadowOffsetY", a._getShadowOffsetY, a._setShadowOffsetY);
    cc.defineGetterSetter(a, "shadowOpacity", a._getShadowOpacity, a._setShadowOpacity);
    cc.defineGetterSetter(a, "shadowBlur", a._getShadowBlur, a._setShadowBlur)
};
cc.LabelTTF = cc.Sprite.extend({
    _dimensions: null,
    _hAlignment: cc.TEXT_ALIGNMENT_CENTER,
    _vAlignment: cc.VERTICAL_TEXT_ALIGNMENT_TOP,
    _fontName: null,
    _fontSize: 0,
    _string: "",
    _originalText: null,
    _shadowEnabled: !1,
    _shadowOffset: null,
    _shadowOpacity: 0,
    _shadowBlur: 0,
    _shadowColor: null,
    _strokeEnabled: !1,
    _strokeColor: null,
    _strokeSize: 0,
    _textFillColor: null,
    _strokeShadowOffsetX: 0,
    _strokeShadowOffsetY: 0,
    _needUpdateTexture: !1,
    _lineWidths: null,
    _className: "LabelTTF",
    _fontStyle: "normal",
    _fontWeight: "normal",
    _lineHeight: "normal",
    initWithString: function(a, b, d, e, f, g) {
        a = a ? a + "" : "";
        d = d || 16;
        e = e || cc.size(0, 0);
        f = f || cc.TEXT_ALIGNMENT_LEFT;
        g = g || cc.VERTICAL_TEXT_ALIGNMENT_TOP;
        this._opacityModifyRGB = !1;
        this._dimensions = cc.size(e.width, e.height);
        this._fontName = b || "Arial";
        this._hAlignment = f;
        this._vAlignment = g;
        this._fontSize = d;
        this._renderCmd._setFontStyle(this._fontName, d, this._fontStyle, this._fontWeight);
        this.string = a;
        this._renderCmd._setColorsString();
        this._renderCmd._updateTexture();
        this._setUpdateTextureDirty();
        return !0
    },
    _setUpdateTextureDirty: function() {
        this._needUpdateTexture = !0;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.textDirty)
    },
    ctor: function(a, b, d, e, f, g) {
        cc.Sprite.prototype.ctor.call(this);
        this._dimensions = cc.size(0, 0);
        this._hAlignment = cc.TEXT_ALIGNMENT_LEFT;
        this._vAlignment = cc.VERTICAL_TEXT_ALIGNMENT_TOP;
        this._opacityModifyRGB = !1;
        this._fontName = "Arial";
        this._shadowEnabled = !1;
        this._shadowOffset = cc.p(0, 0);
        this._shadowBlur = this._shadowOpacity = 0;
        this._strokeEnabled = !1;
        this._strokeColor = cc.color(255, 255, 255, 255);
        this._strokeSize = 0;
        this._textFillColor = cc.color(255,
            255, 255, 255);
        this._strokeShadowOffsetY = this._strokeShadowOffsetX = 0;
        this._needUpdateTexture = !1;
        this._lineWidths = [];
        this._renderCmd._setColorsString();
        this._textureLoaded = !0;
        b && b instanceof cc.FontDefinition ? this.initWithStringAndTextDefinition(a, b) : cc.LabelTTF.prototype.initWithString.call(this, a, b, d, e, f, g)
    },
    init: function() {
        return this.initWithString(" ", this._fontName, this._fontSize)
    },
    description: function() {
        return "\x3ccc.LabelTTF | FontName \x3d" + this._fontName + " FontSize \x3d " + this._fontSize.toFixed(1) +
            "\x3e"
    },
    getLineHeight: function() {
        return !this._lineHeight || this._lineHeight.charAt ? this._renderCmd._getFontClientHeight() : this._lineHeight || this._renderCmd._getFontClientHeight()
    },
    setLineHeight: function(a) {
        this._lineHeight = a
    },
    getString: function() {
        return this._string
    },
    getHorizontalAlignment: function() {
        return this._hAlignment
    },
    getVerticalAlignment: function() {
        return this._vAlignment
    },
    getDimensions: function() {
        return cc.size(this._dimensions)
    },
    getFontSize: function() {
        return this._fontSize
    },
    getFontName: function() {
        return this._fontName
    },
    initWithStringAndTextDefinition: function(a, b) {
        this._updateWithTextDefinition(b, !1);
        this.string = a;
        return !0
    },
    setTextDefinition: function(a) {
        a && this._updateWithTextDefinition(a, !0)
    },
    getTextDefinition: function() {
        return this._prepareTextDefinition(!1)
    },
    enableShadow: function(a, b, d, e) {
        null != a.r && null != a.g && null != a.b && null != a.a ? this._enableShadow(a, b, d) : this._enableShadowNoneColor(a, b, d, e)
    },
    _enableShadowNoneColor: function(a, b, d, e) {
        d = d || 0.5;
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        var f = this._shadowOffset;
        if (f && f.x !== a || f._y !== b) f.x = a, f.y = b;
        this._shadowOpacity !== d && (this._shadowOpacity = d);
        this._renderCmd._setColorsString();
        this._shadowBlur !== e && (this._shadowBlur = e);
        this._setUpdateTextureDirty()
    },
    _enableShadow: function(a, b, d) {
        this._shadowColor || (this._shadowColor = cc.color(255, 255, 255, 128));
        this._shadowColor.r = a.r;
        this._shadowColor.g = a.g;
        this._shadowColor.b = a.b;
        this._enableShadowNoneColor(b.width || b.x || 0, b.height || b.y || 0, null != a.a ? a.a / 255 : 0.5, d)
    },
    _getShadowOffsetX: function() {
        return this._shadowOffset.x
    },
    _setShadowOffsetX: function(a) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        this._shadowOffset.x !== a && (this._shadowOffset.x = a, this._setUpdateTextureDirty())
    },
    _getShadowOffsetY: function() {
        return this._shadowOffset._y
    },
    _setShadowOffsetY: function(a) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        this._shadowOffset._y !== a && (this._shadowOffset._y = a, this._setUpdateTextureDirty())
    },
    _getShadowOffset: function() {
        return cc.p(this._shadowOffset.x, this._shadowOffset.y)
    },
    _setShadowOffset: function(a) {
        !1 ===
            this._shadowEnabled && (this._shadowEnabled = !0);
        if (this._shadowOffset.x !== a.x || this._shadowOffset.y !== a.y) this._shadowOffset.x = a.x, this._shadowOffset.y = a.y, this._setUpdateTextureDirty()
    },
    _getShadowOpacity: function() {
        return this._shadowOpacity
    },
    _setShadowOpacity: function(a) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        this._shadowOpacity !== a && (this._shadowOpacity = a, this._renderCmd._setColorsString(), this._setUpdateTextureDirty())
    },
    _getShadowBlur: function() {
        return this._shadowBlur
    },
    _setShadowBlur: function(a) {
        !1 ===
            this._shadowEnabled && (this._shadowEnabled = !0);
        this._shadowBlur !== a && (this._shadowBlur = a, this._setUpdateTextureDirty())
    },
    disableShadow: function() {
        this._shadowEnabled && (this._shadowEnabled = !1, this._setUpdateTextureDirty())
    },
    enableStroke: function(a, b) {
        !1 === this._strokeEnabled && (this._strokeEnabled = !0);
        var d = this._strokeColor;
        if (d.r !== a.r || d.g !== a.g || d.b !== a.b) d.r = a.r, d.g = a.g, d.b = a.b, this._renderCmd._setColorsString();
        this._strokeSize !== b && (this._strokeSize = b || 0);
        this._setUpdateTextureDirty()
    },
    _getStrokeStyle: function() {
        return this._strokeColor
    },
    _setStrokeStyle: function(a) {
        !1 === this._strokeEnabled && (this._strokeEnabled = !0);
        var b = this._strokeColor;
        if (b.r !== a.r || b.g !== a.g || b.b !== a.b) b.r = a.r, b.g = a.g, b.b = a.b, this._renderCmd._setColorsString(), this._setUpdateTextureDirty()
    },
    _getLineWidth: function() {
        return this._strokeSize
    },
    _setLineWidth: function(a) {
        !1 === this._strokeEnabled && (this._strokeEnabled = !0);
        this._strokeSize !== a && (this._strokeSize = a || 0, this._setUpdateTextureDirty())
    },
    disableStroke: function() {
        this._strokeEnabled && (this._strokeEnabled = !1,
            this._setUpdateTextureDirty())
    },
    setFontFillColor: function(a) {
        var b = this._textFillColor;
        if (b.r !== a.r || b.g !== a.g || b.b !== a.b) b.r = a.r, b.g = a.g, b.b = a.b, this._renderCmd._setColorsString(), this._needUpdateTexture = !0
    },
    _getFillStyle: function() {
        return this._textFillColor
    },
    _updateWithTextDefinition: function(a, b) {
        a.fontDimensions ? (this._dimensions.width = a.boundingWidth, this._dimensions.height = a.boundingHeight) : (this._dimensions.width = 0, this._dimensions.height = 0);
        this._hAlignment = a.textAlign;
        this._vAlignment = a.verticalAlign;
        this._fontName = a.fontName;
        this._fontSize = a.fontSize || 12;
        this._lineHeight = a.lineHeight ? a.lineHeight : this._fontSize;
        this._renderCmd._setFontStyle(a);
        a.shadowEnabled && this.enableShadow(a.shadowOffsetX, a.shadowOffsetY, a.shadowOpacity, a.shadowBlur);
        a.strokeEnabled && this.enableStroke(a.strokeStyle, a.lineWidth);
        this.setFontFillColor(a.fillStyle);
        b && this._renderCmd._updateTexture();
        var d = cc.Node._dirtyFlags;
        this._renderCmd.setDirtyFlag(d.colorDirty | d.opacityDirty | d.textDirty)
    },
    _prepareTextDefinition: function(a) {
        var b =
            new cc.FontDefinition;
        a ? (b.fontSize = this._fontSize, b.boundingWidth = cc.contentScaleFactor() * this._dimensions.width, b.boundingHeight = cc.contentScaleFactor() * this._dimensions.height) : (b.fontSize = this._fontSize, b.boundingWidth = this._dimensions.width, b.boundingHeight = this._dimensions.height);
        b.fontName = this._fontName;
        b.textAlign = this._hAlignment;
        b.verticalAlign = this._vAlignment;
        if (this._strokeEnabled) {
            b.strokeEnabled = !0;
            var d = this._strokeColor;
            b.strokeStyle = cc.color(d.r, d.g, d.b);
            b.lineWidth = this._strokeSize
        } else b.strokeEnabled = !1;
        this._shadowEnabled ? (b.shadowEnabled = !0, b.shadowBlur = this._shadowBlur, b.shadowOpacity = this._shadowOpacity, b.shadowOffsetX = (a ? cc.contentScaleFactor() : 1) * this._shadowOffset.x, b.shadowOffsetY = (a ? cc.contentScaleFactor() : 1) * this._shadowOffset.y) : b._shadowEnabled = !1;
        a = this._textFillColor;
        b.fillStyle = cc.color(a.r, a.g, a.b);
        return b
    },
    setString: function(a) {
        a = String(a);
        this._originalText !== a && (this._originalText = a + "", this._updateString(), this._setUpdateTextureDirty(), this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty))
    },
    _updateString: function() {
        if ((!this._string || "" === this._string) && this._string !== this._originalText) cc.renderer.childrenOrderDirty = !0;
        this._string = this._originalText
    },
    setHorizontalAlignment: function(a) {
        a !== this._hAlignment && (this._hAlignment = a, this._setUpdateTextureDirty())
    },
    setVerticalAlignment: function(a) {
        a !== this._vAlignment && (this._vAlignment = a, this._setUpdateTextureDirty())
    },
    setDimensions: function(a, b) {
        var d;
        void 0 === b ? (d = a.width, b = a.height) : d = a;
        if (d !== this._dimensions.width || b !== this._dimensions.height) this._dimensions.width =
            d, this._dimensions.height = b, this._updateString(), this._setUpdateTextureDirty()
    },
    _getBoundingWidth: function() {
        return this._dimensions.width
    },
    _setBoundingWidth: function(a) {
        a !== this._dimensions.width && (this._dimensions.width = a, this._updateString(), this._setUpdateTextureDirty())
    },
    _getBoundingHeight: function() {
        return this._dimensions.height
    },
    _setBoundingHeight: function(a) {
        a !== this._dimensions.height && (this._dimensions.height = a, this._updateString(), this._setUpdateTextureDirty())
    },
    setFontSize: function(a) {
        this._fontSize !==
            a && (this._fontSize = a, this._renderCmd._setFontStyle(this._fontName, this._fontSize, this._fontStyle, this._fontWeight), this._setUpdateTextureDirty())
    },
    setFontName: function(a) {
        this._fontName && this._fontName !== a && (this._fontName = a, this._renderCmd._setFontStyle(this._fontName, this._fontSize, this._fontStyle, this._fontWeight), this._setUpdateTextureDirty())
    },
    _getFont: function() {
        return this._renderCmd._getFontStyle()
    },
    _setFont: function(a) {
        if (a = cc.LabelTTF._fontStyleRE.exec(a)) this._fontSize = parseInt(a[1]), this._fontName =
            a[2], this._renderCmd._setFontStyle(this._fontName, this._fontSize, this._fontStyle, this._fontWeight), this._setUpdateTextureDirty()
    },
    getContentSize: function() {
        this._needUpdateTexture && this._renderCmd._updateTTF();
        return cc.Sprite.prototype.getContentSize.call(this)
    },
    _getWidth: function() {
        this._needUpdateTexture && this._renderCmd._updateTTF();
        return cc.Sprite.prototype._getWidth.call(this)
    },
    _getHeight: function() {
        this._needUpdateTexture && this._renderCmd._updateTTF();
        return cc.Sprite.prototype._getHeight.call(this)
    },
    setTextureRect: function(a, b, d) {
        cc.Sprite.prototype.setTextureRect.call(this, a, b, d, !1)
    },
    _createRenderCmd: function() {
        return cc._renderType === cc._RENDER_TYPE_CANVAS ? new cc.LabelTTF.CanvasRenderCmd(this) : new cc.LabelTTF.WebGLRenderCmd(this)
    },
    _setFontStyle: function(a) {
        this._fontStyle !== a && (this._fontStyle = a, this._renderCmd._setFontStyle(this._fontName, this._fontSize, this._fontStyle, this._fontWeight), this._setUpdateTextureDirty())
    },
    _getFontStyle: function() {
        return this._fontStyle
    },
    _setFontWeight: function(a) {
        this._fontWeight !==
            a && (this._fontWeight = a, this._renderCmd._setFontStyle(this._fontName, this._fontSize, this._fontStyle, this._fontWeight), this._setUpdateTextureDirty())
    },
    _getFontWeight: function() {
        return this._fontWeight
    }
});
cc.assert(cc.isFunction(cc._tmp.PrototypeLabelTTF), cc._LogInfos.MissingFile, "LabelTTFPropertyDefine.js");
cc._tmp.PrototypeLabelTTF();
delete cc._tmp.PrototypeLabelTTF;
cc.LabelTTF._fontStyleRE = /^(\d+)px\s+['"]?([\w\s\d]+)['"]?$/;
cc.LabelTTF.create = function(a, b, d, e, f, g) {
    return new cc.LabelTTF(a, b, d, e, f, g)
};
cc.LabelTTF.createWithFontDefinition = cc.LabelTTF.create;
cc.LabelTTF._SHADER_PROGRAM = cc.USE_LA88_LABELS ? cc.SHADER_POSITION_TEXTURECOLOR : cc.SHADER_POSITION_TEXTUREA8COLOR;
cc.LabelTTF.__labelHeightDiv = cc.newElement("div");
cc.LabelTTF.__labelHeightDiv.style.fontFamily = "Arial";
cc.LabelTTF.__labelHeightDiv.style.position = "absolute";
cc.LabelTTF.__labelHeightDiv.style.left = "-100px";
cc.LabelTTF.__labelHeightDiv.style.top = "-100px";
cc.LabelTTF.__labelHeightDiv.style.lineHeight = "normal";
document.body ? document.body.appendChild(cc.LabelTTF.__labelHeightDiv) : cc._addEventListener(window, "load", function() {
    this.removeEventListener("load", arguments.callee, !1);
    document.body.appendChild(cc.LabelTTF.__labelHeightDiv)
}, !1);
cc.LabelTTF.__getFontHeightByDiv = function(a, b) {
    if (a instanceof cc.FontDefinition) {
        var d = cc.LabelTTF.__fontHeightCache[a._getCanvasFontStr()];
        if (0 < d) return d;
        var e = cc.LabelTTF.__labelHeightDiv;
        e.innerHTML = "ajghl~!";
        e.style.fontFamily = a.fontName;
        e.style.fontSize = a.fontSize + "px";
        e.style.fontStyle = a.fontStyle;
        e.style.fontWeight = a.fontWeight;
        d = e.clientHeight;
        cc.LabelTTF.__fontHeightCache[a._getCanvasFontStr()] = d;
        e.innerHTML = "";
        return d
    }
    d = cc.LabelTTF.__fontHeightCache[a + "." + b];
    if (0 < d) return d;
    e = cc.LabelTTF.__labelHeightDiv;
    e.innerHTML = "ajghl~!";
    e.style.fontFamily = a;
    e.style.fontSize = b + "px";
    d = e.clientHeight;
    cc.LabelTTF.__fontHeightCache[a + "." + b] = d;
    e.innerHTML = "";
    return d
};
cc.LabelTTF.__fontHeightCache = {};
cc.LabelTTF._textAlign = ["left", "center", "right"];
cc.LabelTTF._textBaseline = ["top", "middle", "bottom"];
cc.LabelTTF.wrapInspection = !0;
cc.LabelTTF._wordRex = /([a-zA-Z0-9\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00e9\u00e8\u00e7\u00e0\u00f9\u00ea\u00e2\u00ee\u00f4\u00fb]+|\S)/;
cc.LabelTTF._symbolRex = /^[!,.:;}\]%\?>\u3001\u2018\u201c\u300b\uff1f\u3002\uff0c\uff01]/;
cc.LabelTTF._lastWordRex = /([a-zA-Z0-9\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00e9\u00e8\u00e7\u00e0\u00f9\u00ea\u00e2\u00ee\u00f4\u00fb]+|\S)$/;
cc.LabelTTF._lastEnglish = /[a-zA-Z0-9\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00e9\u00e8\u00e7\u00e0\u00f9\u00ea\u00e2\u00ee\u00f4\u00fb]+$/;
cc.LabelTTF._firsrEnglish = /^[a-zA-Z0-9\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00e9\u00e8\u00e7\u00e0\u00f9\u00ea\u00e2\u00ee\u00f4\u00fb]/;
(function() {
    cc.LabelTTF.RenderCmd = function() {
        this._fontClientHeight = 18;
        this._fontStyleStr = "";
        this._shadowColorStr = "rgba(128, 128, 128, 0.5)";
        this._strokeColorStr = "";
        this._fillColorStr = "rgba(255,255,255,1)";
        this._labelContext = this._labelCanvas = null;
        this._lineWidths = [];
        this._strings = [];
        this._isMultiLine = !1
    };
    var a = cc.LabelTTF.RenderCmd.prototype;
    a.constructor = cc.LabelTTF.RenderCmd;
    a._getLabelContext = function() {
        if (this._labelContext) return this._labelContext;
        var a = this._node;
        if (!this._labelCanvas) {
            var d =
                cc.newElement("canvas");
            d.width = 1;
            d.height = 1;
            var e = new cc.Texture2D;
            e.initWithElement(d);
            a.setTexture(e);
            this._labelCanvas = d
        }
        return this._labelContext = this._labelCanvas.getContext("2d")
    };
    a._setFontStyle = function(a, d, e, f) {
        a instanceof cc.FontDefinition ? (this._fontStyleStr = a._getCanvasFontStr(), this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(a)) : (this._fontStyleStr = e + " " + f + " " + d + "px '" + a + "'", this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(a, d))
    };
    a._getFontStyle = function() {
        return this._fontStyleStr
    };
    a._getFontClientHeight = function() {
        return this._fontClientHeight
    };
    a._updateTexture = function() {
        this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.textDirty;
        var a = this._node,
            d = this._getLabelContext(),
            e = this._labelCanvas,
            f = a._contentSize;
        if (0 === a._string.length) return e.width = 1, e.height = f.height || 1, a._texture && a._texture.handleLoadedTexture(), a.setTextureRect(cc.rect(0, 0, 1, f.height)), !0;
        d.font = this._fontStyleStr;
        this._updateTTF();
        var g = f.width,
            f = f.height,
            h = e.width === g && e.height === f;
        e.width = g;
        e.height =
            f;
        h && d.clearRect(0, 0, g, f);
        this._drawTTFInCanvas(d);
        a._texture && a._texture.handleLoadedTexture();
        a.setTextureRect(cc.rect(0, 0, g, f));
        return !0
    };
    a._measureConfig = function() {
        this._getLabelContext().font = this._fontStyleStr
    };
    a._measure = function(a) {
        return this._getLabelContext().measureText(a).width
    };
    a._updateTTF = function() {
        var a = this._node,
            d = a._dimensions.width,
            e, f, g = this._lineWidths;
        g.length = 0;
        this._isMultiLine = !1;
        this._measureConfig();
        if (0 !== d) {
            this._strings = a._string.split("\n");
            for (e = 0; e < this._strings.length; e++) this._checkWarp(this._strings,
                e, d)
        } else {
            this._strings = a._string.split("\n");
            e = 0;
            for (f = this._strings.length; e < f; e++) g.push(this._measure(this._strings[e]))
        }
        1 < this._strings.length && (this._isMultiLine = !0);
        f = e = 0;
        a._strokeEnabled && (e = f = 2 * a._strokeSize);
        if (a._shadowEnabled) {
            var h = a._shadowOffset;
            e += 2 * Math.abs(h.x);
            f += 2 * Math.abs(h.y)
        }
        d = 0 === d ? this._isMultiLine ? cc.size(Math.ceil(Math.max.apply(Math, g) + e), Math.ceil(this._fontClientHeight * this._strings.length + f)) : cc.size(Math.ceil(this._measure(a._string) + e), Math.ceil(this._fontClientHeight +
            f)) : 0 === a._dimensions.height ? this._isMultiLine ? cc.size(Math.ceil(d + e), Math.ceil(a.getLineHeight() * this._strings.length + f)) : cc.size(Math.ceil(d + e), Math.ceil(a.getLineHeight() + f)) : cc.size(Math.ceil(d + e), Math.ceil(a._dimensions.height + f));
        "normal" !== a._getFontStyle() && (d.width = Math.ceil(d.width + 0.3 * a._fontSize));
        a.setContentSize(d);
        a._strokeShadowOffsetX = e;
        a._strokeShadowOffsetY = f;
        a = a._anchorPoint;
        this._anchorPointInPoints.x = 0.5 * e + (d.width - e) * a.x;
        this._anchorPointInPoints.y = 0.5 * f + (d.height - f) * a.y
    };
    a._drawTTFInCanvas =
        function(a) {
            if (a) {
                var d = this._node,
                    e = d._strokeShadowOffsetX,
                    f = d._strokeShadowOffsetY,
                    g = d._contentSize.height - f,
                    h = d._vAlignment,
                    k = d._hAlignment,
                    m = d._strokeSize;
                a.setTransform(1, 0, 0, 1, 0.5 * e, g + 0.5 * f);
                a.font !== this._fontStyleStr && (a.font = this._fontStyleStr);
                a.fillStyle = this._fillColorStr;
                var n = f = 0,
                    p = d._strokeEnabled;
                p && (a.lineWidth = 2 * m, a.strokeStyle = this._strokeColorStr);
                d._shadowEnabled && (m = d._shadowOffset, a.shadowColor = this._shadowColorStr, a.shadowOffsetX = m.x, a.shadowOffsetY = -m.y, a.shadowBlur = d._shadowBlur);
                a.textBaseline = cc.LabelTTF._textBaseline[h];
                a.textAlign = cc.LabelTTF._textAlign[k];
                var r = d._contentSize.width - e,
                    e = d.getLineHeight(),
                    m = (e - this._fontClientHeight) / 2,
                    f = k === cc.TEXT_ALIGNMENT_RIGHT ? f + r : k === cc.TEXT_ALIGNMENT_CENTER ? f + r / 2 : f + 0;
                if (this._isMultiLine) {
                    d = this._strings.length;
                    h === cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM ? n = e - 2 * m + g - e * d : h === cc.VERTICAL_TEXT_ALIGNMENT_CENTER && (n = (e - 2 * m) / 2 + (g - e * d) / 2);
                    for (h = 0; h < d; h++) k = this._strings[h], r = -g + (e * h + m) + n, p && a.strokeText(k, f, r), a.fillText(k, f, r)
                } else h !== cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM &&
                    (n = h === cc.VERTICAL_TEXT_ALIGNMENT_TOP ? n - g : n - 0.5 * g), p && a.strokeText(d._string, f, n), a.fillText(d._string, f, n)
            }
        };
    a._checkWarp = function(a, d, e) {
        var f = a[d],
            g = this._measure(f);
        if (g > e && 1 < f.length) {
            for (var h = f.length * (e / g) | 0, k = f.substr(h), m = g - this._measure(k), n, p = 0, r = 0; m > e && 100 > r++;) h *= e / m, h |= 0, k = f.substr(h), m = g - this._measure(k);
            for (r = 0; m < e && 100 > r++;) k && (p = (n = cc.LabelTTF._wordRex.exec(k)) ? n[0].length : 1, n = k), h += p, k = f.substr(h), m = g - this._measure(k);
            h -= p;
            0 === h && (h = 1, n = n.substr(1));
            e = f.substr(0, h);
            if (cc.LabelTTF.wrapInspection &&
                cc.LabelTTF._symbolRex.test(n || k)) g = cc.LabelTTF._lastWordRex.exec(e), h -= g ? g[0].length : 0, n = f.substr(h), e = f.substr(0, h);
            if (cc.LabelTTF._firsrEnglish.test(n) && (g = cc.LabelTTF._lastEnglish.exec(e)) && e !== g[0]) h -= g[0].length, n = f.substr(h), e = f.substr(0, h);
            a[d] = n || k;
            a.splice(d, 0, e)
        }
    }
})();
(function() {
    cc.LabelTTF.CanvasRenderCmd = function(a) {
        cc.Sprite.CanvasRenderCmd.call(this, a);
        cc.LabelTTF.RenderCmd.call(this)
    };
    cc.LabelTTF.CanvasRenderCmd.prototype = Object.create(cc.Sprite.CanvasRenderCmd.prototype);
    cc.inject(cc.LabelTTF.RenderCmd.prototype, cc.LabelTTF.CanvasRenderCmd.prototype);
    var a = cc.LabelTTF.CanvasRenderCmd.prototype;
    a.constructor = cc.LabelTTF.CanvasRenderCmd;
    a.updateStatus = function() {
        var a = cc.Node._dirtyFlags,
            d = this._dirtyFlag,
            e = d & a.colorDirty,
            f = d & a.opacityDirty;
        e && this._updateDisplayColor();
        f && this._updateDisplayOpacity();
        e ? this._updateColor() : d & a.textDirty && this._updateTexture();
        this._dirtyFlag & a.transformDirty && (this.transform(this.getParentRenderCmd(), !0), this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.transformDirty)
    };
    a._syncStatus = function(a) {
        var d = cc.Node._dirtyFlags,
            e = this._dirtyFlag,
            f = a ? a._node : null;
        f && (f._cascadeColorEnabled && a._dirtyFlag & d.colorDirty) && (e |= d.colorDirty);
        f && (f._cascadeOpacityEnabled && a._dirtyFlag & d.opacityDirty) && (e |= d.opacityDirty);
        a && a._dirtyFlag & d.transformDirty &&
            (e |= d.transformDirty);
        var f = e & d.colorDirty,
            g = e & d.opacityDirty;
        this._dirtyFlag = e;
        f && this._syncDisplayColor();
        g && this._syncDisplayOpacity();
        f ? this._updateColor() : e & d.textDirty && this._updateTexture();
        e & d.transformDirty && this.transform(a)
    };
    a._setColorsString = function() {
        var a = this._displayedColor,
            d = this._node,
            e = d._shadowColor || this._displayedColor,
            f = d._strokeColor,
            g = d._textFillColor,
            h = a.r / 255,
            k = a.g / 255,
            a = a.b / 255;
        this._shadowColorStr = "rgba(" + (0 | h * e.r) + "," + (0 | k * e.g) + "," + (0 | a * e.b) + "," + d._shadowOpacity + ")";
        this._fillColorStr = "rgba(" + (0 | h * g.r) + "," + (0 | k * g.g) + "," + (0 | a * g.b) + ", 1)";
        this._strokeColorStr = "rgba(" + (0 | h * f.r) + "," + (0 | k * f.g) + "," + (0 | a * f.b) + ", 1)"
    };
    a._updateColor = function() {
        this._setColorsString();
        this._updateTexture()
    }
})();
(function() {
    cc.LabelTTF.WebGLRenderCmd = function(a) {
        cc.Sprite.WebGLRenderCmd.call(this, a);
        cc.LabelTTF.RenderCmd.call(this);
        this.setShaderProgram(cc.shaderCache.programForKey(cc.LabelTTF._SHADER_PROGRAM))
    };
    var a = cc.LabelTTF.WebGLRenderCmd.prototype = Object.create(cc.Sprite.WebGLRenderCmd.prototype);
    cc.inject(cc.LabelTTF.RenderCmd.prototype, a);
    a.constructor = cc.LabelTTF.WebGLRenderCmd;
    a._setColorsString = function() {
        this.setDirtyFlag(cc.Node._dirtyFlags.textDirty);
        var a = this._node,
            d = a._strokeColor,
            e = a._textFillColor,
            f = a._shadowColor || this._displayedColor;
        this._shadowColorStr = "rgba(" + (0 | f.r) + "," + (0 | f.g) + "," + (0 | f.b) + "," + a._shadowOpacity + ")";
        this._fillColorStr = "rgba(" + (0 | e.r) + "," + (0 | e.g) + "," + (0 | e.b) + ", 1)";
        this._strokeColorStr = "rgba(" + (0 | d.r) + "," + (0 | d.g) + "," + (0 | d.b) + ", 1)"
    };
    a.updateStatus = function() {
        var a = cc.Node._dirtyFlags,
            d = this._dirtyFlag,
            e = d & a.colorDirty,
            f = d & a.opacityDirty;
        e && this._updateDisplayColor();
        f && this._updateDisplayOpacity();
        e || f ? (this._setColorsString(), this._updateColor(), this._updateTexture()) :
            d & a.textDirty && this._updateTexture();
        this._dirtyFlag & a.transformDirty && (this.transform(this.getParentRenderCmd(), !0), this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.transformDirty)
    };
    a._syncStatus = function(a) {
        var d = cc.Node._dirtyFlags,
            e = this._dirtyFlag,
            f = a ? a._node : null;
        f && (f._cascadeColorEnabled && a._dirtyFlag & d.colorDirty) && (e |= d.colorDirty);
        f && (f._cascadeOpacityEnabled && a._dirtyFlag & d.opacityDirty) && (e |= d.opacityDirty);
        a && a._dirtyFlag & d.transformDirty && (e |= d.transformDirty);
        var f = e & d.colorDirty,
            g = e & d.opacityDirty;
        this._dirtyFlag = e;
        f && this._syncDisplayColor();
        g && this._syncDisplayOpacity();
        f || g ? (this._setColorsString(), this._updateColor(), this._updateTexture()) : e & d.textDirty && this._updateTexture();
        this.transform(a)
    }
})();
cc.HashElement = cc.Class.extend({
    actions: null,
    target: null,
    actionIndex: 0,
    currentAction: null,
    currentActionSalvaged: !1,
    paused: !1,
    hh: null,
    ctor: function() {
        this.actions = [];
        this.target = null;
        this.actionIndex = 0;
        this.currentAction = null;
        this.paused = this.currentActionSalvaged = !1;
        this.hh = null
    }
});
cc.ActionManager = cc.Class.extend({
    _hashTargets: null,
    _arrayTargets: null,
    _currentTarget: null,
    _currentTargetSalvaged: !1,
    _searchElementByTarget: function(a, b) {
        for (var d = 0; d < a.length; d++)
            if (b === a[d].target) return a[d];
        return null
    },
    ctor: function() {
        this._hashTargets = {};
        this._arrayTargets = [];
        this._currentTarget = null;
        this._currentTargetSalvaged = !1
    },
    addAction: function(a, b, d) {
        if (!a) throw Error("cc.ActionManager.addAction(): action must be non-null");
        if (!b) throw Error("cc.ActionManager.addAction(): action must be non-null");
        var e = this._hashTargets[b.__instanceId];
        e || (e = new cc.HashElement, e.paused = d, e.target = b, this._hashTargets[b.__instanceId] = e, this._arrayTargets.push(e));
        this._actionAllocWithHashElement(e);
        e.actions.push(a);
        a.startWithTarget(b)
    },
    removeAllActions: function() {
        for (var a = this._arrayTargets, b = 0; b < a.length; b++) {
            var d = a[b];
            d && this.removeAllActionsFromTarget(d.target, !0)
        }
    },
    removeAllActionsFromTarget: function(a, b) {
        if (null != a) {
            var d = this._hashTargets[a.__instanceId];
            d && (-1 !== d.actions.indexOf(d.currentAction) &&
                !d.currentActionSalvaged && (d.currentActionSalvaged = !0), d.actions.length = 0, this._currentTarget === d && !b ? this._currentTargetSalvaged = !0 : this._deleteHashElement(d))
        }
    },
    removeAction: function(a) {
        if (null != a) {
            var b = a.getOriginalTarget();
            if (b = this._hashTargets[b.__instanceId])
                for (var d = 0; d < b.actions.length; d++) {
                    if (b.actions[d] === a) {
                        b.actions.splice(d, 1);
                        break
                    }
                } else cc.log(cc._LogInfos.ActionManager_removeAction)
        }
    },
    removeActionByTag: function(a, b) {
        a === cc.ACTION_TAG_INVALID && cc.log(cc._LogInfos.ActionManager_addAction);
        cc.assert(b, cc._LogInfos.ActionManager_addAction);
        var d = this._hashTargets[b.__instanceId];
        if (d)
            for (var e = d.actions.length, f = 0; f < e; ++f) {
                var g = d.actions[f];
                if (g && g.getTag() === a && g.getOriginalTarget() === b) {
                    this._removeActionAtIndex(f, d);
                    break
                }
            }
    },
    getActionByTag: function(a, b) {
        a === cc.ACTION_TAG_INVALID && cc.log(cc._LogInfos.ActionManager_getActionByTag);
        var d = this._hashTargets[b.__instanceId];
        if (d) {
            if (null != d.actions)
                for (var e = 0; e < d.actions.length; ++e) {
                    var f = d.actions[e];
                    if (f && f.getTag() === a) return f
                }
            cc.log(cc._LogInfos.ActionManager_getActionByTag_2,
                a)
        }
        return null
    },
    numberOfRunningActionsInTarget: function(a) {
        return (a = this._hashTargets[a.__instanceId]) ? a.actions ? a.actions.length : 0 : 0
    },
    pauseTarget: function(a) {
        if (a = this._hashTargets[a.__instanceId]) a.paused = !0
    },
    resumeTarget: function(a) {
        if (a = this._hashTargets[a.__instanceId]) a.paused = !1
    },
    pauseAllRunningActions: function() {
        for (var a = [], b = this._arrayTargets, d = 0; d < b.length; d++) {
            var e = b[d];
            e && !e.paused && (e.paused = !0, a.push(e.target))
        }
        return a
    },
    resumeTargets: function(a) {
        if (a)
            for (var b = 0; b < a.length; b++) a[b] &&
                this.resumeTarget(a[b])
    },
    purgeSharedManager: function() {
        cc.director.getScheduler().unscheduleUpdate(this)
    },
    _removeActionAtIndex: function(a, b) {
        b.actions[a] === b.currentAction && !b.currentActionSalvaged && (b.currentActionSalvaged = !0);
        b.actions.splice(a, 1);
        b.actionIndex >= a && b.actionIndex--;
        0 === b.actions.length && (this._currentTarget === b ? this._currentTargetSalvaged = !0 : this._deleteHashElement(b))
    },
    _deleteHashElement: function(a) {
        var b = !1;
        a && (this._hashTargets[a.target.__instanceId] && (delete this._hashTargets[a.target.__instanceId],
            cc.arrayRemoveObject(this._arrayTargets, a), b = !0), a.actions = null, a.target = null);
        return b
    },
    _actionAllocWithHashElement: function(a) {
        null == a.actions && (a.actions = [])
    },
    update: function(a) {
        for (var b = this._arrayTargets, d, e = 0; e < b.length; e++) {
            d = this._currentTarget = b[e];
            if (!d.paused)
                for (d.actionIndex = 0; d.actionIndex < (d.actions ? d.actions.length : 0); d.actionIndex++)
                    if (d.currentAction = d.actions[d.actionIndex], d.currentAction) {
                        d.currentActionSalvaged = !1;
                        d.currentAction.step(a * (d.currentAction._speedMethod ? d.currentAction._speed :
                            1));
                        if (d.currentActionSalvaged) d.currentAction = null;
                        else if (d.currentAction.isDone()) {
                            d.currentAction.stop();
                            var f = d.currentAction;
                            d.currentAction = null;
                            this.removeAction(f)
                        }
                        d.currentAction = null
                    }
            this._currentTargetSalvaged && 0 === d.actions.length && this._deleteHashElement(d) && e--
        }
    }
});
cc.math = cc.math || {};
cc.math.EPSILON = 0.015625;
cc.math.square = function(a) {
    return a * a
};
cc.math.almostEqual = function(a, b) {
    return a + cc.math.EPSILON > b && a - cc.math.EPSILON < b
};
(function(a) {
    a.math.Vec2 = function(a, b) {
        void 0 === b ? (this.x = a.x, this.y = a.y) : (this.x = a || 0, this.y = b || 0)
    };
    var b = a.math.Vec2.prototype;
    b.fill = function(a, b) {
        this.x = a;
        this.y = b
    };
    b.length = function() {
        return Math.sqrt(a.math.square(this.x) + a.math.square(this.y))
    };
    b.lengthSq = function() {
        return a.math.square(this.x) + a.math.square(this.y)
    };
    b.normalize = function() {
        var a = 1 / this.length();
        this.x *= a;
        this.y *= a;
        return this
    };
    a.math.Vec2.add = function(a, b, f) {
        a.x = b.x + f.x;
        a.y = b.y + f.y;
        return a
    };
    b.add = function(a) {
        this.x += a.x;
        this.y +=
            a.y;
        return this
    };
    b.dot = function(a) {
        return this.x * a.x + this.y * a.y
    };
    a.math.Vec2.subtract = function(a, b, f) {
        a.x = b.x - f.x;
        a.y = b.y - f.y;
        return a
    };
    b.subtract = function(a) {
        this.x -= a.x;
        this.y -= a.y;
        return this
    };
    b.transform = function(a) {
        var b = this.x,
            f = this.y;
        this.x = b * a.mat[0] + f * a.mat[3] + a.mat[6];
        this.y = b * a.mat[1] + f * a.mat[4] + a.mat[7];
        return this
    };
    a.math.Vec2.scale = function(a, b, f) {
        a.x = b.x * f;
        a.y = b.y * f;
        return a
    };
    b.scale = function(a) {
        this.x *= a;
        this.y *= a;
        return this
    };
    b.equals = function(d) {
        return this.x < d.x + a.math.EPSILON &&
            this.x > d.x - a.math.EPSILON && this.y < d.y + a.math.EPSILON && this.y > d.y - a.math.EPSILON
    }
})(cc);
(function(a) {
    a.kmVec3 = a.math.Vec3 = function(a, b, f) {
        a && void 0 === b ? (this.x = a.x, this.y = a.y, this.z = a.z) : (this.x = a || 0, this.y = b || 0, this.z = f || 0)
    };
    a.math.vec3 = function(d, b, f) {
        return new a.math.Vec3(d, b, f)
    };
    var b = a.math.Vec3.prototype;
    b.fill = function(a, b, f) {
        a && void 0 === b ? (this.x = a.x, this.y = a.y, this.z = a.z) : (this.x = a, this.y = b, this.z = f);
        return this
    };
    b.length = function() {
        return Math.sqrt(a.math.square(this.x) + a.math.square(this.y) + a.math.square(this.z))
    };
    b.lengthSq = function() {
        return a.math.square(this.x) + a.math.square(this.y) +
            a.math.square(this.z)
    };
    b.normalize = function() {
        var a = 1 / this.length();
        this.x *= a;
        this.y *= a;
        this.z *= a;
        return this
    };
    b.cross = function(a) {
        var b = this.x,
            f = this.y,
            g = this.z;
        this.x = f * a.z - g * a.y;
        this.y = g * a.x - b * a.z;
        this.z = b * a.y - f * a.x;
        return this
    };
    b.dot = function(a) {
        return this.x * a.x + this.y * a.y + this.z * a.z
    };
    b.add = function(a) {
        this.x += a.x;
        this.y += a.y;
        this.z += a.z;
        return this
    };
    b.subtract = function(a) {
        this.x -= a.x;
        this.y -= a.y;
        this.z -= a.z;
        return this
    };
    b.transform = function(a) {
        var b = this.x,
            f = this.y,
            g = this.z;
        a = a.mat;
        this.x = b *
            a[0] + f * a[4] + g * a[8] + a[12];
        this.y = b * a[1] + f * a[5] + g * a[9] + a[13];
        this.z = b * a[2] + f * a[6] + g * a[10] + a[14];
        return this
    };
    b.transformNormal = function(a) {
        var b = this.x,
            f = this.y,
            g = this.z;
        a = a.mat;
        this.x = b * a[0] + f * a[4] + g * a[8];
        this.y = b * a[1] + f * a[5] + g * a[9];
        this.z = b * a[2] + f * a[6] + g * a[10];
        return this
    };
    b.transformCoord = function(d) {
        var b = new a.math.Vec4(this.x, this.y, this.z, 1);
        b.transform(d);
        this.x = b.x / b.w;
        this.y = b.y / b.w;
        this.z = b.z / b.w;
        return this
    };
    b.scale = function(a) {
        this.x *= a;
        this.y *= a;
        this.z *= a;
        return this
    };
    b.equals = function(d) {
        var b =
            a.math.EPSILON;
        return this.x < d.x + b && this.x > d.x - b && this.y < d.y + b && this.y > d.y - b && this.z < d.z + b && this.z > d.z - b
    };
    b.inverseTransform = function(d) {
        d = d.mat;
        var b = new a.math.Vec3(this.x - d[12], this.y - d[13], this.z - d[14]);
        this.x = b.x * d[0] + b.y * d[1] + b.z * d[2];
        this.y = b.x * d[4] + b.y * d[5] + b.z * d[6];
        this.z = b.x * d[8] + b.y * d[9] + b.z * d[10];
        return this
    };
    b.inverseTransformNormal = function(a) {
        var b = this.x,
            f = this.y,
            g = this.z;
        a = a.mat;
        this.x = b * a[0] + f * a[1] + g * a[2];
        this.y = b * a[4] + f * a[5] + g * a[6];
        this.z = b * a[8] + f * a[9] + g * a[10];
        return this
    };
    b.assignFrom =
        function(a) {
            if (!a) return this;
            this.x = a.x;
            this.y = a.y;
            this.z = a.z;
            return this
        };
    a.math.Vec3.zero = function(a) {
        a.x = a.y = a.z = 0;
        return a
    };
    b.toTypeArray = function() {
        var a = new Float32Array(3);
        a[0] = this.x;
        a[1] = this.y;
        a[2] = this.z;
        return a
    }
})(cc);
(function(a) {
    a.math.Vec4 = function(a, b, f, g) {
        a && void 0 === b ? (this.x = a.x, this.y = a.y, this.z = a.z, this.w = a.w) : (this.x = a || 0, this.y = b || 0, this.z = f || 0, this.w = g || 0)
    };
    a.kmVec4 = a.math.Vec4;
    var b = a.math.Vec4.prototype;
    b.fill = function(a, b, f, g) {
        a && void 0 === b ? (this.x = a.x, this.y = a.y, this.z = a.z, this.w = a.w) : (this.x = a, this.y = b, this.z = f, this.w = g)
    };
    b.add = function(a) {
        if (!a) return this;
        this.x += a.x;
        this.y += a.y;
        this.z += a.z;
        this.w += a.w;
        return this
    };
    b.dot = function(a) {
        return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w
    };
    b.length =
        function() {
            return Math.sqrt(a.math.square(this.x) + a.math.square(this.y) + a.math.square(this.z) + a.math.square(this.w))
        };
    b.lengthSq = function() {
        return a.math.square(this.x) + a.math.square(this.y) + a.math.square(this.z) + a.math.square(this.w)
    };
    b.lerp = function(a, b) {
        return this
    };
    b.normalize = function() {
        var a = 1 / this.length();
        this.x *= a;
        this.y *= a;
        this.z *= a;
        this.w *= a;
        return this
    };
    b.scale = function(a) {
        this.normalize();
        this.x *= a;
        this.y *= a;
        this.z *= a;
        this.w *= a;
        return this
    };
    b.subtract = function(a) {
        this.x -= a.x;
        this.y -=
            a.y;
        this.z -= a.z;
        this.w -= a.w
    };
    b.transform = function(a) {
        var b = this.x,
            f = this.y,
            g = this.z,
            h = this.w;
        a = a.mat;
        this.x = b * a[0] + f * a[4] + g * a[8] + h * a[12];
        this.y = b * a[1] + f * a[5] + g * a[9] + h * a[13];
        this.z = b * a[2] + f * a[6] + g * a[10] + h * a[14];
        this.w = b * a[3] + f * a[7] + g * a[11] + h * a[15];
        return this
    };
    a.math.Vec4.transformArray = function(b, e) {
        for (var f = [], g = 0; g < b.length; g++) {
            var h = new a.math.Vec4(b[g]);
            h.transform(e);
            f.push(h)
        }
        return f
    };
    b.equals = function(b) {
        var e = a.math.EPSILON;
        return this.x < b.x + e && this.x > b.x - e && this.y < b.y + e && this.y > b.y - e &&
            this.z < b.z + e && this.z > b.z - e && this.w < b.w + e && this.w > b.w - e
    };
    b.assignFrom = function(a) {
        this.x = a.x;
        this.y = a.y;
        this.z = a.z;
        this.w = a.w;
        return this
    };
    b.toTypeArray = function() {
        var a = new Float32Array(4);
        a[0] = this.x;
        a[1] = this.y;
        a[2] = this.z;
        a[3] = this.w;
        return a
    }
})(cc);
(function(a) {
    function b(b, e, f) {
        e = new a.math.Vec2(e);
        e.subtract(b);
        f.x = -e.y;
        f.y = e.x;
        f.normalize()
    }
    a.math.Ray2 = function(b, e) {
        this.start = b || new a.math.Vec2;
        this.dir = e || new a.math.Vec2
    };
    a.math.Ray2.prototype.fill = function(a, b, f, g) {
        this.start.x = a;
        this.start.y = b;
        this.dir.x = f;
        this.dir.y = g
    };
    a.math.Ray2.prototype.intersectLineSegment = function(b, e, f) {
        var g = this.start.x,
            h = this.start.y,
            k = this.start.x + this.dir.x,
            m = this.start.y + this.dir.y,
            n = b.x,
            p = b.y,
            r = e.x,
            s = e.y,
            t = (s - p) * (k - g) - (r - n) * (m - h);
        if (t > -a.math.EPSILON &&
            t < a.math.EPSILON) return !1;
        p = ((r - n) * (h - p) - (s - p) * (g - n)) / t;
        n = g + p * (k - g);
        p = h + p * (m - h);
        if (n < Math.min(b.x, e.x) - a.math.EPSILON || n > Math.max(b.x, e.x) + a.math.EPSILON || p < Math.min(b.y, e.y) - a.math.EPSILON || p > Math.max(b.y, e.y) + a.math.EPSILON || n < Math.min(g, k) - a.math.EPSILON || n > Math.max(g, k) + a.math.EPSILON || p < Math.min(h, m) - a.math.EPSILON || p > Math.max(h, m) + a.math.EPSILON) return !1;
        f.x = n;
        f.y = p;
        return !0
    };
    a.math.Ray2.prototype.intersectTriangle = function(d, e, f, g, h) {
        var k = new a.math.Vec2,
            m = new a.math.Vec2,
            n = new a.math.Vec2,
            p = 1E4,
            r = !1,
            s;
        this.intersectLineSegment(d, e, k) && (r = !0, s = k.subtract(this.start).length(), s < p && (m.x = k.x, m.y = k.y, p = s, b(d, e, n)));
        this.intersectLineSegment(e, f, k) && (r = !0, s = k.subtract(this.start).length(), s < p && (m.x = k.x, m.y = k.y, p = s, b(e, f, n)));
        this.intersectLineSegment(f, d, k) && (r = !0, s = k.subtract(this.start).length(), s < p && (m.x = k.x, m.y = k.y, b(f, d, n)));
        r && (g.x = m.x, g.y = m.y, h && (h.x = n.x, h.y = n.y));
        return r
    }
})(cc);
window.Uint16Array = window.Uint16Array || window.Array;
window.Float32Array = window.Float32Array || window.Array;
(function(a) {
    a.math.Matrix3 = function(a) {
        this.mat = a && a.mat ? new Float32Array(a.mat) : new Float32Array(9)
    };
    a.kmMat3 = a.math.Matrix3;
    var b = a.math.Matrix3.prototype;
    b.fill = function(a) {
        var b = this.mat;
        a = a.mat;
        b[0] = a[0];
        b[1] = a[1];
        b[2] = a[2];
        b[3] = a[3];
        b[4] = a[4];
        b[5] = a[5];
        b[6] = a[6];
        b[7] = a[7];
        b[8] = a[8];
        return this
    };
    b.adjugate = function() {
        var a = this.mat,
            b = a[0],
            d = a[1],
            h = a[2],
            k = a[3],
            m = a[4],
            n = a[5],
            p = a[6],
            r = a[7],
            s = a[8];
        a[0] = m * s - n * r;
        a[1] = h * r - d * s;
        a[2] = d * n - h * m;
        a[3] = n * p - k * s;
        a[4] = b * s - h * p;
        a[5] = h * k - b * n;
        a[6] = k * r - m * p;
        a[8] = b *
            m - d * k;
        return this
    };
    b.identity = function() {
        var a = this.mat;
        a[1] = a[2] = a[3] = a[5] = a[6] = a[7] = 0;
        a[0] = a[4] = a[8] = 1;
        return this
    };
    var d = new a.math.Matrix3;
    b.inverse = function(a) {
        if (0 === a) return this;
        d.assignFrom(this);
        a = 1 / a;
        this.adjugate();
        this.multiplyScalar(a);
        return this
    };
    b.isIdentity = function() {
        var a = this.mat;
        return 1 === a[0] && 0 === a[1] && 0 === a[2] && 0 === a[3] && 1 === a[4] && 0 === a[5] && 0 === a[6] && 0 === a[7] && 1 === a[8]
    };
    b.transpose = function() {
        var a = this.mat,
            b = a[1],
            d = a[2],
            h = a[5],
            k = a[6],
            m = a[7];
        a[1] = a[3];
        a[2] = k;
        a[3] = b;
        a[5] =
            m;
        a[6] = d;
        a[7] = h;
        return this
    };
    b.determinant = function() {
        var a = this.mat,
            b = a[0] * a[4] * a[8] + a[1] * a[5] * a[6] + a[2] * a[3] * a[7];
        return b -= a[2] * a[4] * a[6] + a[0] * a[5] * a[7] + a[1] * a[3] * a[8]
    };
    b.multiply = function(a) {
        var b = this.mat,
            d = a.mat;
        a = b[0];
        var h = b[1],
            k = b[2],
            m = b[3],
            n = b[4],
            p = b[5],
            r = b[6],
            s = b[7],
            t = b[8],
            u = d[0],
            v = d[1],
            w = d[2],
            x = d[3],
            B = d[4],
            y = d[5],
            z = d[6],
            A = d[7],
            d = d[8];
        b[0] = a * u + m * v + r * w;
        b[1] = h * u + n * v + s * w;
        b[2] = k * u + p * v + t * w;
        b[3] = k * u + p * v + t * w;
        b[4] = h * x + n * B + s * y;
        b[5] = k * x + p * B + t * y;
        b[6] = a * z + m * A + r * d;
        b[7] = h * z + n * A + s * d;
        b[8] = k * z + p * A + t * d;
        return this
    };
    b.multiplyScalar = function(a) {
        var b = this.mat;
        b[0] *= a;
        b[1] *= a;
        b[2] *= a;
        b[3] *= a;
        b[4] *= a;
        b[5] *= a;
        b[6] *= a;
        b[7] *= a;
        b[8] *= a;
        return this
    };
    a.math.Matrix3.rotationAxisAngle = function(b, d) {
        var g = Math.cos(d),
            h = Math.sin(d),
            k = new a.math.Matrix3,
            m = k.mat;
        m[0] = g + b.x * b.x * (1 - g);
        m[1] = b.z * h + b.y * b.x * (1 - g);
        m[2] = -b.y * h + b.z * b.x * (1 - g);
        m[3] = -b.z * h + b.x * b.y * (1 - g);
        m[4] = g + b.y * b.y * (1 - g);
        m[5] = b.x * h + b.z * b.y * (1 - g);
        m[6] = b.y * h + b.x * b.z * (1 - g);
        m[7] = -b.x * h + b.y * b.z * (1 - g);
        m[8] = g + b.z * b.z * (1 - g);
        return k
    };
    b.assignFrom = function(b) {
        if (this ===
            b) return a.log("cc.math.Matrix3.assign(): current matrix equals matIn"), this;
        var d = this.mat;
        b = b.mat;
        d[0] = b[0];
        d[1] = b[1];
        d[2] = b[2];
        d[3] = b[3];
        d[4] = b[4];
        d[5] = b[5];
        d[6] = b[6];
        d[7] = b[7];
        d[8] = b[8];
        return this
    };
    b.equals = function(b) {
        if (this === b) return !0;
        var d = a.math.EPSILON,
            g = this.mat;
        b = b.mat;
        for (var h = 0; 9 > h; ++h)
            if (!(g[h] + d > b[h] && g[h] - d < b[h])) return !1;
        return !0
    };
    a.math.Matrix3.createByRotationX = function(b) {
        var d = new a.math.Matrix3,
            g = d.mat;
        g[0] = 1;
        g[1] = 0;
        g[2] = 0;
        g[3] = 0;
        g[4] = Math.cos(b);
        g[5] = Math.sin(b);
        g[6] = 0;
        g[7] = -Math.sin(b);
        g[8] = Math.cos(b);
        return d
    };
    a.math.Matrix3.createByRotationY = function(b) {
        var d = new a.math.Matrix3,
            g = d.mat;
        g[0] = Math.cos(b);
        g[1] = 0;
        g[2] = -Math.sin(b);
        g[3] = 0;
        g[4] = 1;
        g[5] = 0;
        g[6] = Math.sin(b);
        g[7] = 0;
        g[8] = Math.cos(b);
        return d
    };
    a.math.Matrix3.createByRotationZ = function(b) {
        var d = new a.math.Matrix3,
            g = d.mat;
        g[0] = Math.cos(b);
        g[1] = -Math.sin(b);
        g[2] = 0;
        g[3] = Math.sin(b);
        g[4] = Math.cos(b);
        g[5] = 0;
        g[6] = 0;
        g[7] = 0;
        g[8] = 1;
        return d
    };
    a.math.Matrix3.createByRotation = function(b) {
        var d = new a.math.Matrix3,
            g = d.mat;
        g[0] = Math.cos(b);
        g[1] = Math.sin(b);
        g[2] = 0;
        g[3] = -Math.sin(b);
        g[4] = Math.cos(b);
        g[5] = 0;
        g[6] = 0;
        g[7] = 0;
        g[8] = 1;
        return d
    };
    a.math.Matrix3.createByScale = function(b, d) {
        var g = new a.math.Matrix3;
        g.identity();
        g.mat[0] = b;
        g.mat[4] = d;
        return g
    };
    a.math.Matrix3.createByTranslation = function(b, d) {
        var g = new a.math.Matrix3;
        g.identity();
        g.mat[6] = b;
        g.mat[7] = d;
        return g
    };
    a.math.Matrix3.createByQuaternion = function(b) {
        if (!b) return null;
        var d = new a.math.Matrix3,
            g = d.mat;
        g[0] = 1 - 2 * (b.y * b.y + b.z * b.z);
        g[1] = 2 * (b.x * b.y - b.w * b.z);
        g[2] = 2 *
            (b.x * b.z + b.w * b.y);
        g[3] = 2 * (b.x * b.y + b.w * b.z);
        g[4] = 1 - 2 * (b.x * b.x + b.z * b.z);
        g[5] = 2 * (b.y * b.z - b.w * b.x);
        g[6] = 2 * (b.x * b.z - b.w * b.y);
        g[7] = 2 * (b.y * b.z + b.w * b.x);
        g[8] = 1 - 2 * (b.x * b.x + b.y * b.y);
        return d
    };
    b.rotationToAxisAngle = function() {
        return a.math.Quaternion.rotationMatrix(this).toAxisAndAngle()
    }
})(cc);
(function(a) {
    a.math.Matrix4 = function(a) {
        this.mat = a && a.mat ? new Float32Array(a.mat) : new Float32Array(16)
    };
    a.kmMat4 = a.math.Matrix4;
    var b = a.math.Matrix4.prototype;
    b.fill = function(a) {
        for (var b = this.mat, d = 0; 16 > d; d++) b[d] = a[d];
        return this
    };
    a.kmMat4Identity = function(a) {
        var b = a.mat;
        b[1] = b[2] = b[3] = b[4] = b[6] = b[7] = b[8] = b[9] = b[11] = b[12] = b[13] = b[14] = 0;
        b[0] = b[5] = b[10] = b[15] = 1;
        return a
    };
    b.identity = function() {
        var a = this.mat;
        a[1] = a[2] = a[3] = a[4] = a[6] = a[7] = a[8] = a[9] = a[11] = a[12] = a[13] = a[14] = 0;
        a[0] = a[5] = a[10] = a[15] = 1;
        return this
    };
    b.get = function(a, b) {
        return this.mat[a + 4 * b]
    };
    b.set = function(a, b, d) {
        this.mat[a + 4 * b] = d
    };
    b.swap = function(a, b, d, e) {
        var m = this.mat,
            n = m[a + 4 * b];
        m[a + 4 * b] = m[d + 4 * e];
        m[d + 4 * e] = n
    };
    a.math.Matrix4._gaussj = function(a, b) {
        var d, e = 0,
            m = 0,
            n, p, r, s, t = [0, 0, 0, 0],
            u = [0, 0, 0, 0],
            v = [0, 0, 0, 0];
        for (d = 0; 4 > d; d++) {
            for (n = s = 0; 4 > n; n++)
                if (1 !== v[n])
                    for (p = 0; 4 > p; p++) 0 === v[p] && (r = Math.abs(a.get(n, p)), r >= s && (s = r, m = n, e = p));
                ++v[e];
            if (m !== e) {
                for (n = 0; 4 > n; n++) a.swap(m, n, e, n);
                for (n = 0; 4 > n; n++) b.swap(m, n, e, n)
            }
            u[d] = m;
            t[d] = e;
            if (0 === a.get(e,
                e)) return !1;
            p = 1 / a.get(e, e);
            a.set(e, e, 1);
            for (n = 0; 4 > n; n++) a.set(e, n, a.get(e, n) * p);
            for (n = 0; 4 > n; n++) b.set(e, n, b.get(e, n) * p);
            for (p = 0; 4 > p; p++)
                if (p !== e) {
                    r = a.get(p, e);
                    a.set(p, e, 0);
                    for (n = 0; 4 > n; n++) a.set(p, n, a.get(p, n) - a.get(e, n) * r);
                    for (n = 0; 4 > n; n++) b.set(p, n, a.get(p, n) - b.get(e, n) * r)
                }
        }
        for (n = 3; 0 <= n; n--)
            if (u[n] !== t[n])
                for (p = 0; 4 > p; p++) a.swap(p, u[n], p, t[n]);
        return !0
    };
    var d = (new a.math.Matrix4).identity();
    a.kmMat4Inverse = function(b, e) {
        var h = new a.math.Matrix4(e),
            k = new a.math.Matrix4(d);
        if (!1 === a.math.Matrix4._gaussj(h,
            k)) return null;
        b.assignFrom(h);
        return b
    };
    b.inverse = function() {
        var b = new a.math.Matrix4(this),
            e = new a.math.Matrix4(d);
        return !1 === a.math.Matrix4._gaussj(b, e) ? null : b
    };
    b.isIdentity = function() {
        var a = this.mat;
        return 1 === a[0] && 0 === a[1] && 0 === a[2] && 0 === a[3] && 0 === a[4] && 1 === a[5] && 0 === a[6] && 0 === a[7] && 0 === a[8] && 0 === a[9] && 1 === a[10] && 0 === a[11] && 0 === a[12] && 0 === a[13] && 0 === a[14] && 1 === a[15]
    };
    b.transpose = function() {
        var a = this.mat,
            b = a[1],
            d = a[2],
            e = a[3],
            m = a[6],
            n = a[7],
            p = a[8],
            r = a[9],
            s = a[11],
            t = a[12],
            u = a[13],
            v = a[14];
        a[1] = a[4];
        a[2] = p;
        a[3] = t;
        a[4] = b;
        a[6] = r;
        a[7] = u;
        a[8] = d;
        a[9] = m;
        a[11] = v;
        a[12] = e;
        a[13] = n;
        a[14] = s;
        return this
    };
    a.kmMat4Multiply = function(a, b, d) {
        var e = a.mat,
            m = b.mat,
            n = d.mat;
        d = m[0];
        b = m[1];
        var p = m[2],
            r = m[3],
            s = m[4],
            t = m[5],
            u = m[6],
            v = m[7],
            w = m[8],
            x = m[9],
            B = m[10],
            y = m[11],
            z = m[12],
            A = m[13],
            C = m[14],
            m = m[15],
            D = n[0],
            E = n[1],
            F = n[2],
            G = n[3],
            H = n[4],
            I = n[5],
            J = n[6],
            K = n[7],
            L = n[8],
            M = n[9],
            N = n[10],
            O = n[11],
            P = n[12],
            Q = n[13],
            R = n[14],
            n = n[15];
        e[0] = D * d + E * s + F * w + G * z;
        e[1] = D * b + E * t + F * x + G * A;
        e[2] = D * p + E * u + F * B + G * C;
        e[3] = D * r + E * v + F * y + G * m;
        e[4] = H * d + I * s + J * w + K * z;
        e[5] =
            H * b + I * t + J * x + K * A;
        e[6] = H * p + I * u + J * B + K * C;
        e[7] = H * r + I * v + J * y + K * m;
        e[8] = L * d + M * s + N * w + O * z;
        e[9] = L * b + M * t + N * x + O * A;
        e[10] = L * p + M * u + N * B + O * C;
        e[11] = L * r + M * v + N * y + O * m;
        e[12] = P * d + Q * s + R * w + n * z;
        e[13] = P * b + Q * t + R * x + n * A;
        e[14] = P * p + Q * u + R * B + n * C;
        e[15] = P * r + Q * v + R * y + n * m;
        return a
    };
    b.multiply = function(a) {
        var b = this.mat,
            d = a.mat;
        a = b[0];
        var e = b[1],
            m = b[2],
            n = b[3],
            p = b[4],
            r = b[5],
            s = b[6],
            t = b[7],
            u = b[8],
            v = b[9],
            w = b[10],
            x = b[11],
            B = b[12],
            y = b[13],
            z = b[14],
            A = b[15],
            C = d[0],
            D = d[1],
            E = d[2],
            F = d[3],
            G = d[4],
            H = d[5],
            I = d[6],
            J = d[7],
            K = d[8],
            L = d[9],
            M = d[10],
            N = d[11],
            O = d[12],
            P = d[13],
            Q = d[14],
            d = d[15];
        b[0] = C * a + D * p + E * u + F * B;
        b[1] = C * e + D * r + E * v + F * y;
        b[2] = C * m + D * s + E * w + F * z;
        b[3] = C * n + D * t + E * x + F * A;
        b[4] = G * a + H * p + I * u + J * B;
        b[5] = G * e + H * r + I * v + J * y;
        b[6] = G * m + H * s + I * w + J * z;
        b[7] = G * n + H * t + I * x + J * A;
        b[8] = K * a + L * p + M * u + N * B;
        b[9] = K * e + L * r + M * v + N * y;
        b[10] = K * m + L * s + M * w + N * z;
        b[11] = K * n + L * t + M * x + N * A;
        b[12] = O * a + P * p + Q * u + d * B;
        b[13] = O * e + P * r + Q * v + d * y;
        b[14] = O * m + P * s + Q * w + d * z;
        b[15] = O * n + P * t + Q * x + d * A;
        return this
    };
    a.getMat4MultiplyValue = function(a, b) {
        var d = a.mat,
            e = b.mat,
            m = new Float32Array(16);
        m[0] = d[0] * e[0] + d[4] * e[1] + d[8] * e[2] + d[12] * e[3];
        m[1] = d[1] * e[0] + d[5] * e[1] + d[9] * e[2] + d[13] * e[3];
        m[2] = d[2] * e[0] + d[6] * e[1] + d[10] * e[2] + d[14] * e[3];
        m[3] = d[3] * e[0] + d[7] * e[1] + d[11] * e[2] + d[15] * e[3];
        m[4] = d[0] * e[4] + d[4] * e[5] + d[8] * e[6] + d[12] * e[7];
        m[5] = d[1] * e[4] + d[5] * e[5] + d[9] * e[6] + d[13] * e[7];
        m[6] = d[2] * e[4] + d[6] * e[5] + d[10] * e[6] + d[14] * e[7];
        m[7] = d[3] * e[4] + d[7] * e[5] + d[11] * e[6] + d[15] * e[7];
        m[8] = d[0] * e[8] + d[4] * e[9] + d[8] * e[10] + d[12] * e[11];
        m[9] = d[1] * e[8] + d[5] * e[9] + d[9] * e[10] + d[13] * e[11];
        m[10] = d[2] * e[8] + d[6] * e[9] + d[10] * e[10] + d[14] * e[11];
        m[11] = d[3] * e[8] + d[7] * e[9] + d[11] *
            e[10] + d[15] * e[11];
        m[12] = d[0] * e[12] + d[4] * e[13] + d[8] * e[14] + d[12] * e[15];
        m[13] = d[1] * e[12] + d[5] * e[13] + d[9] * e[14] + d[13] * e[15];
        m[14] = d[2] * e[12] + d[6] * e[13] + d[10] * e[14] + d[14] * e[15];
        m[15] = d[3] * e[12] + d[7] * e[13] + d[11] * e[14] + d[15] * e[15];
        return m
    };
    a.kmMat4Assign = function(b, d) {
        if (b === d) return a.log("cc.kmMat4Assign(): pOut equals pIn"), b;
        var e = b.mat,
            k = d.mat;
        e[0] = k[0];
        e[1] = k[1];
        e[2] = k[2];
        e[3] = k[3];
        e[4] = k[4];
        e[5] = k[5];
        e[6] = k[6];
        e[7] = k[7];
        e[8] = k[8];
        e[9] = k[9];
        e[10] = k[10];
        e[11] = k[11];
        e[12] = k[12];
        e[13] = k[13];
        e[14] = k[14];
        e[15] = k[15];
        return b
    };
    b.assignFrom = function(b) {
        if (this === b) return a.log("cc.mat.Matrix4.assignFrom(): mat4 equals current matrix"), this;
        var d = this.mat;
        b = b.mat;
        d[0] = b[0];
        d[1] = b[1];
        d[2] = b[2];
        d[3] = b[3];
        d[4] = b[4];
        d[5] = b[5];
        d[6] = b[6];
        d[7] = b[7];
        d[8] = b[8];
        d[9] = b[9];
        d[10] = b[10];
        d[11] = b[11];
        d[12] = b[12];
        d[13] = b[13];
        d[14] = b[14];
        d[15] = b[15];
        return this
    };
    b.equals = function(b) {
        if (this === b) return a.log("cc.kmMat4AreEqual(): pMat1 and pMat2 are same object."), !0;
        var d = this.mat;
        b = b.mat;
        for (var e = a.math.EPSILON, k = 0; 16 >
            k; k++)
            if (!(d[k] + e > b[k] && d[k] - e < b[k])) return !1;
        return !0
    };
    a.math.Matrix4.createByRotationX = function(b, d) {
        d = d || new a.math.Matrix4;
        var e = d.mat;
        e[0] = 1;
        e[3] = e[2] = e[1] = 0;
        e[4] = 0;
        e[5] = Math.cos(b);
        e[6] = Math.sin(b);
        e[7] = 0;
        e[8] = 0;
        e[9] = -Math.sin(b);
        e[10] = Math.cos(b);
        e[11] = 0;
        e[14] = e[13] = e[12] = 0;
        e[15] = 1;
        return d
    };
    a.math.Matrix4.createByRotationY = function(b, d) {
        d = d || new a.math.Matrix4;
        var e = d.mat;
        e[0] = Math.cos(b);
        e[1] = 0;
        e[2] = -Math.sin(b);
        e[3] = 0;
        e[7] = e[6] = e[4] = 0;
        e[5] = 1;
        e[8] = Math.sin(b);
        e[9] = 0;
        e[10] = Math.cos(b);
        e[11] =
            0;
        e[14] = e[13] = e[12] = 0;
        e[15] = 1;
        return d
    };
    a.math.Matrix4.createByRotationZ = function(b, d) {
        d = d || new a.math.Matrix4;
        var e = d.mat;
        e[0] = Math.cos(b);
        e[1] = Math.sin(b);
        e[3] = e[2] = 0;
        e[4] = -Math.sin(b);
        e[5] = Math.cos(b);
        e[7] = e[6] = 0;
        e[11] = e[9] = e[8] = 0;
        e[10] = 1;
        e[14] = e[13] = e[12] = 0;
        e[15] = 1;
        return d
    };
    a.math.Matrix4.createByPitchYawRoll = function(b, d, e, k) {
        k = k || new a.math.Matrix4;
        var m = Math.cos(b);
        b = Math.sin(b);
        var n = Math.cos(d);
        d = Math.sin(d);
        var p = Math.cos(e);
        e = Math.sin(e);
        var r = b * d,
            s = m * d,
            t = k.mat;
        t[0] = n * p;
        t[4] = n * e;
        t[8] = -d;
        t[1] = r * p - m * e;
        t[5] = r * e + m * p;
        t[9] = b * n;
        t[2] = s * p + b * e;
        t[6] = s * e - b * p;
        t[10] = m * n;
        t[3] = t[7] = t[11] = 0;
        t[15] = 1;
        return k
    };
    a.math.Matrix4.createByQuaternion = function(b, d) {
        d = d || new a.math.Matrix4;
        var e = d.mat;
        e[0] = 1 - 2 * (b.y * b.y + b.z * b.z);
        e[1] = 2 * (b.x * b.y + b.z * b.w);
        e[2] = 2 * (b.x * b.z - b.y * b.w);
        e[3] = 0;
        e[4] = 2 * (b.x * b.y - b.z * b.w);
        e[5] = 1 - 2 * (b.x * b.x + b.z * b.z);
        e[6] = 2 * (b.z * b.y + b.x * b.w);
        e[7] = 0;
        e[8] = 2 * (b.x * b.z + b.y * b.w);
        e[9] = 2 * (b.y * b.z - b.x * b.w);
        e[10] = 1 - 2 * (b.x * b.x + b.y * b.y);
        e[11] = 0;
        e[14] = e[13] = e[12] = 0;
        e[15] = 1;
        return d
    };
    a.math.Matrix4.createByRotationTranslation =
        function(b, d, e) {
            e = e || new a.math.Matrix4;
            var k = e.mat;
            b = b.mat;
            k[0] = b[0];
            k[1] = b[1];
            k[2] = b[2];
            k[3] = 0;
            k[4] = b[3];
            k[5] = b[4];
            k[6] = b[5];
            k[7] = 0;
            k[8] = b[6];
            k[9] = b[7];
            k[10] = b[8];
            k[11] = 0;
            k[12] = d.x;
            k[13] = d.y;
            k[14] = d.z;
            k[15] = 1;
            return e
        };
    a.math.Matrix4.createByScale = function(b, d, e, k) {
        k = k || new a.math.Matrix4;
        var m = k.mat;
        m[0] = b;
        m[5] = d;
        m[10] = e;
        m[15] = 1;
        m[1] = m[2] = m[3] = m[4] = m[6] = m[7] = m[8] = m[9] = m[11] = m[12] = m[13] = m[14] = 0;
        return k
    };
    a.kmMat4Translation = function(a, b, d, e) {
        a.mat[0] = a.mat[5] = a.mat[10] = a.mat[15] = 1;
        a.mat[1] = a.mat[2] =
            a.mat[3] = a.mat[4] = a.mat[6] = a.mat[7] = a.mat[8] = a.mat[9] = a.mat[11] = 0;
        a.mat[12] = b;
        a.mat[13] = d;
        a.mat[14] = e;
        return a
    };
    a.math.Matrix4.createByTranslation = function(b, d, e, k) {
        k = k || new a.math.Matrix4;
        k.identity();
        k.mat[12] = b;
        k.mat[13] = d;
        k.mat[14] = e;
        return k
    };
    b.getUpVec3 = function() {
        var b = this.mat;
        return (new a.math.Vec3(b[4], b[5], b[6])).normalize()
    };
    b.getRightVec3 = function() {
        var b = this.mat;
        return (new a.math.Vec3(b[0], b[1], b[2])).normalize()
    };
    b.getForwardVec3 = function() {
        var b = this.mat;
        return (new a.math.Vec3(b[8],
            b[9], b[10])).normalize()
    };
    a.kmMat4PerspectiveProjection = function(b, d, e, k, m) {
        var n = a.degreesToRadians(d / 2);
        d = m - k;
        var p = Math.sin(n);
        if (0 === d || 0 === p || 0 === e) return null;
        n = Math.cos(n) / p;
        b.identity();
        b.mat[0] = n / e;
        b.mat[5] = n;
        b.mat[10] = -(m + k) / d;
        b.mat[11] = -1;
        b.mat[14] = -2 * k * m / d;
        b.mat[15] = 0;
        return b
    };
    a.math.Matrix4.createPerspectiveProjection = function(b, d, e, k) {
        var m = a.degreesToRadians(b / 2);
        b = k - e;
        var n = Math.sin(m);
        if (0 === b || 0 === n || 0 === d) return null;
        var m = Math.cos(m) / n,
            n = new a.math.Matrix4,
            p = n.mat;
        n.identity();
        p[0] = m / d;
        p[5] = m;
        p[10] = -(k + e) / b;
        p[11] = -1;
        p[14] = -2 * e * k / b;
        p[15] = 0;
        return n
    };
    a.kmMat4OrthographicProjection = function(a, b, d, e, m, n, p) {
        a.identity();
        a.mat[0] = 2 / (d - b);
        a.mat[5] = 2 / (m - e);
        a.mat[10] = -2 / (p - n);
        a.mat[12] = -((d + b) / (d - b));
        a.mat[13] = -((m + e) / (m - e));
        a.mat[14] = -((p + n) / (p - n));
        return a
    };
    a.math.Matrix4.createOrthographicProjection = function(b, d, e, k, m, n) {
        var p = new a.math.Matrix4,
            r = p.mat;
        p.identity();
        r[0] = 2 / (d - b);
        r[5] = 2 / (k - e);
        r[10] = -2 / (n - m);
        r[12] = -((d + b) / (d - b));
        r[13] = -((k + e) / (k - e));
        r[14] = -((n + m) / (n - m));
        return p
    };
    a.kmMat4LookAt = function(b, d, e, k) {
        e = new a.math.Vec3(e);
        var m = new a.math.Vec3(k);
        e.subtract(d);
        e.normalize();
        m.normalize();
        k = new a.math.Vec3(e);
        k.cross(m);
        k.normalize();
        m = new a.math.Vec3(k);
        m.cross(e);
        k.normalize();
        b.identity();
        b.mat[0] = k.x;
        b.mat[4] = k.y;
        b.mat[8] = k.z;
        b.mat[1] = m.x;
        b.mat[5] = m.y;
        b.mat[9] = m.z;
        b.mat[2] = -e.x;
        b.mat[6] = -e.y;
        b.mat[10] = -e.z;
        d = a.math.Matrix4.createByTranslation(-d.x, -d.y, -d.z);
        b.multiply(d);
        return b
    };
    var e = new a.math.Matrix4;
    b.lookAt = function(b, d, h) {
        d = new a.math.Vec3(d);
        var k =
            new a.math.Vec3(h);
        h = this.mat;
        d.subtract(b);
        d.normalize();
        k.normalize();
        var m = new a.math.Vec3(d);
        m.cross(k);
        m.normalize();
        k = new a.math.Vec3(m);
        k.cross(d);
        m.normalize();
        this.identity();
        h[0] = m.x;
        h[4] = m.y;
        h[8] = m.z;
        h[1] = k.x;
        h[5] = k.y;
        h[9] = k.z;
        h[2] = -d.x;
        h[6] = -d.y;
        h[10] = -d.z;
        e = a.math.Matrix4.createByTranslation(-b.x, -b.y, -b.z, e);
        this.multiply(e);
        return this
    };
    a.kmMat4RotationAxisAngle = function(b, d, e) {
        var k = Math.cos(e);
        e = Math.sin(e);
        d = new a.math.Vec3(d);
        d.normalize();
        b.mat[0] = k + d.x * d.x * (1 - k);
        b.mat[1] = d.z *
            e + d.y * d.x * (1 - k);
        b.mat[2] = -d.y * e + d.z * d.x * (1 - k);
        b.mat[3] = 0;
        b.mat[4] = -d.z * e + d.x * d.y * (1 - k);
        b.mat[5] = k + d.y * d.y * (1 - k);
        b.mat[6] = d.x * e + d.z * d.y * (1 - k);
        b.mat[7] = 0;
        b.mat[8] = d.y * e + d.x * d.z * (1 - k);
        b.mat[9] = -d.x * e + d.y * d.z * (1 - k);
        b.mat[10] = k + d.z * d.z * (1 - k);
        b.mat[11] = 0;
        b.mat[12] = 0;
        b.mat[13] = 0;
        b.mat[14] = 0;
        b.mat[15] = 1;
        return b
    };
    a.math.Matrix4.createByAxisAndAngle = function(b, d, e) {
        e = e || new a.math.Matrix4;
        var k = this.mat,
            m = Math.cos(d);
        d = Math.sin(d);
        b = new a.math.Vec3(b);
        b.normalize();
        k[0] = m + b.x * b.x * (1 - m);
        k[1] = b.z * d + b.y * b.x *
            (1 - m);
        k[2] = -b.y * d + b.z * b.x * (1 - m);
        k[3] = 0;
        k[4] = -b.z * d + b.x * b.y * (1 - m);
        k[5] = m + b.y * b.y * (1 - m);
        k[6] = b.x * d + b.z * b.y * (1 - m);
        k[7] = 0;
        k[8] = b.y * d + b.x * b.z * (1 - m);
        k[9] = -b.x * d + b.y * b.z * (1 - m);
        k[10] = m + b.z * b.z * (1 - m);
        k[11] = 0;
        k[12] = k[13] = k[14] = 0;
        k[15] = 1;
        return e
    };
    b.extractRotation = function() {
        var b = new a.math.Matrix3,
            d = this.mat,
            e = b.mat;
        e[0] = d[0];
        e[1] = d[1];
        e[2] = d[2];
        e[3] = d[4];
        e[4] = d[5];
        e[5] = d[6];
        e[6] = d[8];
        e[7] = d[9];
        e[8] = d[10];
        return b
    };
    b.extractPlane = function(b) {
        var d = new a.math.Plane,
            e = this.mat;
        switch (b) {
            case a.math.Plane.RIGHT:
                d.a =
                    e[3] - e[0];
                d.b = e[7] - e[4];
                d.c = e[11] - e[8];
                d.d = e[15] - e[12];
                break;
            case a.math.Plane.LEFT:
                d.a = e[3] + e[0];
                d.b = e[7] + e[4];
                d.c = e[11] + e[8];
                d.d = e[15] + e[12];
                break;
            case a.math.Plane.BOTTOM:
                d.a = e[3] + e[1];
                d.b = e[7] + e[5];
                d.c = e[11] + e[9];
                d.d = e[15] + e[13];
                break;
            case a.math.Plane.TOP:
                d.a = e[3] - e[1];
                d.b = e[7] - e[5];
                d.c = e[11] - e[9];
                d.d = e[15] - e[13];
                break;
            case a.math.Plane.FAR:
                d.a = e[3] - e[2];
                d.b = e[7] - e[6];
                d.c = e[11] - e[10];
                d.d = e[15] - e[14];
                break;
            case a.math.Plane.NEAR:
                d.a = e[3] + e[2];
                d.b = e[7] + e[6];
                d.c = e[11] + e[10];
                d.d = e[15] + e[14];
                break;
            default:
                a.log("cc.math.Matrix4.extractPlane: Invalid plane index")
        }
        b = Math.sqrt(d.a * d.a + d.b * d.b + d.c * d.c);
        d.a /= b;
        d.b /= b;
        d.c /= b;
        d.d /= b;
        return d
    };
    b.toAxisAndAngle = function() {
        var b = this.extractRotation();
        return a.math.Quaternion.rotationMatrix(b).toAxisAndAngle()
    }
})(cc);
(function(a) {
    a.math.Plane = function(a, b, f, g) {
        a && void 0 === b ? (this.a = a.a, this.b = a.b, this.c = a.c, this.d = a.d) : (this.a = a || 0, this.b = b || 0, this.c = f || 0, this.d = g || 0)
    };
    a.kmPlane = a.math.Plane;
    var b = a.math.Plane.prototype;
    a.math.Plane.LEFT = 0;
    a.math.Plane.RIGHT = 1;
    a.math.Plane.BOTTOM = 2;
    a.math.Plane.TOP = 3;
    a.math.Plane.NEAR = 4;
    a.math.Plane.FAR = 5;
    a.math.Plane.POINT_INFRONT_OF_PLANE = 0;
    a.math.Plane.POINT_BEHIND_PLANE = 1;
    a.math.Plane.POINT_ON_PLANE = 2;
    b.dot = function(a) {
        return this.a * a.x + this.b * a.y + this.c * a.z + this.d * a.w
    };
    b.dotCoord =
        function(a) {
            return this.a * a.x + this.b * a.y + this.c * a.z + this.d
        };
    b.dotNormal = function(a) {
        return this.a * a.x + this.b * a.y + this.c * a.z
    };
    a.math.Plane.fromPointNormal = function(b, e) {
        return new a.math.Plane(e.x, e.y, e.z, -e.dot(b))
    };
    a.math.Plane.fromPoints = function(b, e, f) {
        e = new a.math.Vec3(e);
        f = new a.math.Vec3(f);
        var g = new a.math.Plane;
        e.subtract(b);
        f.subtract(b);
        e.cross(f);
        e.normalize();
        g.a = e.x;
        g.b = e.y;
        g.c = e.z;
        g.d = e.scale(-1).dot(b);
        return g
    };
    b.normalize = function() {
        var b = new a.math.Vec3(this.a, this.b, this.c),
            e = 1 /
            b.length();
        b.normalize();
        this.a = b.x;
        this.b = b.y;
        this.c = b.z;
        this.d *= e;
        return this
    };
    b.classifyPoint = function(b) {
        b = this.a * b.x + this.b * b.y + this.c * b.z + this.d;
        return 0.0010 < b ? a.math.Plane.POINT_INFRONT_OF_PLANE : -0.0010 > b ? a.math.Plane.POINT_BEHIND_PLANE : a.math.Plane.POINT_ON_PLANE
    }
})(cc);
(function(a) {
    a.math.Quaternion = function(a, b, f, g) {
        a && void 0 === b ? (this.x = a.x, this.y = a.y, this.z = a.z, this.w = a.w) : (this.x = a || 0, this.y = b || 0, this.z = f || 0, this.w = g || 0)
    };
    a.kmQuaternion = a.math.Quaternion;
    var b = a.math.Quaternion.prototype;
    b.conjugate = function(a) {
        this.x = -a.x;
        this.y = -a.y;
        this.z = -a.z;
        this.w = a.w;
        return this
    };
    b.dot = function(a) {
        return this.w * a.w + this.x * a.x + this.y * a.y + this.z * a.z
    };
    b.exponential = function() {
        return this
    };
    b.identity = function() {
        this.z = this.y = this.x = 0;
        this.w = 1;
        return this
    };
    b.inverse = function() {
        var b =
            this.length();
        if (Math.abs(b) > a.math.EPSILON) return this.w = this.z = this.y = this.x = 0, this;
        this.conjugate(this).scale(1 / b);
        return this
    };
    b.isIdentity = function() {
        return 0 === this.x && 0 === this.y && 0 === this.z && 1 === this.w
    };
    b.length = function() {
        return Math.sqrt(this.lengthSq())
    };
    b.lengthSq = function() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    };
    b.multiply = function(a) {
        var b = this.x,
            f = this.y,
            g = this.z,
            h = this.w;
        this.w = h * a.w - b * a.x - f * a.y - g * a.z;
        this.x = h * a.x + b * a.w + f * a.z - g * a.y;
        this.y = h * a.y + f * a.w + g * a.x -
            b * a.z;
        this.z = h * a.z + g * a.w + b * a.y - f * a.x;
        return this
    };
    b.normalize = function() {
        var b = this.length();
        if (Math.abs(b) <= a.math.EPSILON) throw Error("current quaternion is an invalid value");
        this.scale(1 / b);
        return this
    };
    b.rotationAxis = function(a, b) {
        var f = 0.5 * b,
            g = Math.sin(f);
        this.w = Math.cos(f);
        this.x = a.x * g;
        this.y = a.y * g;
        this.z = a.z * g;
        return this
    };
    a.math.Quaternion.rotationMatrix = function(b) {
        if (!b) return null;
        var e, f, g;
        e = [];
        f = b.mat;
        b = 0;
        e[0] = f[0];
        e[1] = f[3];
        e[2] = f[6];
        e[4] = f[1];
        e[5] = f[4];
        e[6] = f[7];
        e[8] = f[2];
        e[9] = f[5];
        e[10] = f[8];
        e[15] = 1;
        var h = e[0];
        b = h[0] + h[5] + h[10] + 1;
        b > a.math.EPSILON ? (b = 2 * Math.sqrt(b), e = (h[9] - h[6]) / b, f = (h[2] - h[8]) / b, g = (h[4] - h[1]) / b, b *= 0.25) : h[0] > h[5] && h[0] > h[10] ? (b = 2 * Math.sqrt(1 + h[0] - h[5] - h[10]), e = 0.25 * b, f = (h[4] + h[1]) / b, g = (h[2] + h[8]) / b, b = (h[9] - h[6]) / b) : h[5] > h[10] ? (b = 2 * Math.sqrt(1 + h[5] - h[0] - h[10]), e = (h[4] + h[1]) / b, f = 0.25 * b, g = (h[9] + h[6]) / b, b = (h[2] - h[8]) / b) : (b = 2 * Math.sqrt(1 + h[10] - h[0] - h[5]), e = (h[2] + h[8]) / b, f = (h[9] + h[6]) / b, g = 0.25 * b, b = (h[4] - h[1]) / b);
        return new a.math.Quaternion(e, f, g, b)
    };
    a.math.Quaternion.rotationYawPitchRoll =
        function(b, e, f) {
            var g, h, k, m, n;
            g = a.degreesToRadians(e) / 2;
            h = a.degreesToRadians(b) / 2;
            k = a.degreesToRadians(f) / 2;
            f = Math.cos(g);
            b = Math.cos(h);
            e = Math.cos(k);
            g = Math.sin(g);
            h = Math.sin(h);
            k = Math.sin(k);
            m = b * e;
            n = h * k;
            var p = new a.math.Quaternion;
            p.w = f * m + g * n;
            p.x = g * m - f * n;
            p.y = f * h * e + g * b * k;
            p.z = f * b * k - g * h * e;
            p.normalize();
            return p
        };
    b.slerp = function(b, e) {
        if (this.x === b.x && this.y === b.y && this.z === b.z && this.w === b.w) return this;
        var f = this.dot(b),
            g = Math.acos(f),
            h = Math.sqrt(1 - a.math.square(f)),
            f = Math.sin(e * g) / h,
            g = Math.sin((1 -
                e) * g) / h,
            h = new a.math.Quaternion(b);
        this.scale(g);
        h.scale(f);
        this.add(h);
        return this
    };
    b.toAxisAndAngle = function() {
        var b, e, f = new a.math.Vec3;
        b = Math.acos(this.w);
        e = Math.sqrt(a.math.square(this.x) + a.math.square(this.y) + a.math.square(this.z));
        e > -a.math.EPSILON && e < a.math.EPSILON || e < 2 * Math.PI + a.math.EPSILON && e > 2 * Math.PI - a.math.EPSILON ? (b = 0, f.x = 0, f.y = 0, f.z = 1) : (b *= 2, f.x = this.x / e, f.y = this.y / e, f.z = this.z / e, f.normalize());
        return {
            axis: f,
            angle: b
        }
    };
    b.scale = function(a) {
        this.x *= a;
        this.y *= a;
        this.z *= a;
        this.w *= a;
        return this
    };
    b.assignFrom = function(a) {
        this.x = a.x;
        this.y = a.y;
        this.z = a.z;
        this.w = a.w;
        return this
    };
    b.add = function(a) {
        this.x += a.x;
        this.y += a.y;
        this.z += a.z;
        this.w += a.w;
        return this
    };
    a.math.Quaternion.rotationBetweenVec3 = function(b, e, f) {
        var g = new a.math.Vec3(b),
            h = new a.math.Vec3(e);
        g.normalize();
        h.normalize();
        var k = g.dot(h);
        e = new a.math.Quaternion;
        if (1 <= k) return e.identity(), e; - 0.999999 > k ? Math.abs(f.lengthSq()) < a.math.EPSILON ? e.rotationAxis(f, Math.PI) : (g = new a.math.Vec3(1, 0, 0), g.cross(b), Math.abs(g.lengthSq()) < a.math.EPSILON &&
            (g.fill(0, 1, 0), g.cross(b)), g.normalize(), e.rotationAxis(g, Math.PI)) : (b = Math.sqrt(2 * (1 + k)), f = 1 / b, g.cross(h), e.x = g.x * f, e.y = g.y * f, e.z = g.z * f, e.w = 0.5 * b, e.normalize());
        return e
    };
    b.multiplyVec3 = function(b) {
        var e = this.x,
            f = this.y,
            g = this.z,
            h = new a.math.Vec3(b),
            k = new a.math.Vec3(e, f, g),
            e = new a.math.Vec3(e, f, g);
        k.cross(b);
        e.cross(k);
        k.scale(2 * q.w);
        e.scale(2);
        h.add(k);
        h.add(e);
        return h
    }
})(cc);
cc.math.AABB = function(a, b) {
    this.min = a || new cc.math.Vec3;
    this.max = b || new cc.math.Vec3
};
cc.math.AABB.prototype.containsPoint = function(a) {
    return a.x >= this.min.x && a.x <= this.max.x && a.y >= this.min.y && a.y <= this.max.y && a.z >= this.min.z && a.z <= this.max.z
};
cc.math.AABB.containsPoint = function(a, b) {
    return a.x >= b.min.x && a.x <= b.max.x && a.y >= b.min.y && a.y <= b.max.y && a.z >= b.min.z && a.z <= b.max.z
};
cc.math.AABB.prototype.assignFrom = function(a) {
    this.min.assignFrom(a.min);
    this.max.assignFrom(a.max)
};
cc.math.AABB.assign = function(a, b) {
    a.min.assignFrom(b.min);
    a.max.assignFrom(b.max);
    return a
};
(function(a) {
    a.math.Matrix4Stack = function(a, b) {
        this.top = a;
        this.stack = b || []
    };
    a.km_mat4_stack = a.math.Matrix4Stack;
    var b = a.math.Matrix4Stack.prototype;
    b.initialize = function() {
        this.stack.length = 0;
        this.top = null
    };
    a.km_mat4_stack_push = function(b, e) {
        b.stack.push(b.top);
        b.top = new a.math.Matrix4(e)
    };
    a.km_mat4_stack_pop = function(a, b) {
        a.top = a.stack.pop()
    };
    a.km_mat4_stack_release = function(a) {
        a.stack = null;
        a.top = null
    };
    b.push = function(b) {
        b = b || this.top;
        this.stack.push(this.top);
        this.top = new a.math.Matrix4(b)
    };
    b.pop =
        function() {
            this.top = this.stack.pop()
        };
    b.release = function() {
        this._matrixPool = this.top = this.stack = null
    };
    b._getFromPool = function(b) {
        var e = this._matrixPool;
        if (0 === e.length) return new a.math.Matrix4(b);
        e = e.pop();
        e.assignFrom(b);
        return e
    };
    b._putInPool = function(a) {
        this._matrixPool.push(a)
    }
})(cc);
(function(a) {
    a.KM_GL_MODELVIEW = 5888;
    a.KM_GL_PROJECTION = 5889;
    a.KM_GL_TEXTURE = 5890;
    a.modelview_matrix_stack = new a.math.Matrix4Stack;
    a.projection_matrix_stack = new a.math.Matrix4Stack;
    a.texture_matrix_stack = new a.math.Matrix4Stack;
    a.current_stack = null;
    a.lazyInitialize = function() {
        var b = new a.math.Matrix4;
        a.modelview_matrix_stack.initialize();
        a.projection_matrix_stack.initialize();
        a.texture_matrix_stack.initialize();
        a.current_stack = a.modelview_matrix_stack;
        a.initialized = !0;
        b.identity();
        a.modelview_matrix_stack.push(b);
        a.projection_matrix_stack.push(b);
        a.texture_matrix_stack.push(b)
    };
    a.lazyInitialize();
    a.kmGLFreeAll = function() {
        a.modelview_matrix_stack.release();
        a.modelview_matrix_stack = null;
        a.projection_matrix_stack.release();
        a.projection_matrix_stack = null;
        a.texture_matrix_stack.release();
        a.texture_matrix_stack = null;
        a.initialized = !1;
        a.current_stack = null
    };
    a.kmGLPushMatrix = function() {
        a.current_stack.push(a.current_stack.top)
    };
    a.kmGLPushMatrixWitMat4 = function(b) {
        a.current_stack.stack.push(a.current_stack.top);
        b.assignFrom(a.current_stack.top);
        a.current_stack.top = b
    };
    a.kmGLPopMatrix = function() {
        a.current_stack.top = a.current_stack.stack.pop()
    };
    a.kmGLMatrixMode = function(b) {
        switch (b) {
            case a.KM_GL_MODELVIEW:
                a.current_stack = a.modelview_matrix_stack;
                break;
            case a.KM_GL_PROJECTION:
                a.current_stack = a.projection_matrix_stack;
                break;
            case a.KM_GL_TEXTURE:
                a.current_stack = a.texture_matrix_stack;
                break;
            default:
                throw Error("Invalid matrix mode specified");
        }
    };
    a.kmGLLoadIdentity = function() {
        a.current_stack.top.identity()
    };
    a.kmGLLoadMatrix = function(b) {
        a.current_stack.top.assignFrom(b)
    };
    a.kmGLMultMatrix = function(b) {
        a.current_stack.top.multiply(b)
    };
    var b = new a.math.Matrix4;
    a.kmGLTranslatef = function(d, f, g) {
        d = a.math.Matrix4.createByTranslation(d, f, g, b);
        a.current_stack.top.multiply(d)
    };
    var d = new a.math.Vec3;
    a.kmGLRotatef = function(e, f, g, h) {
        d.fill(f, g, h);
        e = a.math.Matrix4.createByAxisAndAngle(d, a.degreesToRadians(e), b);
        a.current_stack.top.multiply(e)
    };
    a.kmGLScalef = function(d, f, g) {
        d = a.math.Matrix4.createByScale(d, f, g, b);
        a.current_stack.top.multiply(d)
    };
    a.kmGLGetMatrix = function(b, d) {
        switch (b) {
            case a.KM_GL_MODELVIEW:
                d.assignFrom(a.modelview_matrix_stack.top);
                break;
            case a.KM_GL_PROJECTION:
                d.assignFrom(a.projection_matrix_stack.top);
                break;
            case a.KM_GL_TEXTURE:
                d.assignFrom(a.texture_matrix_stack.top);
                break;
            default:
                throw Error("Invalid matrix mode specified");
        }
    }
})(cc);
cc.SHADER_POSITION_UCOLOR_FRAG = "precision lowp float;\nvarying vec4 v_fragmentColor;\nvoid main()                              \n{ \n    gl_FragColor \x3d v_fragmentColor;      \n}\n";
cc.SHADER_POSITION_UCOLOR_VERT = "attribute vec4 a_position;\nuniform    vec4 u_color;\nuniform float u_pointSize;\nvarying lowp vec4 v_fragmentColor; \nvoid main(void)   \n{\n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n    gl_PointSize \x3d u_pointSize;          \n    v_fragmentColor \x3d u_color;           \n}";
cc.SHADER_POSITION_COLOR_FRAG = "precision lowp float; \nvarying vec4 v_fragmentColor; \nvoid main() \n{ \n     gl_FragColor \x3d v_fragmentColor; \n} ";
cc.SHADER_POSITION_COLOR_VERT = "attribute vec4 a_position;\nattribute vec4 a_color;\nvarying lowp vec4 v_fragmentColor;\nvoid main()\n{\n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_fragmentColor \x3d a_color;             \n}";
cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_FRAG = "// #extension GL_OES_standard_derivatives : enable\nvarying mediump vec4 v_color;\nvarying mediump vec2 v_texcoord;\nvoid main()\t\n{ \n// #if defined GL_OES_standard_derivatives\t\n// gl_FragColor \x3d v_color*smoothstep(0.0, length(fwidth(v_texcoord)), 1.0 - length(v_texcoord)); \n// #else\t\ngl_FragColor \x3d v_color * step(0.0, 1.0 - length(v_texcoord)); \n// #endif \n}";
cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_VERT = "attribute mediump vec4 a_position; \nattribute mediump vec2 a_texcoord; \nattribute mediump vec4 a_color;\t\nvarying mediump vec4 v_color; \nvarying mediump vec2 v_texcoord;\t\nvoid main() \n{ \n     v_color \x3d a_color;//vec4(a_color.rgb * a_color.a, a_color.a); \n     v_texcoord \x3d a_texcoord; \n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n}";
cc.SHADER_POSITION_TEXTURE_FRAG = "precision lowp float;   \nvarying vec2 v_texCoord;  \nvoid main() \n{  \n    gl_FragColor \x3d  texture2D(CC_Texture0, v_texCoord);   \n}";
cc.SHADER_POSITION_TEXTURE_VERT = "attribute vec4 a_position; \nattribute vec2 a_texCoord; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_texCoord \x3d a_texCoord;               \n}";
cc.SHADER_POSITION_TEXTURE_UCOLOR_FRAG = "precision lowp float;  \nuniform vec4 u_color; \nvarying vec2 v_texCoord; \nvoid main() \n{  \n    gl_FragColor \x3d  texture2D(CC_Texture0, v_texCoord) * u_color;    \n}";
cc.SHADER_POSITION_TEXTURE_UCOLOR_VERT = "attribute vec4 a_position;\nattribute vec2 a_texCoord; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_texCoord \x3d a_texCoord;                 \n}";
cc.SHADER_POSITION_TEXTURE_A8COLOR_FRAG = "precision lowp float;  \nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nvoid main() \n{ \n    gl_FragColor \x3d vec4( v_fragmentColor.rgb,         \n        v_fragmentColor.a * texture2D(CC_Texture0, v_texCoord).a   \n    ); \n}";
cc.SHADER_POSITION_TEXTURE_A8COLOR_VERT = "attribute vec4 a_position; \nattribute vec2 a_texCoord; \nattribute vec4 a_color;  \nvarying lowp vec4 v_fragmentColor; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_fragmentColor \x3d a_color; \n    v_texCoord \x3d a_texCoord; \n}";
cc.SHADER_POSITION_TEXTURE_COLOR_FRAG = "precision lowp float;\nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nvoid main() \n{ \n    gl_FragColor \x3d v_fragmentColor * texture2D(CC_Texture0, v_texCoord); \n}";
cc.SHADER_POSITION_TEXTURE_COLOR_VERT = "attribute vec4 a_position; \nattribute vec2 a_texCoord; \nattribute vec4 a_color;  \nvarying lowp vec4 v_fragmentColor; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_fragmentColor \x3d a_color; \n    v_texCoord \x3d a_texCoord; \n}";
cc.SHADER_POSITION_TEXTURE_COLOR_ALPHATEST_FRAG = "precision lowp float;   \nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord;   \nuniform float CC_alpha_value; \nvoid main() \n{  \n    vec4 texColor \x3d texture2D(CC_Texture0, v_texCoord);  \n    if ( texColor.a \x3c\x3d CC_alpha_value )          \n        discard; \n    gl_FragColor \x3d texColor * v_fragmentColor;  \n}";
cc.SHADEREX_SWITCHMASK_FRAG = "precision lowp float; \nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nuniform sampler2D u_texture;  \nuniform sampler2D   u_mask;   \nvoid main()  \n{  \n    vec4 texColor   \x3d texture2D(u_texture, v_texCoord);  \n    vec4 maskColor  \x3d texture2D(u_mask, v_texCoord); \n    vec4 finalColor \x3d vec4(texColor.r, texColor.g, texColor.b, maskColor.a * texColor.a);        \n    gl_FragColor    \x3d v_fragmentColor * finalColor; \n}";
cc.shaderCache = {
    TYPE_POSITION_TEXTURECOLOR: 0,
    TYPE_POSITION_TEXTURECOLOR_ALPHATEST: 1,
    TYPE_POSITION_COLOR: 2,
    TYPE_POSITION_TEXTURE: 3,
    TYPE_POSITION_TEXTURE_UCOLOR: 4,
    TYPE_POSITION_TEXTURE_A8COLOR: 5,
    TYPE_POSITION_UCOLOR: 6,
    TYPE_POSITION_LENGTH_TEXTURECOLOR: 7,
    TYPE_MAX: 8,
    _programs: {},
    _init: function() {
        this.loadDefaultShaders();
        return !0
    },
    _loadDefaultShader: function(a, b) {
        switch (b) {
            case this.TYPE_POSITION_TEXTURECOLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_COLOR_VERT, cc.SHADER_POSITION_TEXTURE_COLOR_FRAG);
                a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
                a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                break;
            case this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_COLOR_VERT, cc.SHADER_POSITION_TEXTURE_COLOR_ALPHATEST_FRAG);
                a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
                a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                break;
            case this.TYPE_POSITION_COLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_COLOR_VERT, cc.SHADER_POSITION_COLOR_FRAG);
                a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
                break;
            case this.TYPE_POSITION_TEXTURE:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_VERT, cc.SHADER_POSITION_TEXTURE_FRAG);
                a.addAttribute(cc.ATTRIBUTE_NAME_POSITION,
                    cc.VERTEX_ATTRIB_POSITION);
                a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                break;
            case this.TYPE_POSITION_TEXTURE_UCOLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_UCOLOR_VERT, cc.SHADER_POSITION_TEXTURE_UCOLOR_FRAG);
                a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                break;
            case this.TYPE_POSITION_TEXTURE_A8COLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_A8COLOR_VERT,
                    cc.SHADER_POSITION_TEXTURE_A8COLOR_FRAG);
                a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
                a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                break;
            case this.TYPE_POSITION_UCOLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_UCOLOR_VERT, cc.SHADER_POSITION_UCOLOR_FRAG);
                a.addAttribute("aVertex", cc.VERTEX_ATTRIB_POSITION);
                break;
            case this.TYPE_POSITION_LENGTH_TEXTURECOLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_VERT,
                    cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_FRAG);
                a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
                break;
            default:
                cc.log("cocos2d: cc.shaderCache._loadDefaultShader, error shader type");
                return
        }
        a.link();
        a.updateUniforms()
    },
    loadDefaultShaders: function() {
        var a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURECOLOR);
        this._programs[cc.SHADER_POSITION_TEXTURECOLOR] =
            a;
        this._programs.ShaderPositionTextureColor = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST);
        this._programs[cc.SHADER_POSITION_TEXTURECOLORALPHATEST] = a;
        this._programs.ShaderPositionTextureColorAlphaTest = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_COLOR);
        this._programs[cc.SHADER_POSITION_COLOR] = a;
        this._programs.ShaderPositionColor = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE);
        this._programs[cc.SHADER_POSITION_TEXTURE] =
            a;
        this._programs.ShaderPositionTexture = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE_UCOLOR);
        this._programs[cc.SHADER_POSITION_TEXTURE_UCOLOR] = a;
        this._programs.ShaderPositionTextureUColor = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE_A8COLOR);
        this._programs[cc.SHADER_POSITION_TEXTUREA8COLOR] = a;
        this._programs.ShaderPositionTextureA8Color = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_UCOLOR);
        this._programs[cc.SHADER_POSITION_UCOLOR] =
            a;
        this._programs.ShaderPositionUColor = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_LENGTH_TEXTURECOLOR);
        this._programs[cc.SHADER_POSITION_LENGTHTEXTURECOLOR] = a;
        this._programs.ShaderPositionLengthTextureColor = a
    },
    reloadDefaultShaders: function() {
        var a = this.programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURECOLOR);
        a = this.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST);
        a = this.programForKey(cc.SHADER_POSITION_COLOR);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_COLOR);
        a = this.programForKey(cc.SHADER_POSITION_TEXTURE);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE);
        a = this.programForKey(cc.SHADER_POSITION_TEXTURE_UCOLOR);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE_UCOLOR);
        a = this.programForKey(cc.SHADER_POSITION_TEXTUREA8COLOR);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE_A8COLOR);
        a = this.programForKey(cc.SHADER_POSITION_UCOLOR);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_UCOLOR)
    },
    programForKey: function(a) {
        return this._programs[a]
    },
    getProgram: function(a) {
        return this._programs[a]
    },
    addProgram: function(a, b) {
        this._programs[b] = a
    }
};
cc.HashUniformEntry = function(a, b, d) {
    this.value = a;
    this.location = b;
    this.hh = d || {}
};
cc.GLProgram = cc.Class.extend({
    _glContext: null,
    _programObj: null,
    _vertShader: null,
    _fragShader: null,
    _uniforms: null,
    _hashForUniforms: null,
    _usesTime: !1,
    _updateUniformLocation: function(a, b, d) {
        if (null == a) return !1;
        d = !0;
        for (var e = null, f = 0; f < this._hashForUniforms.length; f++) this._hashForUniforms[f].location == a && (e = this._hashForUniforms[f]);
        e ? e.value == b ? d = !1 : e.value = b : (e = new cc.HashUniformEntry, e.location = a, e.value = b, this._hashForUniforms.push(e));
        return d
    },
    _description: function() {
        return "\x3cCCGLProgram \x3d " +
            this.toString() + " | Program \x3d " + this._programObj.toString() + ", VertexShader \x3d " + this._vertShader.toString() + ", FragmentShader \x3d " + this._fragShader.toString() + "\x3e"
    },
    _compileShader: function(a, b, d) {
        if (!d || !a) return !1;
        d = (cc.GLProgram._isHighpSupported() ? "precision highp float;\n" : "precision mediump float;\n") + "uniform mat4 CC_PMatrix;         \nuniform mat4 CC_MVMatrix;        \nuniform mat4 CC_MVPMatrix;       \nuniform vec4 CC_Time;            \nuniform vec4 CC_SinTime;         \nuniform vec4 CC_CosTime;         \nuniform vec4 CC_Random01;        \nuniform sampler2D CC_Texture0;   \n//CC INCLUDES END                \n" +
            d;
        this._glContext.shaderSource(a, d);
        this._glContext.compileShader(a);
        d = this._glContext.getShaderParameter(a, this._glContext.COMPILE_STATUS);
        d || (cc.log("cocos2d: ERROR: Failed to compile shader:\n" + this._glContext.getShaderSource(a)), b === this._glContext.VERTEX_SHADER ? cc.log("cocos2d: \n" + this.vertexShaderLog()) : cc.log("cocos2d: \n" + this.fragmentShaderLog()));
        return !0 === d
    },
    ctor: function(a, b, d) {
        this._uniforms = [];
        this._hashForUniforms = [];
        this._glContext = d || cc._renderContext;
        a && b && this.init(a, b)
    },
    destroyProgram: function() {
        this._hashForUniforms =
            this._uniforms = this._fragShader = this._vertShader = null;
        this._glContext.deleteProgram(this._programObj)
    },
    initWithVertexShaderByteArray: function(a, b) {
        var d = this._glContext;
        this._programObj = d.createProgram();
        this._fragShader = this._vertShader = null;
        a && (this._vertShader = d.createShader(d.VERTEX_SHADER), this._compileShader(this._vertShader, d.VERTEX_SHADER, a) || cc.log("cocos2d: ERROR: Failed to compile vertex shader"));
        b && (this._fragShader = d.createShader(d.FRAGMENT_SHADER), this._compileShader(this._fragShader,
            d.FRAGMENT_SHADER, b) || cc.log("cocos2d: ERROR: Failed to compile fragment shader"));
        this._vertShader && d.attachShader(this._programObj, this._vertShader);
        cc.checkGLErrorDebug();
        this._fragShader && d.attachShader(this._programObj, this._fragShader);
        this._hashForUniforms.length = 0;
        cc.checkGLErrorDebug();
        return !0
    },
    initWithString: function(a, b) {
        return this.initWithVertexShaderByteArray(a, b)
    },
    initWithVertexShaderFilename: function(a, b) {
        var d = cc.loader.getRes(a);
        if (!d) throw Error("Please load the resource firset : " +
            a);
        var e = cc.loader.getRes(b);
        if (!e) throw Error("Please load the resource firset : " + b);
        return this.initWithVertexShaderByteArray(d, e)
    },
    init: function(a, b) {
        return this.initWithVertexShaderFilename(a, b)
    },
    addAttribute: function(a, b) {
        this._glContext.bindAttribLocation(this._programObj, b, a)
    },
    link: function() {
        if (!this._programObj) return cc.log("cc.GLProgram.link(): Cannot link invalid program"), !1;
        this._glContext.linkProgram(this._programObj);
        this._vertShader && this._glContext.deleteShader(this._vertShader);
        this._fragShader && this._glContext.deleteShader(this._fragShader);
        this._fragShader = this._vertShader = null;
        return cc.game.config[cc.game.CONFIG_KEY.debugMode] && !this._glContext.getProgramParameter(this._programObj, this._glContext.LINK_STATUS) ? (cc.log("cocos2d: ERROR: Failed to link program: " + this._glContext.getProgramInfoLog(this._programObj)), cc.glDeleteProgram(this._programObj), this._programObj = null, !1) : !0
    },
    use: function() {
        cc.glUseProgram(this._programObj)
    },
    updateUniforms: function() {
        this._uniforms[cc.UNIFORM_PMATRIX] =
            this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_PMATRIX_S);
        this._uniforms[cc.UNIFORM_MVMATRIX] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_MVMATRIX_S);
        this._uniforms[cc.UNIFORM_MVPMATRIX] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_MVPMATRIX_S);
        this._uniforms[cc.UNIFORM_TIME] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_TIME_S);
        this._uniforms[cc.UNIFORM_SINTIME] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_SINTIME_S);
        this._uniforms[cc.UNIFORM_COSTIME] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_COSTIME_S);
        this._usesTime = null != this._uniforms[cc.UNIFORM_TIME] || null != this._uniforms[cc.UNIFORM_SINTIME] || null != this._uniforms[cc.UNIFORM_COSTIME];
        this._uniforms[cc.UNIFORM_RANDOM01] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_RANDOM01_S);
        this._uniforms[cc.UNIFORM_SAMPLER] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_SAMPLER_S);
        this.use();
        this.setUniformLocationWith1i(this._uniforms[cc.UNIFORM_SAMPLER],
            0)
    },
    getUniformLocationForName: function(a) {
        if (!a) throw Error("cc.GLProgram.getUniformLocationForName(): uniform name should be non-null");
        if (!this._programObj) throw Error("cc.GLProgram.getUniformLocationForName(): Invalid operation. Cannot get uniform location when program is not initialized");
        return this._glContext.getUniformLocation(this._programObj, a)
    },
    getUniformMVPMatrix: function() {
        return this._uniforms[cc.UNIFORM_MVPMATRIX]
    },
    getUniformSampler: function() {
        return this._uniforms[cc.UNIFORM_SAMPLER]
    },
    setUniformLocationWith1i: function(a, b) {
        this._updateUniformLocation(a, b) && this._glContext.uniform1i(a, b)
    },
    setUniformLocationWith2i: function(a, b, d) {
        this._updateUniformLocation(a, [b, d]) && this._glContext.uniform2i(a, b, d)
    },
    setUniformLocationWith3i: function(a, b, d, e) {
        this._updateUniformLocation(a, [b, d, e]) && this._glContext.uniform3i(a, b, d, e)
    },
    setUniformLocationWith4i: function(a, b, d, e, f) {
        this._updateUniformLocation(a, [b, d, e, f]) && this._glContext.uniform4i(a, b, d, e, f)
    },
    setUniformLocationWith2iv: function(a, b,
        d) {
        this._updateUniformLocation(a, b) && this._glContext.uniform2iv(a, b)
    },
    setUniformLocationWith3iv: function(a, b, d) {
        this._updateUniformLocation(a, b) && this._glContext.uniform3iv(a, b)
    },
    setUniformLocationWith4iv: function(a, b, d) {
        this._updateUniformLocation(a, b) && this._glContext.uniform4iv(a, b)
    },
    setUniformLocationI32: function(a, b) {
        this.setUniformLocationWith1i(a, b)
    },
    setUniformLocationWith1f: function(a, b) {
        this._updateUniformLocation(a, b) && this._glContext.uniform1f(a, b)
    },
    setUniformLocationWith2f: function(a,
        b, d) {
        this._updateUniformLocation(a, [b, d]) && this._glContext.uniform2f(a, b, d)
    },
    setUniformLocationWith3f: function(a, b, d, e) {
        this._updateUniformLocation(a, [b, d, e]) && this._glContext.uniform3f(a, b, d, e)
    },
    setUniformLocationWith4f: function(a, b, d, e, f) {
        this._updateUniformLocation(a, [b, d, e, f]) && this._glContext.uniform4f(a, b, d, e, f)
    },
    setUniformLocationWith2fv: function(a, b, d) {
        this._updateUniformLocation(a, b) && this._glContext.uniform2fv(a, b)
    },
    setUniformLocationWith3fv: function(a, b, d) {
        this._updateUniformLocation(a,
            b) && this._glContext.uniform3fv(a, b)
    },
    setUniformLocationWith4fv: function(a, b, d) {
        this._updateUniformLocation(a, b) && this._glContext.uniform4fv(a, b)
    },
    setUniformLocationWithMatrix4fv: function(a, b, d) {
        this._updateUniformLocation(a, b) && this._glContext.uniformMatrix4fv(a, !1, b)
    },
    setUniformLocationF32: function() {
        if (!(2 > arguments.length)) switch (arguments.length) {
            case 2:
                this.setUniformLocationWith1f(arguments[0], arguments[1]);
                break;
            case 3:
                this.setUniformLocationWith2f(arguments[0], arguments[1], arguments[2]);
                break;
            case 4:
                this.setUniformLocationWith3f(arguments[0], arguments[1], arguments[2], arguments[3]);
                break;
            case 5:
                this.setUniformLocationWith4f(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4])
        }
    },
    setUniformsForBuiltins: function() {
        var a = new cc.math.Matrix4,
            b = new cc.math.Matrix4,
            d = new cc.math.Matrix4;
        cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, a);
        cc.kmGLGetMatrix(cc.KM_GL_MODELVIEW, b);
        cc.kmMat4Multiply(d, a, b);
        this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], a.mat, 1);
        this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX],
            b.mat, 1);
        this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], d.mat, 1);
        this._usesTime && (a = cc.director, a = a.getTotalFrames() * a.getAnimationInterval(), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_TIME], a / 10, a, 2 * a, 4 * a), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_SINTIME], a / 8, a / 4, a / 2, Math.sin(a)), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_COSTIME], a / 8, a / 4, a / 2, Math.cos(a))); - 1 !== this._uniforms[cc.UNIFORM_RANDOM01] && this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_RANDOM01],
            Math.random(), Math.random(), Math.random(), Math.random())
    },
    _setUniformsForBuiltinsForRenderer: function(a) {
        if (a && a._renderCmd) {
            var b = new cc.math.Matrix4,
                d = new cc.math.Matrix4;
            cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, b);
            cc.kmMat4Multiply(d, b, a._renderCmd._stackMatrix);
            this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], b.mat, 1);
            this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX], a._renderCmd._stackMatrix.mat, 1);
            this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX],
                d.mat, 1);
            this._usesTime && (a = cc.director, a = a.getTotalFrames() * a.getAnimationInterval(), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_TIME], a / 10, a, 2 * a, 4 * a), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_SINTIME], a / 8, a / 4, a / 2, Math.sin(a)), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_COSTIME], a / 8, a / 4, a / 2, Math.cos(a))); - 1 !== this._uniforms[cc.UNIFORM_RANDOM01] && this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_RANDOM01], Math.random(), Math.random(), Math.random(), Math.random())
        }
    },
    setUniformForModelViewProjectionMatrix: function() {
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], !1, cc.getMat4MultiplyValue(cc.projection_matrix_stack.top, cc.modelview_matrix_stack.top))
    },
    setUniformForModelViewProjectionMatrixWithMat4: function(a) {
        cc.kmMat4Multiply(a, cc.projection_matrix_stack.top, cc.modelview_matrix_stack.top);
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], !1, a.mat)
    },
    setUniformForModelViewAndProjectionMatrixWithMat4: function() {
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX], !1, cc.modelview_matrix_stack.top.mat);
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], !1, cc.projection_matrix_stack.top.mat)
    },
    _setUniformForMVPMatrixWithMat4: function(a) {
        if (!a) throw Error("modelView matrix is undefined.");
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX], !1, a.mat);
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], !1, cc.projection_matrix_stack.top.mat)
    },
    vertexShaderLog: function() {
        return this._glContext.getShaderInfoLog(this._vertShader)
    },
    getVertexShaderLog: function() {
        return this._glContext.getShaderInfoLog(this._vertShader)
    },
    getFragmentShaderLog: function() {
        return this._glContext.getShaderInfoLog(this._vertShader)
    },
    fragmentShaderLog: function() {
        return this._glContext.getShaderInfoLog(this._fragShader)
    },
    programLog: function() {
        return this._glContext.getProgramInfoLog(this._programObj)
    },
    getProgramLog: function() {
        return this._glContext.getProgramInfoLog(this._programObj)
    },
    reset: function() {
        this._fragShader = this._vertShader = null;
        this._uniforms.length =
            0;
        this._glContext.deleteProgram(this._programObj);
        this._programObj = null;
        for (var a = 0; a < this._hashForUniforms.length; a++) this._hashForUniforms[a].value = null, this._hashForUniforms[a] = null;
        this._hashForUniforms.length = 0
    },
    getProgram: function() {
        return this._programObj
    },
    retain: function() {},
    release: function() {}
});
cc.GLProgram.create = function(a, b) {
    return new cc.GLProgram(a, b)
};
cc.GLProgram._highpSupported = null;
cc.GLProgram._isHighpSupported = function() {
    if (null == cc.GLProgram._highpSupported) {
        var a = cc._renderContext,
            a = a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.HIGH_FLOAT);
        cc.GLProgram._highpSupported = 0 !== a.precision
    }
    return cc.GLProgram._highpSupported
};
cc.setProgram = function(a, b) {
    a.shaderProgram = b;
    var d = a.children;
    if (d)
        for (var e = 0; e < d.length; e++) cc.setProgram(d[e], b)
};
cc._currentProjectionMatrix = -1;
cc._vertexAttribPosition = !1;
cc._vertexAttribColor = !1;
cc._vertexAttribTexCoords = !1;
cc.ENABLE_GL_STATE_CACHE && (cc.MAX_ACTIVETEXTURE = 16, cc._currentShaderProgram = -1, cc._currentBoundTexture = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], cc._blendingSource = -1, cc._blendingDest = -1, cc._GLServerState = 0, cc.TEXTURE_ATLAS_USE_VAO && (cc._uVAO = 0));
cc.glInvalidateStateCache = function() {
    cc.kmGLFreeAll();
    cc._currentProjectionMatrix = -1;
    cc._vertexAttribPosition = !1;
    cc._vertexAttribColor = !1;
    cc._vertexAttribTexCoords = !1;
    if (cc.ENABLE_GL_STATE_CACHE) {
        cc._currentShaderProgram = -1;
        for (var a = 0; a < cc.MAX_ACTIVETEXTURE; a++) cc._currentBoundTexture[a] = -1;
        cc._blendingSource = -1;
        cc._blendingDest = -1;
        cc._GLServerState = 0
    }
};
cc.glUseProgram = function(a) {
    a !== cc._currentShaderProgram && (cc._currentShaderProgram = a, cc._renderContext.useProgram(a))
};
cc.ENABLE_GL_STATE_CACHE || (cc.glUseProgram = function(a) {
    cc._renderContext.useProgram(a)
});
cc.glDeleteProgram = function(a) {
    cc.ENABLE_GL_STATE_CACHE && a === cc._currentShaderProgram && (cc._currentShaderProgram = -1);
    gl.deleteProgram(a)
};
cc.glBlendFunc = function(a, b) {
    if (a !== cc._blendingSource || b !== cc._blendingDest) cc._blendingSource = a, cc._blendingDest = b, cc.setBlending(a, b)
};
cc.setBlending = function(a, b) {
    var d = cc._renderContext;
    a === d.ONE && b === d.ZERO ? d.disable(d.BLEND) : (d.enable(d.BLEND), cc._renderContext.blendFunc(a, b))
};
cc.glBlendFuncForParticle = function(a, b) {
    if (a !== cc._blendingSource || b !== cc._blendingDest) {
        cc._blendingSource = a;
        cc._blendingDest = b;
        var d = cc._renderContext;
        a === d.ONE && b === d.ZERO ? d.disable(d.BLEND) : (d.enable(d.BLEND), d.blendFuncSeparate(d.SRC_ALPHA, b, a, b))
    }
};
cc.ENABLE_GL_STATE_CACHE || (cc.glBlendFunc = cc.setBlending);
cc.glBlendResetToCache = function() {
    var a = cc._renderContext;
    a.blendEquation(a.FUNC_ADD);
    cc.ENABLE_GL_STATE_CACHE ? cc.setBlending(cc._blendingSource, cc._blendingDest) : cc.setBlending(a.BLEND_SRC, a.BLEND_DST)
};
cc.setProjectionMatrixDirty = function() {
    cc._currentProjectionMatrix = -1
};
cc.glEnableVertexAttribs = function(a) {
    var b = cc._renderContext,
        d = a & cc.VERTEX_ATTRIB_FLAG_POSITION;
    d !== cc._vertexAttribPosition && (d ? b.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION) : b.disableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION), cc._vertexAttribPosition = d);
    d = a & cc.VERTEX_ATTRIB_FLAG_COLOR;
    d !== cc._vertexAttribColor && (d ? b.enableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR) : b.disableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR), cc._vertexAttribColor = d);
    a &= cc.VERTEX_ATTRIB_FLAG_TEX_COORDS;
    a !== cc._vertexAttribTexCoords &&
        (a ? b.enableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS) : b.disableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS), cc._vertexAttribTexCoords = a)
};
cc.glBindTexture2D = function(a) {
    cc.glBindTexture2DN(0, a)
};
cc.glBindTexture2DN = function(a, b) {
    if (cc._currentBoundTexture[a] !== b) {
        cc._currentBoundTexture[a] = b;
        var d = cc._renderContext;
        d.activeTexture(d.TEXTURE0 + a);
        b ? d.bindTexture(d.TEXTURE_2D, b._webTextureObj) : d.bindTexture(d.TEXTURE_2D, null)
    }
};
cc.ENABLE_GL_STATE_CACHE || (cc.glBindTexture2DN = function(a, b) {
    var d = cc._renderContext;
    d.activeTexture(d.TEXTURE0 + a);
    b ? d.bindTexture(d.TEXTURE_2D, b._webTextureObj) : d.bindTexture(d.TEXTURE_2D, null)
});
cc.glDeleteTexture = function(a) {
    cc.glDeleteTextureN(0, a)
};
cc.glDeleteTextureN = function(a, b) {
    cc.ENABLE_GL_STATE_CACHE && b === cc._currentBoundTexture[a] && (cc._currentBoundTexture[a] = -1);
    cc._renderContext.deleteTexture(b)
};
cc.glBindVAO = function(a) {
    cc.TEXTURE_ATLAS_USE_VAO && (cc.ENABLE_GL_STATE_CACHE && cc._uVAO !== a) && (cc._uVAO = a)
};
cc.glEnable = function(a) {};
cc.ACTION_TAG_INVALID = -1;
cc.Action = cc.Class.extend({
    originalTarget: null,
    target: null,
    tag: cc.ACTION_TAG_INVALID,
    ctor: function() {
        this.target = this.originalTarget = null;
        this.tag = cc.ACTION_TAG_INVALID
    },
    copy: function() {
        cc.log("copy is deprecated. Please use clone instead.");
        return this.clone()
    },
    clone: function() {
        var a = new cc.Action;
        a.originalTarget = null;
        a.target = null;
        a.tag = this.tag;
        return a
    },
    isDone: function() {
        return !0
    },
    startWithTarget: function(a) {
        this.target = this.originalTarget = a
    },
    stop: function() {
        this.target = null
    },
    step: function(a) {
        cc.log("[Action step]. override me")
    },
    update: function(a) {
        cc.log("[Action update]. override me")
    },
    getTarget: function() {
        return this.target
    },
    setTarget: function(a) {
        this.target = a
    },
    getOriginalTarget: function() {
        return this.originalTarget
    },
    setOriginalTarget: function(a) {
        this.originalTarget = a
    },
    getTag: function() {
        return this.tag
    },
    setTag: function(a) {
        this.tag = a
    },
    retain: function() {},
    release: function() {}
});
cc.action = function() {
    return new cc.Action
};
cc.Action.create = cc.action;
cc.FiniteTimeAction = cc.Action.extend({
    _duration: 0,
    ctor: function() {
        cc.Action.prototype.ctor.call(this);
        this._duration = 0
    },
    getDuration: function() {
        return this._duration * (this._timesForRepeat || 1)
    },
    setDuration: function(a) {
        this._duration = a
    },
    reverse: function() {
        cc.log("cocos2d: FiniteTimeAction#reverse: Implement me");
        return null
    },
    clone: function() {
        return new cc.FiniteTimeAction
    }
});
cc.Speed = cc.Action.extend({
    _speed: 0,
    _innerAction: null,
    ctor: function(a, b) {
        cc.Action.prototype.ctor.call(this);
        this._speed = 0;
        this._innerAction = null;
        a && this.initWithAction(a, b)
    },
    getSpeed: function() {
        return this._speed
    },
    setSpeed: function(a) {
        this._speed = a
    },
    initWithAction: function(a, b) {
        if (!a) throw Error("cc.Speed.initWithAction(): action must be non nil");
        this._innerAction = a;
        this._speed = b;
        return !0
    },
    clone: function() {
        var a = new cc.Speed;
        a.initWithAction(this._innerAction.clone(), this._speed);
        return a
    },
    startWithTarget: function(a) {
        cc.Action.prototype.startWithTarget.call(this,
            a);
        this._innerAction.startWithTarget(a)
    },
    stop: function() {
        this._innerAction.stop();
        cc.Action.prototype.stop.call(this)
    },
    step: function(a) {
        this._innerAction.step(a * this._speed)
    },
    isDone: function() {
        return this._innerAction.isDone()
    },
    reverse: function() {
        return new cc.Speed(this._innerAction.reverse(), this._speed)
    },
    setInnerAction: function(a) {
        this._innerAction !== a && (this._innerAction = a)
    },
    getInnerAction: function() {
        return this._innerAction
    }
});
cc.speed = function(a, b) {
    return new cc.Speed(a, b)
};
cc.Speed.create = cc.speed;
cc.Follow = cc.Action.extend({
    _followedNode: null,
    _boundarySet: !1,
    _boundaryFullyCovered: !1,
    _halfScreenSize: null,
    _fullScreenSize: null,
    _worldRect: null,
    leftBoundary: 0,
    rightBoundary: 0,
    topBoundary: 0,
    bottomBoundary: 0,
    ctor: function(a, b) {
        cc.Action.prototype.ctor.call(this);
        this._followedNode = null;
        this._boundaryFullyCovered = this._boundarySet = !1;
        this._fullScreenSize = this._halfScreenSize = null;
        this.bottomBoundary = this.topBoundary = this.rightBoundary = this.leftBoundary = 0;
        this._worldRect = cc.rect(0, 0, 0, 0);
        a && (b ? this.initWithTarget(a,
            b) : this.initWithTarget(a))
    },
    clone: function() {
        var a = new cc.Follow,
            b = this._worldRect,
            b = new cc.Rect(b.x, b.y, b.width, b.height);
        a.initWithTarget(this._followedNode, b);
        return a
    },
    isBoundarySet: function() {
        return this._boundarySet
    },
    setBoudarySet: function(a) {
        this._boundarySet = a
    },
    initWithTarget: function(a, b) {
        if (!a) throw Error("cc.Follow.initWithAction(): followedNode must be non nil");
        b = b || cc.rect(0, 0, 0, 0);
        this._followedNode = a;
        this._worldRect = b;
        this._boundarySet = !cc._rectEqualToZero(b);
        this._boundaryFullyCovered = !1;
        var d = cc.director.getWinSize();
        this._fullScreenSize = cc.p(d.width, d.height);
        this._halfScreenSize = cc.pMult(this._fullScreenSize, 0.5);
        this._boundarySet && (this.leftBoundary = -(b.x + b.width - this._fullScreenSize.x), this.rightBoundary = -b.x, this.topBoundary = -b.y, this.bottomBoundary = -(b.y + b.height - this._fullScreenSize.y), this.rightBoundary < this.leftBoundary && (this.rightBoundary = this.leftBoundary = (this.leftBoundary + this.rightBoundary) / 2), this.topBoundary < this.bottomBoundary && (this.topBoundary = this.bottomBoundary =
            (this.topBoundary + this.bottomBoundary) / 2), this.topBoundary === this.bottomBoundary && this.leftBoundary === this.rightBoundary && (this._boundaryFullyCovered = !0));
        return !0
    },
    step: function(a) {
        a = this._followedNode.x;
        var b = this._followedNode.y;
        a = this._halfScreenSize.x - a;
        b = this._halfScreenSize.y - b;
        this.target._renderCmd._dirtyFlag = 0;
        this._boundarySet ? this._boundaryFullyCovered || this.target.setPosition(cc.clampf(a, this.leftBoundary, this.rightBoundary), cc.clampf(b, this.bottomBoundary, this.topBoundary)) : this.target.setPosition(a,
            b)
    },
    isDone: function() {
        return !this._followedNode.running
    },
    stop: function() {
        this.target = null;
        cc.Action.prototype.stop.call(this)
    }
});
cc.follow = function(a, b) {
    return new cc.Follow(a, b)
};
cc.Follow.create = cc.follow;
cc.ActionInterval = cc.FiniteTimeAction.extend({
    _elapsed: 0,
    _firstTick: !1,
    _easeList: null,
    _timesForRepeat: 1,
    _repeatForever: !1,
    _repeatMethod: !1,
    _speed: 1,
    _speedMethod: !1,
    ctor: function(a) {
        this._timesForRepeat = this._speed = 1;
        this._repeatForever = !1;
        this.MAX_VALUE = 2;
        this._speedMethod = this._repeatMethod = !1;
        cc.FiniteTimeAction.prototype.ctor.call(this);
        void 0 !== a && this.initWithDuration(a)
    },
    getElapsed: function() {
        return this._elapsed
    },
    initWithDuration: function(a) {
        this._duration = 0 === a ? cc.FLT_EPSILON : a;
        this._elapsed =
            0;
        return this._firstTick = !0
    },
    isDone: function() {
        return this._elapsed >= this._duration
    },
    _cloneDecoration: function(a) {
        a._repeatForever = this._repeatForever;
        a._speed = this._speed;
        a._timesForRepeat = this._timesForRepeat;
        a._easeList = this._easeList;
        a._speedMethod = this._speedMethod;
        a._repeatMethod = this._repeatMethod
    },
    _reverseEaseList: function(a) {
        if (this._easeList) {
            a._easeList = [];
            for (var b = 0; b < this._easeList.length; b++) a._easeList.push(this._easeList[b].reverse())
        }
    },
    clone: function() {
        var a = new cc.ActionInterval(this._duration);
        this._cloneDecoration(a);
        return a
    },
    easing: function(a) {
        this._easeList ? this._easeList.length = 0 : this._easeList = [];
        for (var b = 0; b < arguments.length; b++) this._easeList.push(arguments[b]);
        return this
    },
    _computeEaseTime: function(a) {
        var b = this._easeList;
        if (!b || 0 === b.length) return a;
        for (var d = 0, e = b.length; d < e; d++) a = b[d].easing(a);
        return a
    },
    step: function(a) {
        this._firstTick ? (this._firstTick = !1, this._elapsed = 0) : this._elapsed += a;
        a = this._elapsed / (1.192092896E-7 < this._duration ? this._duration : 1.192092896E-7);
        a = 1 > a ?
            a : 1;
        this.update(0 < a ? a : 0);
        this._repeatMethod && (1 < this._timesForRepeat && this.isDone()) && (this._repeatForever || this._timesForRepeat--, this.startWithTarget(this.target), this.step(this._elapsed - this._duration))
    },
    startWithTarget: function(a) {
        cc.Action.prototype.startWithTarget.call(this, a);
        this._elapsed = 0;
        this._firstTick = !0
    },
    reverse: function() {
        cc.log("cc.IntervalAction: reverse not implemented.");
        return null
    },
    setAmplitudeRate: function(a) {
        cc.log("cc.ActionInterval.setAmplitudeRate(): it should be overridden in subclass.")
    },
    getAmplitudeRate: function() {
        cc.log("cc.ActionInterval.getAmplitudeRate(): it should be overridden in subclass.");
        return 0
    },
    speed: function(a) {
        if (0 >= a) return cc.log("The speed parameter error"), this;
        this._speedMethod = !0;
        this._speed *= a;
        return this
    },
    getSpeed: function() {
        return this._speed
    },
    setSpeed: function(a) {
        this._speed = a;
        return this
    },
    repeat: function(a) {
        a = Math.round(a);
        if (isNaN(a) || 1 > a) return cc.log("The repeat parameter error"), this;
        this._repeatMethod = !0;
        this._timesForRepeat *= a;
        return this
    },
    repeatForever: function() {
        this._repeatMethod = !0;
        this._timesForRepeat = this.MAX_VALUE;
        this._repeatForever = !0;
        return this
    }
});
cc.actionInterval = function(a) {
    return new cc.ActionInterval(a)
};
cc.ActionInterval.create = cc.actionInterval;
cc.Sequence = cc.ActionInterval.extend({
    _actions: null,
    _split: null,
    _last: 0,
    ctor: function(a) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._actions = [];
        var b = a instanceof Array ? a : arguments,
            d = b.length - 1;
        0 <= d && null == b[d] && cc.log("parameters should not be ending with null in Javascript");
        if (0 <= d) {
            for (var e = b[0], f = 1; f < d; f++) b[f] && (e = cc.Sequence._actionOneTwo(e, b[f]));
            this.initWithTwoActions(e, b[d])
        }
    },
    initWithTwoActions: function(a, b) {
        if (!a || !b) throw Error("cc.Sequence.initWithTwoActions(): arguments must all be non nil");
        this.initWithDuration(a._duration + b._duration);
        this._actions[0] = a;
        this._actions[1] = b;
        return !0
    },
    clone: function() {
        var a = new cc.Sequence;
        this._cloneDecoration(a);
        a.initWithTwoActions(this._actions[0].clone(), this._actions[1].clone());
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._split = this._actions[0]._duration / this._duration;
        this._last = -1
    },
    stop: function() {
        -1 !== this._last && this._actions[this._last].stop();
        cc.Action.prototype.stop.call(this)
    },
    update: function(a) {
        var b =
            0,
            d = this._split,
            e = this._actions,
            f = this._last;
        a = this._computeEaseTime(a);
        a < d ? (a = 0 !== d ? a / d : 1, 0 === b && 1 === f && (e[1].update(0), e[1].stop())) : (b = 1, a = 1 === d ? 1 : (a - d) / (1 - d), -1 === f && (e[0].startWithTarget(this.target), e[0].update(1), e[0].stop()), f || (e[0].update(1), e[0].stop()));
        e = e[b];
        f === b && e.isDone() || (f !== b && e.startWithTarget(this.target), a *= e._timesForRepeat, e.update(1 < a ? a % 1 : a), this._last = b)
    },
    reverse: function() {
        var a = cc.Sequence._actionOneTwo(this._actions[1].reverse(), this._actions[0].reverse());
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.sequence = function(a) {
    var b = a instanceof Array ? a : arguments;
    0 < b.length && null == b[b.length - 1] && cc.log("parameters should not be ending with null in Javascript");
    for (var d, e, f, g; b && 0 < b.length;) {
        e = Array.prototype.shift.call(b);
        g = e._timesForRepeat || 1;
        e._repeatMethod = !1;
        e._timesForRepeat = 1;
        f = 0;
        d || (d = e, f = 1);
        for (f; f < g; f++) d = cc.Sequence._actionOneTwo(d, e)
    }
    return d
};
cc.Sequence.create = cc.sequence;
cc.Sequence._actionOneTwo = function(a, b) {
    var d = new cc.Sequence;
    d.initWithTwoActions(a, b);
    return d
};
cc.Repeat = cc.ActionInterval.extend({
    _times: 0,
    _total: 0,
    _nextDt: 0,
    _actionInstant: !1,
    _innerAction: null,
    ctor: function(a, b) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== b && this.initWithAction(a, b)
    },
    initWithAction: function(a, b) {
        return this.initWithDuration(a._duration * b) ? (this._times = b, this._innerAction = a, a instanceof cc.ActionInstant && (this._actionInstant = !0, this._times -= 1), this._total = 0, !0) : !1
    },
    clone: function() {
        var a = new cc.Repeat;
        this._cloneDecoration(a);
        a.initWithAction(this._innerAction.clone(),
            this._times);
        return a
    },
    startWithTarget: function(a) {
        this._total = 0;
        this._nextDt = this._innerAction._duration / this._duration;
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._innerAction.startWithTarget(a)
    },
    stop: function() {
        this._innerAction.stop();
        cc.Action.prototype.stop.call(this)
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        var b = this._innerAction,
            d = this._duration,
            e = this._times,
            f = this._nextDt;
        if (a >= f) {
            for (; a > f && this._total < e;) b.update(1), this._total++, b.stop(), b.startWithTarget(this.target),
                this._nextDt = f += b._duration / d;
            1 <= a && this._total < e && this._total++;
            this._actionInstant || (this._total === e ? (b.update(1), b.stop()) : b.update(a - (f - b._duration / d)))
        } else b.update(a * e % 1)
    },
    isDone: function() {
        return this._total === this._times
    },
    reverse: function() {
        var a = new cc.Repeat(this._innerAction.reverse(), this._times);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    },
    setInnerAction: function(a) {
        this._innerAction !== a && (this._innerAction = a)
    },
    getInnerAction: function() {
        return this._innerAction
    }
});
cc.repeat = function(a, b) {
    return new cc.Repeat(a, b)
};
cc.Repeat.create = cc.repeat;
cc.RepeatForever = cc.ActionInterval.extend({
    _innerAction: null,
    ctor: function(a) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._innerAction = null;
        a && this.initWithAction(a)
    },
    initWithAction: function(a) {
        if (!a) throw Error("cc.RepeatForever.initWithAction(): action must be non null");
        this._innerAction = a;
        return !0
    },
    clone: function() {
        var a = new cc.RepeatForever;
        this._cloneDecoration(a);
        a.initWithAction(this._innerAction.clone());
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this,
            a);
        this._innerAction.startWithTarget(a)
    },
    step: function(a) {
        var b = this._innerAction;
        b.step(a);
        b.isDone() && (b.startWithTarget(this.target), b.step(b.getElapsed() - b._duration))
    },
    isDone: function() {
        return !1
    },
    reverse: function() {
        var a = new cc.RepeatForever(this._innerAction.reverse());
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    },
    setInnerAction: function(a) {
        this._innerAction !== a && (this._innerAction = a)
    },
    getInnerAction: function() {
        return this._innerAction
    }
});
cc.repeatForever = function(a) {
    return new cc.RepeatForever(a)
};
cc.RepeatForever.create = cc.repeatForever;
cc.Spawn = cc.ActionInterval.extend({
    _one: null,
    _two: null,
    ctor: function(a) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._two = this._one = null;
        var b = a instanceof Array ? a : arguments,
            d = b.length - 1;
        0 <= d && null == b[d] && cc.log("parameters should not be ending with null in Javascript");
        if (0 <= d) {
            for (var e = b[0], f = 1; f < d; f++) b[f] && (e = cc.Spawn._actionOneTwo(e, b[f]));
            this.initWithTwoActions(e, b[d])
        }
    },
    initWithTwoActions: function(a, b) {
        if (!a || !b) throw Error("cc.Spawn.initWithTwoActions(): arguments must all be non null");
        var d = !1,
            e = a._duration,
            f = b._duration;
        this.initWithDuration(Math.max(e, f)) && (this._one = a, this._two = b, e > f ? this._two = cc.Sequence._actionOneTwo(b, cc.delayTime(e - f)) : e < f && (this._one = cc.Sequence._actionOneTwo(a, cc.delayTime(f - e))), d = !0);
        return d
    },
    clone: function() {
        var a = new cc.Spawn;
        this._cloneDecoration(a);
        a.initWithTwoActions(this._one.clone(), this._two.clone());
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._one.startWithTarget(a);
        this._two.startWithTarget(a)
    },
    stop: function() {
        this._one.stop();
        this._two.stop();
        cc.Action.prototype.stop.call(this)
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        this._one && this._one.update(a);
        this._two && this._two.update(a)
    },
    reverse: function() {
        var a = cc.Spawn._actionOneTwo(this._one.reverse(), this._two.reverse());
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.spawn = function(a) {
    var b = a instanceof Array ? a : arguments;
    0 < b.length && null == b[b.length - 1] && cc.log("parameters should not be ending with null in Javascript");
    for (var d = b[0], e = 1; e < b.length; e++) null != b[e] && (d = cc.Spawn._actionOneTwo(d, b[e]));
    return d
};
cc.Spawn.create = cc.spawn;
cc.Spawn._actionOneTwo = function(a, b) {
    var d = new cc.Spawn;
    d.initWithTwoActions(a, b);
    return d
};
cc.RotateTo = cc.ActionInterval.extend({
    _dstAngleX: 0,
    _startAngleX: 0,
    _diffAngleX: 0,
    _dstAngleY: 0,
    _startAngleY: 0,
    _diffAngleY: 0,
    ctor: function(a, b, d) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== b && this.initWithDuration(a, b, d)
    },
    initWithDuration: function(a, b, d) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._dstAngleX = b || 0, this._dstAngleY = d || this._dstAngleX, !0) : !1
    },
    clone: function() {
        var a = new cc.RotateTo;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._dstAngleX,
            this._dstAngleY);
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        var b = a.rotationX % 360,
            d = this._dstAngleX - b;
        180 < d && (d -= 360); - 180 > d && (d += 360);
        this._startAngleX = b;
        this._diffAngleX = d;
        this._startAngleY = a.rotationY % 360;
        a = this._dstAngleY - this._startAngleY;
        180 < a && (a -= 360); - 180 > a && (a += 360);
        this._diffAngleY = a
    },
    reverse: function() {
        cc.log("cc.RotateTo.reverse(): it should be overridden in subclass.")
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        this.target && (this.target.rotationX =
            this._startAngleX + this._diffAngleX * a, this.target.rotationY = this._startAngleY + this._diffAngleY * a)
    }
});
cc.rotateTo = function(a, b, d) {
    return new cc.RotateTo(a, b, d)
};
cc.RotateTo.create = cc.rotateTo;
cc.RotateBy = cc.ActionInterval.extend({
    _angleX: 0,
    _startAngleX: 0,
    _angleY: 0,
    _startAngleY: 0,
    ctor: function(a, b, d) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== b && this.initWithDuration(a, b, d)
    },
    initWithDuration: function(a, b, d) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._angleX = b || 0, this._angleY = d || this._angleX, !0) : !1
    },
    clone: function() {
        var a = new cc.RotateBy;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._angleX, this._angleY);
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this,
            a);
        this._startAngleX = a.rotationX;
        this._startAngleY = a.rotationY
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        this.target && (this.target.rotationX = this._startAngleX + this._angleX * a, this.target.rotationY = this._startAngleY + this._angleY * a)
    },
    reverse: function() {
        var a = new cc.RotateBy(this._duration, -this._angleX, -this._angleY);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.rotateBy = function(a, b, d) {
    return new cc.RotateBy(a, b, d)
};
cc.RotateBy.create = cc.rotateBy;
cc.MoveBy = cc.ActionInterval.extend({
    _positionDelta: null,
    _startPosition: null,
    _previousPosition: null,
    ctor: function(a, b, d) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._positionDelta = cc.p(0, 0);
        this._startPosition = cc.p(0, 0);
        this._previousPosition = cc.p(0, 0);
        void 0 !== b && this.initWithDuration(a, b, d)
    },
    initWithDuration: function(a, b, d) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (void 0 !== b.x && (d = b.y, b = b.x), this._positionDelta.x = b, this._positionDelta.y = d, !0) : !1
    },
    clone: function() {
        var a =
            new cc.MoveBy;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._positionDelta);
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        var b = a.getPositionX();
        a = a.getPositionY();
        this._previousPosition.x = b;
        this._previousPosition.y = a;
        this._startPosition.x = b;
        this._startPosition.y = a
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        if (this.target) {
            var b = this._positionDelta.x * a;
            a *= this._positionDelta.y;
            var d = this._startPosition;
            if (cc.ENABLE_STACKABLE_ACTIONS) {
                var e =
                    this.target.getPositionX(),
                    f = this.target.getPositionY(),
                    g = this._previousPosition;
                d.x = d.x + e - g.x;
                d.y = d.y + f - g.y;
                b += d.x;
                a += d.y;
                g.x = b;
                g.y = a;
                this.target.setPosition(b, a)
            } else this.target.setPosition(d.x + b, d.y + a)
        }
    },
    reverse: function() {
        var a = new cc.MoveBy(this._duration, cc.p(-this._positionDelta.x, -this._positionDelta.y));
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.moveBy = function(a, b, d) {
    return new cc.MoveBy(a, b, d)
};
cc.MoveBy.create = cc.moveBy;
cc.MoveTo = cc.MoveBy.extend({
    _endPosition: null,
    ctor: function(a, b, d) {
        cc.MoveBy.prototype.ctor.call(this);
        this._endPosition = cc.p(0, 0);
        void 0 !== b && this.initWithDuration(a, b, d)
    },
    initWithDuration: function(a, b, d) {
        return cc.MoveBy.prototype.initWithDuration.call(this, a, b, d) ? (void 0 !== b.x && (d = b.y, b = b.x), this._endPosition.x = b, this._endPosition.y = d, !0) : !1
    },
    clone: function() {
        var a = new cc.MoveTo;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._endPosition);
        return a
    },
    startWithTarget: function(a) {
        cc.MoveBy.prototype.startWithTarget.call(this,
            a);
        this._positionDelta.x = this._endPosition.x - a.getPositionX();
        this._positionDelta.y = this._endPosition.y - a.getPositionY()
    }
});
cc.moveTo = function(a, b, d) {
    return new cc.MoveTo(a, b, d)
};
cc.MoveTo.create = cc.moveTo;
cc.SkewTo = cc.ActionInterval.extend({
    _skewX: 0,
    _skewY: 0,
    _startSkewX: 0,
    _startSkewY: 0,
    _endSkewX: 0,
    _endSkewY: 0,
    _deltaX: 0,
    _deltaY: 0,
    ctor: function(a, b, d) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== d && this.initWithDuration(a, b, d)
    },
    initWithDuration: function(a, b, d) {
        var e = !1;
        cc.ActionInterval.prototype.initWithDuration.call(this, a) && (this._endSkewX = b, this._endSkewY = d, e = !0);
        return e
    },
    clone: function() {
        var a = new cc.SkewTo;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._endSkewX, this._endSkewY);
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._startSkewX = a.skewX % 180;
        this._deltaX = this._endSkewX - this._startSkewX;
        180 < this._deltaX && (this._deltaX -= 360); - 180 > this._deltaX && (this._deltaX += 360);
        this._startSkewY = a.skewY % 360;
        this._deltaY = this._endSkewY - this._startSkewY;
        180 < this._deltaY && (this._deltaY -= 360); - 180 > this._deltaY && (this._deltaY += 360)
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        this.target.skewX = this._startSkewX + this._deltaX * a;
        this.target.skewY =
            this._startSkewY + this._deltaY * a
    }
});
cc.skewTo = function(a, b, d) {
    return new cc.SkewTo(a, b, d)
};
cc.SkewTo.create = cc.skewTo;
cc.SkewBy = cc.SkewTo.extend({
    ctor: function(a, b, d) {
        cc.SkewTo.prototype.ctor.call(this);
        void 0 !== d && this.initWithDuration(a, b, d)
    },
    initWithDuration: function(a, b, d) {
        var e = !1;
        cc.SkewTo.prototype.initWithDuration.call(this, a, b, d) && (this._skewX = b, this._skewY = d, e = !0);
        return e
    },
    clone: function() {
        var a = new cc.SkewBy;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._skewX, this._skewY);
        return a
    },
    startWithTarget: function(a) {
        cc.SkewTo.prototype.startWithTarget.call(this, a);
        this._deltaX = this._skewX;
        this._deltaY = this._skewY;
        this._endSkewX = this._startSkewX + this._deltaX;
        this._endSkewY = this._startSkewY + this._deltaY
    },
    reverse: function() {
        var a = new cc.SkewBy(this._duration, -this._skewX, -this._skewY);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.skewBy = function(a, b, d) {
    return new cc.SkewBy(a, b, d)
};
cc.SkewBy.create = cc.skewBy;
cc.JumpBy = cc.ActionInterval.extend({
    _startPosition: null,
    _delta: null,
    _height: 0,
    _jumps: 0,
    _previousPosition: null,
    ctor: function(a, b, d, e, f) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._startPosition = cc.p(0, 0);
        this._previousPosition = cc.p(0, 0);
        this._delta = cc.p(0, 0);
        void 0 !== e && this.initWithDuration(a, b, d, e, f)
    },
    initWithDuration: function(a, b, d, e, f) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (void 0 === f && (f = e, e = d, d = b.y, b = b.x), this._delta.x = b, this._delta.y = d, this._height = e, this._jumps =
            f, !0) : !1
    },
    clone: function() {
        var a = new cc.JumpBy;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._delta, this._height, this._jumps);
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        var b = a.getPositionX();
        a = a.getPositionY();
        this._previousPosition.x = b;
        this._previousPosition.y = a;
        this._startPosition.x = b;
        this._startPosition.y = a
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        if (this.target) {
            var b = a * this._jumps % 1,
                b = 4 * this._height * b * (1 - b),
                b = b + this._delta.y *
                a;
            a *= this._delta.x;
            var d = this._startPosition;
            if (cc.ENABLE_STACKABLE_ACTIONS) {
                var e = this.target.getPositionX(),
                    f = this.target.getPositionY(),
                    g = this._previousPosition;
                d.x = d.x + e - g.x;
                d.y = d.y + f - g.y;
                a += d.x;
                b += d.y;
                g.x = a;
                g.y = b;
                this.target.setPosition(a, b)
            } else this.target.setPosition(d.x + a, d.y + b)
        }
    },
    reverse: function() {
        var a = new cc.JumpBy(this._duration, cc.p(-this._delta.x, -this._delta.y), this._height, this._jumps);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.jumpBy = function(a, b, d, e, f) {
    return new cc.JumpBy(a, b, d, e, f)
};
cc.JumpBy.create = cc.jumpBy;
cc.JumpTo = cc.JumpBy.extend({
    _endPosition: null,
    ctor: function(a, b, d, e, f) {
        cc.JumpBy.prototype.ctor.call(this);
        this._endPosition = cc.p(0, 0);
        void 0 !== e && this.initWithDuration(a, b, d, e, f)
    },
    initWithDuration: function(a, b, d, e, f) {
        return cc.JumpBy.prototype.initWithDuration.call(this, a, b, d, e, f) ? (void 0 === f && (d = b.y, b = b.x), this._endPosition.x = b, this._endPosition.y = d, !0) : !1
    },
    startWithTarget: function(a) {
        cc.JumpBy.prototype.startWithTarget.call(this, a);
        this._delta.x = this._endPosition.x - this._startPosition.x;
        this._delta.y =
            this._endPosition.y - this._startPosition.y
    },
    clone: function() {
        var a = new cc.JumpTo;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._endPosition, this._height, this._jumps);
        return a
    }
});
cc.jumpTo = function(a, b, d, e, f) {
    return new cc.JumpTo(a, b, d, e, f)
};
cc.JumpTo.create = cc.jumpTo;
cc.bezierAt = function(a, b, d, e, f) {
    return Math.pow(1 - f, 3) * a + 3 * f * Math.pow(1 - f, 2) * b + 3 * Math.pow(f, 2) * (1 - f) * d + Math.pow(f, 3) * e
};
cc.BezierBy = cc.ActionInterval.extend({
    _config: null,
    _startPosition: null,
    _previousPosition: null,
    ctor: function(a, b) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._config = [];
        this._startPosition = cc.p(0, 0);
        this._previousPosition = cc.p(0, 0);
        b && this.initWithDuration(a, b)
    },
    initWithDuration: function(a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._config = b, !0) : !1
    },
    clone: function() {
        var a = new cc.BezierBy;
        this._cloneDecoration(a);
        for (var b = [], d = 0; d < this._config.length; d++) {
            var e =
                this._config[d];
            b.push(cc.p(e.x, e.y))
        }
        a.initWithDuration(this._duration, b);
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        var b = a.getPositionX();
        a = a.getPositionY();
        this._previousPosition.x = b;
        this._previousPosition.y = a;
        this._startPosition.x = b;
        this._startPosition.y = a
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        if (this.target) {
            var b = this._config,
                d = b[0].y,
                e = b[1].y,
                f = b[2].y,
                b = cc.bezierAt(0, b[0].x, b[1].x, b[2].x, a);
            a = cc.bezierAt(0, d, e, f, a);
            d = this._startPosition;
            if (cc.ENABLE_STACKABLE_ACTIONS) {
                var e = this.target.getPositionX(),
                    f = this.target.getPositionY(),
                    g = this._previousPosition;
                d.x = d.x + e - g.x;
                d.y = d.y + f - g.y;
                b += d.x;
                a += d.y;
                g.x = b;
                g.y = a;
                this.target.setPosition(b, a)
            } else this.target.setPosition(d.x + b, d.y + a)
        }
    },
    reverse: function() {
        var a = this._config,
            a = [cc.pAdd(a[1], cc.pNeg(a[2])), cc.pAdd(a[0], cc.pNeg(a[2])), cc.pNeg(a[2])],
            a = new cc.BezierBy(this._duration, a);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.bezierBy = function(a, b) {
    return new cc.BezierBy(a, b)
};
cc.BezierBy.create = cc.bezierBy;
cc.BezierTo = cc.BezierBy.extend({
    _toConfig: null,
    ctor: function(a, b) {
        cc.BezierBy.prototype.ctor.call(this);
        this._toConfig = [];
        b && this.initWithDuration(a, b)
    },
    initWithDuration: function(a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._toConfig = b, !0) : !1
    },
    clone: function() {
        var a = new cc.BezierTo;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._toConfig);
        return a
    },
    startWithTarget: function(a) {
        cc.BezierBy.prototype.startWithTarget.call(this, a);
        a = this._startPosition;
        var b =
            this._toConfig,
            d = this._config;
        d[0] = cc.pSub(b[0], a);
        d[1] = cc.pSub(b[1], a);
        d[2] = cc.pSub(b[2], a)
    }
});
cc.bezierTo = function(a, b) {
    return new cc.BezierTo(a, b)
};
cc.BezierTo.create = cc.bezierTo;
cc.ScaleTo = cc.ActionInterval.extend({
    _scaleX: 1,
    _scaleY: 1,
    _startScaleX: 1,
    _startScaleY: 1,
    _endScaleX: 0,
    _endScaleY: 0,
    _deltaX: 0,
    _deltaY: 0,
    ctor: function(a, b, d) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== b && this.initWithDuration(a, b, d)
    },
    initWithDuration: function(a, b, d) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._endScaleX = b, this._endScaleY = null != d ? d : b, !0) : !1
    },
    clone: function() {
        var a = new cc.ScaleTo;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._endScaleX,
            this._endScaleY);
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._startScaleX = a.scaleX;
        this._startScaleY = a.scaleY;
        this._deltaX = this._endScaleX - this._startScaleX;
        this._deltaY = this._endScaleY - this._startScaleY
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        this.target && (this.target.scaleX = this._startScaleX + this._deltaX * a, this.target.scaleY = this._startScaleY + this._deltaY * a)
    }
});
cc.scaleTo = function(a, b, d) {
    return new cc.ScaleTo(a, b, d)
};
cc.ScaleTo.create = cc.scaleTo;
cc.ScaleBy = cc.ScaleTo.extend({
    startWithTarget: function(a) {
        cc.ScaleTo.prototype.startWithTarget.call(this, a);
        this._deltaX = this._startScaleX * this._endScaleX - this._startScaleX;
        this._deltaY = this._startScaleY * this._endScaleY - this._startScaleY
    },
    reverse: function() {
        var a = new cc.ScaleBy(this._duration, 1 / this._endScaleX, 1 / this._endScaleY);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    },
    clone: function() {
        var a = new cc.ScaleBy;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._endScaleX,
            this._endScaleY);
        return a
    }
});
cc.scaleBy = function(a, b, d) {
    return new cc.ScaleBy(a, b, d)
};
cc.ScaleBy.create = cc.scaleBy;
cc.Blink = cc.ActionInterval.extend({
    _times: 0,
    _originalState: !1,
    ctor: function(a, b) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== b && this.initWithDuration(a, b)
    },
    initWithDuration: function(a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._times = b, !0) : !1
    },
    clone: function() {
        var a = new cc.Blink;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._times);
        return a
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        if (this.target && !this.isDone()) {
            var b = 1 / this._times;
            this.target.visible =
                a % b > b / 2
        }
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._originalState = a.visible
    },
    stop: function() {
        this.target.visible = this._originalState;
        cc.ActionInterval.prototype.stop.call(this)
    },
    reverse: function() {
        var a = new cc.Blink(this._duration, this._times);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.blink = function(a, b) {
    return new cc.Blink(a, b)
};
cc.Blink.create = cc.blink;
cc.FadeTo = cc.ActionInterval.extend({
    _toOpacity: 0,
    _fromOpacity: 0,
    ctor: function(a, b) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== b && this.initWithDuration(a, b)
    },
    initWithDuration: function(a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._toOpacity = b, !0) : !1
    },
    clone: function() {
        var a = new cc.FadeTo;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._toOpacity);
        return a
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        var b = void 0 !== this._fromOpacity ? this._fromOpacity :
            255;
        this.target.opacity = b + (this._toOpacity - b) * a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._fromOpacity = a.opacity
    }
});
cc.fadeTo = function(a, b) {
    return new cc.FadeTo(a, b)
};
cc.FadeTo.create = cc.fadeTo;
cc.FadeIn = cc.FadeTo.extend({
    _reverseAction: null,
    ctor: function(a) {
        cc.FadeTo.prototype.ctor.call(this);
        null == a && (a = 0);
        this.initWithDuration(a, 255)
    },
    reverse: function() {
        var a = new cc.FadeOut;
        a.initWithDuration(this._duration, 0);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    },
    clone: function() {
        var a = new cc.FadeIn;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._toOpacity);
        return a
    },
    startWithTarget: function(a) {
        this._reverseAction && (this._toOpacity = this._reverseAction._fromOpacity);
        cc.FadeTo.prototype.startWithTarget.call(this, a)
    }
});
cc.fadeIn = function(a) {
    return new cc.FadeIn(a)
};
cc.FadeIn.create = cc.fadeIn;
cc.FadeOut = cc.FadeTo.extend({
    ctor: function(a) {
        cc.FadeTo.prototype.ctor.call(this);
        null == a && (a = 0);
        this.initWithDuration(a, 0)
    },
    reverse: function() {
        var a = new cc.FadeIn;
        a._reverseAction = this;
        a.initWithDuration(this._duration, 255);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    },
    clone: function() {
        var a = new cc.FadeOut;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._toOpacity);
        return a
    }
});
cc.fadeOut = function(a) {
    return new cc.FadeOut(a)
};
cc.FadeOut.create = cc.fadeOut;
cc.TintTo = cc.ActionInterval.extend({
    _to: null,
    _from: null,
    ctor: function(a, b, d, e) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._to = cc.color(0, 0, 0);
        this._from = cc.color(0, 0, 0);
        void 0 !== e && this.initWithDuration(a, b, d, e)
    },
    initWithDuration: function(a, b, d, e) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._to = cc.color(b, d, e), !0) : !1
    },
    clone: function() {
        var a = new cc.TintTo;
        this._cloneDecoration(a);
        var b = this._to;
        a.initWithDuration(this._duration, b.r, b.g, b.b);
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this,
            a);
        this._from = this.target.color
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        var b = this._from,
            d = this._to;
        b && this.target.setColor(cc.color(b.r + (d.r - b.r) * a, b.g + (d.g - b.g) * a, b.b + (d.b - b.b) * a))
    }
});
cc.tintTo = function(a, b, d, e) {
    return new cc.TintTo(a, b, d, e)
};
cc.TintTo.create = cc.tintTo;
cc.TintBy = cc.ActionInterval.extend({
    _deltaR: 0,
    _deltaG: 0,
    _deltaB: 0,
    _fromR: 0,
    _fromG: 0,
    _fromB: 0,
    ctor: function(a, b, d, e) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== e && this.initWithDuration(a, b, d, e)
    },
    initWithDuration: function(a, b, d, e) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._deltaR = b, this._deltaG = d, this._deltaB = e, !0) : !1
    },
    clone: function() {
        var a = new cc.TintBy;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._deltaR, this._deltaG, this._deltaB);
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        a = a.color;
        this._fromR = a.r;
        this._fromG = a.g;
        this._fromB = a.b
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        this.target.color = cc.color(this._fromR + this._deltaR * a, this._fromG + this._deltaG * a, this._fromB + this._deltaB * a)
    },
    reverse: function() {
        var a = new cc.TintBy(this._duration, -this._deltaR, -this._deltaG, -this._deltaB);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.tintBy = function(a, b, d, e) {
    return new cc.TintBy(a, b, d, e)
};
cc.TintBy.create = cc.tintBy;
cc.DelayTime = cc.ActionInterval.extend({
    update: function(a) {},
    reverse: function() {
        var a = new cc.DelayTime(this._duration);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    },
    clone: function() {
        var a = new cc.DelayTime;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration);
        return a
    }
});
cc.delayTime = function(a) {
    return new cc.DelayTime(a)
};
cc.DelayTime.create = cc.delayTime;
cc.ReverseTime = cc.ActionInterval.extend({
    _other: null,
    ctor: function(a) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._other = null;
        a && this.initWithAction(a)
    },
    initWithAction: function(a) {
        if (!a) throw Error("cc.ReverseTime.initWithAction(): action must be non null");
        if (a === this._other) throw Error("cc.ReverseTime.initWithAction(): the action was already passed in.");
        return cc.ActionInterval.prototype.initWithDuration.call(this, a._duration) ? (this._other = a, !0) : !1
    },
    clone: function() {
        var a = new cc.ReverseTime;
        this._cloneDecoration(a);
        a.initWithAction(this._other.clone());
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._other.startWithTarget(a)
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        this._other && this._other.update(1 - a)
    },
    reverse: function() {
        return this._other.clone()
    },
    stop: function() {
        this._other.stop();
        cc.Action.prototype.stop.call(this)
    }
});
cc.reverseTime = function(a) {
    return new cc.ReverseTime(a)
};
cc.ReverseTime.create = cc.reverseTime;
cc.Animate = cc.ActionInterval.extend({
    _animation: null,
    _nextFrame: 0,
    _origFrame: null,
    _executedLoops: 0,
    _splitTimes: null,
    _currFrameIndex: 0,
    ctor: function(a) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._splitTimes = [];
        a && this.initWithAnimation(a)
    },
    getAnimation: function() {
        return this._animation
    },
    setAnimation: function(a) {
        this._animation = a
    },
    getCurrentFrameIndex: function() {
        return this._currFrameIndex
    },
    initWithAnimation: function(a) {
        if (!a) throw Error("cc.Animate.initWithAnimation(): animation must be non-NULL");
        var b = a.getDuration();
        if (this.initWithDuration(b * a.getLoops())) {
            this._nextFrame = 0;
            this.setAnimation(a);
            this._origFrame = null;
            this._executedLoops = 0;
            var d = this._splitTimes,
                e = d.length = 0,
                f = b / a.getTotalDelayUnits();
            a = a.getFrames();
            cc.arrayVerifyType(a, cc.AnimationFrame);
            for (var g = 0; g < a.length; g++) {
                var h = e * f / b,
                    e = e + a[g].getDelayUnits();
                d.push(h)
            }
            return !0
        }
        return !1
    },
    clone: function() {
        var a = new cc.Animate;
        this._cloneDecoration(a);
        a.initWithAnimation(this._animation.clone());
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this,
            a);
        this._animation.getRestoreOriginalFrame() && (this._origFrame = a.displayFrame());
        this._executedLoops = this._nextFrame = 0
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        1 > a && (a *= this._animation.getLoops(), (0 | a) > this._executedLoops && (this._nextFrame = 0, this._executedLoops++), a %= 1);
        for (var b = this._animation.getFrames(), d = b.length, e = this._splitTimes, f = this._nextFrame; f < d; f++)
            if (e[f] <= a) _currFrameIndex = f, this.target.setSpriteFrame(b[_currFrameIndex].getSpriteFrame()), this._nextFrame = f + 1;
            else break
    },
    reverse: function() {
        var a =
            this._animation,
            b = a.getFrames(),
            d = [];
        cc.arrayVerifyType(b, cc.AnimationFrame);
        if (0 < b.length)
            for (var e = b.length - 1; 0 <= e; e--) {
                var f = b[e];
                if (!f) break;
                d.push(f.clone())
            }
        b = new cc.Animation(d, a.getDelayPerUnit(), a.getLoops());
        b.setRestoreOriginalFrame(a.getRestoreOriginalFrame());
        a = new cc.Animate(b);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    },
    stop: function() {
        this._animation.getRestoreOriginalFrame() && this.target && this.target.setSpriteFrame(this._origFrame);
        cc.Action.prototype.stop.call(this)
    }
});
cc.animate = function(a) {
    return new cc.Animate(a)
};
cc.Animate.create = cc.animate;
cc.TargetedAction = cc.ActionInterval.extend({
    _action: null,
    _forcedTarget: null,
    ctor: function(a, b) {
        cc.ActionInterval.prototype.ctor.call(this);
        b && this.initWithTarget(a, b)
    },
    initWithTarget: function(a, b) {
        return this.initWithDuration(b._duration) ? (this._forcedTarget = a, this._action = b, !0) : !1
    },
    clone: function() {
        var a = new cc.TargetedAction;
        this._cloneDecoration(a);
        a.initWithTarget(this._forcedTarget, this._action.clone());
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._action.startWithTarget(this._forcedTarget)
    },
    stop: function() {
        this._action.stop()
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        this._action.update(a)
    },
    getForcedTarget: function() {
        return this._forcedTarget
    },
    setForcedTarget: function(a) {
        this._forcedTarget !== a && (this._forcedTarget = a)
    }
});
cc.targetedAction = function(a, b) {
    return new cc.TargetedAction(a, b)
};
cc.TargetedAction.create = cc.targetedAction;
cc.ActionInstant = cc.FiniteTimeAction.extend({
    isDone: function() {
        return !0
    },
    step: function(a) {
        this.update(1)
    },
    update: function(a) {},
    reverse: function() {
        return this.clone()
    },
    clone: function() {
        return new cc.ActionInstant
    }
});
cc.Show = cc.ActionInstant.extend({
    update: function(a) {
        this.target.visible = !0
    },
    reverse: function() {
        return new cc.Hide
    },
    clone: function() {
        return new cc.Show
    }
});
cc.show = function() {
    return new cc.Show
};
cc.Show.create = cc.show;
cc.Hide = cc.ActionInstant.extend({
    update: function(a) {
        this.target.visible = !1
    },
    reverse: function() {
        return new cc.Show
    },
    clone: function() {
        return new cc.Hide
    }
});
cc.hide = function() {
    return new cc.Hide
};
cc.Hide.create = cc.hide;
cc.ToggleVisibility = cc.ActionInstant.extend({
    update: function(a) {
        this.target.visible = !this.target.visible
    },
    reverse: function() {
        return new cc.ToggleVisibility
    },
    clone: function() {
        return new cc.ToggleVisibility
    }
});
cc.toggleVisibility = function() {
    return new cc.ToggleVisibility
};
cc.ToggleVisibility.create = cc.toggleVisibility;
cc.RemoveSelf = cc.ActionInstant.extend({
    _isNeedCleanUp: !0,
    ctor: function(a) {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        void 0 !== a && this.init(a)
    },
    update: function(a) {
        this.target.removeFromParent(this._isNeedCleanUp)
    },
    init: function(a) {
        this._isNeedCleanUp = a;
        return !0
    },
    reverse: function() {
        return new cc.RemoveSelf(this._isNeedCleanUp)
    },
    clone: function() {
        return new cc.RemoveSelf(this._isNeedCleanUp)
    }
});
cc.removeSelf = function(a) {
    return new cc.RemoveSelf(a)
};
cc.RemoveSelf.create = cc.removeSelf;
cc.FlipX = cc.ActionInstant.extend({
    _flippedX: !1,
    ctor: function(a) {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        this._flippedX = !1;
        void 0 !== a && this.initWithFlipX(a)
    },
    initWithFlipX: function(a) {
        this._flippedX = a;
        return !0
    },
    update: function(a) {
        this.target.flippedX = this._flippedX
    },
    reverse: function() {
        return new cc.FlipX(!this._flippedX)
    },
    clone: function() {
        var a = new cc.FlipX;
        a.initWithFlipX(this._flippedX);
        return a
    }
});
cc.flipX = function(a) {
    return new cc.FlipX(a)
};
cc.FlipX.create = cc.flipX;
cc.FlipY = cc.ActionInstant.extend({
    _flippedY: !1,
    ctor: function(a) {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        this._flippedY = !1;
        void 0 !== a && this.initWithFlipY(a)
    },
    initWithFlipY: function(a) {
        this._flippedY = a;
        return !0
    },
    update: function(a) {
        this.target.flippedY = this._flippedY
    },
    reverse: function() {
        return new cc.FlipY(!this._flippedY)
    },
    clone: function() {
        var a = new cc.FlipY;
        a.initWithFlipY(this._flippedY);
        return a
    }
});
cc.flipY = function(a) {
    return new cc.FlipY(a)
};
cc.FlipY.create = cc.flipY;
cc.Place = cc.ActionInstant.extend({
    _x: 0,
    _y: 0,
    ctor: function(a, b) {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        this._y = this._x = 0;
        void 0 !== a && (void 0 !== a.x && (b = a.y, a = a.x), this.initWithPosition(a, b))
    },
    initWithPosition: function(a, b) {
        this._x = a;
        this._y = b;
        return !0
    },
    update: function(a) {
        this.target.setPosition(this._x, this._y)
    },
    clone: function() {
        var a = new cc.Place;
        a.initWithPosition(this._x, this._y);
        return a
    }
});
cc.place = function(a, b) {
    return new cc.Place(a, b)
};
cc.Place.create = cc.place;
cc.CallFunc = cc.ActionInstant.extend({
    _selectorTarget: null,
    _callFunc: null,
    _function: null,
    _data: null,
    ctor: function(a, b, d) {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        void 0 !== a && (void 0 === b ? this.initWithFunction(a) : this.initWithFunction(a, b, d))
    },
    initWithFunction: function(a, b, d) {
        b ? (this._data = d, this._callFunc = a, this._selectorTarget = b) : a && (this._function = a);
        return !0
    },
    execute: function() {
        null != this._callFunc ? this._callFunc.call(this._selectorTarget, this.target, this._data) : this._function && this._function.call(null,
            this.target)
    },
    update: function(a) {
        this.execute()
    },
    getTargetCallback: function() {
        return this._selectorTarget
    },
    setTargetCallback: function(a) {
        a !== this._selectorTarget && (this._selectorTarget && (this._selectorTarget = null), this._selectorTarget = a)
    },
    clone: function() {
        var a = new cc.CallFunc;
        this._selectorTarget ? a.initWithFunction(this._callFunc, this._selectorTarget, this._data) : this._function && a.initWithFunction(this._function);
        return a
    }
});
cc.callFunc = function(a, b, d) {
    return new cc.CallFunc(a, b, d)
};
cc.CallFunc.create = cc.callFunc;
cc.ActionCamera = cc.ActionInterval.extend({
    _centerXOrig: 0,
    _centerYOrig: 0,
    _centerZOrig: 0,
    _eyeXOrig: 0,
    _eyeYOrig: 0,
    _eyeZOrig: 0,
    _upXOrig: 0,
    _upYOrig: 0,
    _upZOrig: 0,
    ctor: function() {
        cc.ActionInterval.prototype.ctor.call(this);
        this._upZOrig = this._upYOrig = this._upXOrig = this._eyeZOrig = this._eyeYOrig = this._eyeXOrig = this._centerZOrig = this._centerYOrig = this._centerXOrig = 0
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        a = a.getCamera();
        var b = a.getCenter();
        this._centerXOrig = b.x;
        this._centerYOrig = b.y;
        this._centerZOrig = b.z;
        b = a.getEye();
        this._eyeXOrig = b.x;
        this._eyeYOrig = b.y;
        this._eyeZOrig = b.z;
        a = a.getUp();
        this._upXOrig = a.x;
        this._upYOrig = a.y;
        this._upZOrig = a.z
    },
    clone: function() {
        return new cc.ActionCamera
    },
    reverse: function() {
        return new cc.ReverseTime(this)
    }
});
cc.OrbitCamera = cc.ActionCamera.extend({
    _radius: 0,
    _deltaRadius: 0,
    _angleZ: 0,
    _deltaAngleZ: 0,
    _angleX: 0,
    _deltaAngleX: 0,
    _radZ: 0,
    _radDeltaZ: 0,
    _radX: 0,
    _radDeltaX: 0,
    ctor: function(a, b, d, e, f, g, h) {
        cc.ActionCamera.prototype.ctor.call(this);
        void 0 !== h && this.initWithDuration(a, b, d, e, f, g, h)
    },
    initWithDuration: function(a, b, d, e, f, g, h) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._radius = b, this._deltaRadius = d, this._angleZ = e, this._deltaAngleZ = f, this._angleX = g, this._deltaAngleX = h, this._radDeltaZ =
            cc.degreesToRadians(f), this._radDeltaX = cc.degreesToRadians(h), !0) : !1
    },
    sphericalRadius: function() {
        var a, b;
        b = this.target.getCamera();
        var d = b.getEye();
        a = b.getCenter();
        b = d.x - a.x;
        var e = d.y - a.y;
        a = d.z - a.z;
        var d = Math.sqrt(Math.pow(b, 2) + Math.pow(e, 2) + Math.pow(a, 2)),
            f = Math.sqrt(Math.pow(b, 2) + Math.pow(e, 2));
        0 === f && (f = cc.FLT_EPSILON);
        0 === d && (d = cc.FLT_EPSILON);
        a = Math.acos(a / d);
        b = 0 > b ? Math.PI - Math.asin(e / f) : Math.asin(e / f);
        return {
            newRadius: d / cc.Camera.getZEye(),
            zenith: a,
            azimuth: b
        }
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this,
            a);
        a = this.sphericalRadius();
        isNaN(this._radius) && (this._radius = a.newRadius);
        isNaN(this._angleZ) && (this._angleZ = cc.radiansToDegrees(a.zenith));
        isNaN(this._angleX) && (this._angleX = cc.radiansToDegrees(a.azimuth));
        this._radZ = cc.degreesToRadians(this._angleZ);
        this._radX = cc.degreesToRadians(this._angleX)
    },
    clone: function() {
        var a = new cc.OrbitCamera;
        a.initWithDuration(this._duration, this._radius, this._deltaRadius, this._angleZ, this._deltaAngleZ, this._angleX, this._deltaAngleX);
        return a
    },
    update: function(a) {
        a =
            this._computeEaseTime(a);
        var b = (this._radius + this._deltaRadius * a) * cc.Camera.getZEye(),
            d = this._radZ + this._radDeltaZ * a,
            e = this._radX + this._radDeltaX * a;
        a = Math.sin(d) * Math.cos(e) * b + this._centerXOrig;
        e = Math.sin(d) * Math.sin(e) * b + this._centerYOrig;
        b = Math.cos(d) * b + this._centerZOrig;
        this.target.getCamera().setEye(a, e, b);
        this.target.setNodeDirty()
    }
});
cc.orbitCamera = function(a, b, d, e, f, g, h) {
    return new cc.OrbitCamera(a, b, d, e, f, g, h)
};
cc.OrbitCamera.create = cc.orbitCamera;
cc.ActionEase = cc.ActionInterval.extend({
    _inner: null,
    ctor: function(a) {
        cc.ActionInterval.prototype.ctor.call(this);
        a && this.initWithAction(a)
    },
    initWithAction: function(a) {
        if (!a) throw Error("cc.ActionEase.initWithAction(): action must be non nil");
        return this.initWithDuration(a.getDuration()) ? (this._inner = a, !0) : !1
    },
    clone: function() {
        var a = new cc.ActionEase;
        a.initWithAction(this._inner.clone());
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._inner.startWithTarget(this.target)
    },
    stop: function() {
        this._inner.stop();
        cc.ActionInterval.prototype.stop.call(this)
    },
    update: function(a) {
        this._inner.update(a)
    },
    reverse: function() {
        return new cc.ActionEase(this._inner.reverse())
    },
    getInnerAction: function() {
        return this._inner
    }
});
cc.actionEase = function(a) {
    return new cc.ActionEase(a)
};
cc.ActionEase.create = cc.actionEase;
cc.EaseRateAction = cc.ActionEase.extend({
    _rate: 0,
    ctor: function(a, b) {
        cc.ActionEase.prototype.ctor.call(this);
        void 0 !== b && this.initWithAction(a, b)
    },
    setRate: function(a) {
        this._rate = a
    },
    getRate: function() {
        return this._rate
    },
    initWithAction: function(a, b) {
        return cc.ActionEase.prototype.initWithAction.call(this, a) ? (this._rate = b, !0) : !1
    },
    clone: function() {
        var a = new cc.EaseRateAction;
        a.initWithAction(this._inner.clone(), this._rate);
        return a
    },
    reverse: function() {
        return new cc.EaseRateAction(this._inner.reverse(),
            1 / this._rate)
    }
});
cc.easeRateAction = function(a, b) {
    return new cc.EaseRateAction(a, b)
};
cc.EaseRateAction.create = cc.easeRateAction;
cc.EaseIn = cc.EaseRateAction.extend({
    update: function(a) {
        this._inner.update(Math.pow(a, this._rate))
    },
    reverse: function() {
        return new cc.EaseIn(this._inner.reverse(), 1 / this._rate)
    },
    clone: function() {
        var a = new cc.EaseIn;
        a.initWithAction(this._inner.clone(), this._rate);
        return a
    }
});
cc.EaseIn.create = function(a, b) {
    return new cc.EaseIn(a, b)
};
cc.easeIn = function(a) {
    return {
        _rate: a,
        easing: function(a) {
            return Math.pow(a, this._rate)
        },
        reverse: function() {
            return cc.easeIn(1 / this._rate)
        }
    }
};
cc.EaseOut = cc.EaseRateAction.extend({
    update: function(a) {
        this._inner.update(Math.pow(a, 1 / this._rate))
    },
    reverse: function() {
        return new cc.EaseOut(this._inner.reverse(), 1 / this._rate)
    },
    clone: function() {
        var a = new cc.EaseOut;
        a.initWithAction(this._inner.clone(), this._rate);
        return a
    }
});
cc.EaseOut.create = function(a, b) {
    return new cc.EaseOut(a, b)
};
cc.easeOut = function(a) {
    return {
        _rate: a,
        easing: function(a) {
            return Math.pow(a, 1 / this._rate)
        },
        reverse: function() {
            return cc.easeOut(1 / this._rate)
        }
    }
};
cc.EaseInOut = cc.EaseRateAction.extend({
    update: function(a) {
        a *= 2;
        1 > a ? this._inner.update(0.5 * Math.pow(a, this._rate)) : this._inner.update(1 - 0.5 * Math.pow(2 - a, this._rate))
    },
    clone: function() {
        var a = new cc.EaseInOut;
        a.initWithAction(this._inner.clone(), this._rate);
        return a
    },
    reverse: function() {
        return new cc.EaseInOut(this._inner.reverse(), this._rate)
    }
});
cc.EaseInOut.create = function(a, b) {
    return new cc.EaseInOut(a, b)
};
cc.easeInOut = function(a) {
    return {
        _rate: a,
        easing: function(a) {
            a *= 2;
            return 1 > a ? 0.5 * Math.pow(a, this._rate) : 1 - 0.5 * Math.pow(2 - a, this._rate)
        },
        reverse: function() {
            return cc.easeInOut(this._rate)
        }
    }
};
cc.EaseExponentialIn = cc.ActionEase.extend({
    update: function(a) {
        this._inner.update(0 === a ? 0 : Math.pow(2, 10 * (a - 1)))
    },
    reverse: function() {
        return new cc.EaseExponentialOut(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseExponentialIn;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseExponentialIn.create = function(a) {
    return new cc.EaseExponentialIn(a)
};
cc._easeExponentialInObj = {
    easing: function(a) {
        return 0 === a ? 0 : Math.pow(2, 10 * (a - 1))
    },
    reverse: function() {
        return cc._easeExponentialOutObj
    }
};
cc.easeExponentialIn = function() {
    return cc._easeExponentialInObj
};
cc.EaseExponentialOut = cc.ActionEase.extend({
    update: function(a) {
        this._inner.update(1 === a ? 1 : -Math.pow(2, -10 * a) + 1)
    },
    reverse: function() {
        return new cc.EaseExponentialIn(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseExponentialOut;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseExponentialOut.create = function(a) {
    return new cc.EaseExponentialOut(a)
};
cc._easeExponentialOutObj = {
    easing: function(a) {
        return 1 === a ? 1 : -Math.pow(2, -10 * a) + 1
    },
    reverse: function() {
        return cc._easeExponentialInObj
    }
};
cc.easeExponentialOut = function() {
    return cc._easeExponentialOutObj
};
cc.EaseExponentialInOut = cc.ActionEase.extend({
    update: function(a) {
        1 !== a && 0 !== a && (a *= 2, a = 1 > a ? 0.5 * Math.pow(2, 10 * (a - 1)) : 0.5 * (-Math.pow(2, -10 * (a - 1)) + 2));
        this._inner.update(a)
    },
    reverse: function() {
        return new cc.EaseExponentialInOut(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseExponentialInOut;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseExponentialInOut.create = function(a) {
    return new cc.EaseExponentialInOut(a)
};
cc._easeExponentialInOutObj = {
    easing: function(a) {
        return 1 !== a && 0 !== a ? (a *= 2, 1 > a ? 0.5 * Math.pow(2, 10 * (a - 1)) : 0.5 * (-Math.pow(2, -10 * (a - 1)) + 2)) : a
    },
    reverse: function() {
        return cc._easeExponentialInOutObj
    }
};
cc.easeExponentialInOut = function() {
    return cc._easeExponentialInOutObj
};
cc.EaseSineIn = cc.ActionEase.extend({
    update: function(a) {
        a = 0 === a || 1 === a ? a : -1 * Math.cos(a * Math.PI / 2) + 1;
        this._inner.update(a)
    },
    reverse: function() {
        return new cc.EaseSineOut(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseSineIn;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseSineIn.create = function(a) {
    return new cc.EaseSineIn(a)
};
cc._easeSineInObj = {
    easing: function(a) {
        return 0 === a || 1 === a ? a : -1 * Math.cos(a * Math.PI / 2) + 1
    },
    reverse: function() {
        return cc._easeSineOutObj
    }
};
cc.easeSineIn = function() {
    return cc._easeSineInObj
};
cc.EaseSineOut = cc.ActionEase.extend({
    update: function(a) {
        a = 0 === a || 1 === a ? a : Math.sin(a * Math.PI / 2);
        this._inner.update(a)
    },
    reverse: function() {
        return new cc.EaseSineIn(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseSineOut;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseSineOut.create = function(a) {
    return new cc.EaseSineOut(a)
};
cc._easeSineOutObj = {
    easing: function(a) {
        return 0 === a || 1 === a ? a : Math.sin(a * Math.PI / 2)
    },
    reverse: function() {
        return cc._easeSineInObj
    }
};
cc.easeSineOut = function() {
    return cc._easeSineOutObj
};
cc.EaseSineInOut = cc.ActionEase.extend({
    update: function(a) {
        a = 0 === a || 1 === a ? a : -0.5 * (Math.cos(Math.PI * a) - 1);
        this._inner.update(a)
    },
    clone: function() {
        var a = new cc.EaseSineInOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseSineInOut(this._inner.reverse())
    }
});
cc.EaseSineInOut.create = function(a) {
    return new cc.EaseSineInOut(a)
};
cc._easeSineInOutObj = {
    easing: function(a) {
        return 0 === a || 1 === a ? a : -0.5 * (Math.cos(Math.PI * a) - 1)
    },
    reverse: function() {
        return cc._easeSineInOutObj
    }
};
cc.easeSineInOut = function() {
    return cc._easeSineInOutObj
};
cc.EaseElastic = cc.ActionEase.extend({
    _period: 0.3,
    ctor: function(a, b) {
        cc.ActionEase.prototype.ctor.call(this);
        a && this.initWithAction(a, b)
    },
    getPeriod: function() {
        return this._period
    },
    setPeriod: function(a) {
        this._period = a
    },
    initWithAction: function(a, b) {
        cc.ActionEase.prototype.initWithAction.call(this, a);
        this._period = null == b ? 0.3 : b;
        return !0
    },
    reverse: function() {
        cc.log("cc.EaseElastic.reverse(): it should be overridden in subclass.");
        return null
    },
    clone: function() {
        var a = new cc.EaseElastic;
        a.initWithAction(this._inner.clone(),
            this._period);
        return a
    }
});
cc.EaseElastic.create = function(a, b) {
    return new cc.EaseElastic(a, b)
};
cc.EaseElasticIn = cc.EaseElastic.extend({
    update: function(a) {
        var b = 0;
        0 === a || 1 === a ? b = a : (b = this._period / 4, a -= 1, b = -Math.pow(2, 10 * a) * Math.sin(2 * (a - b) * Math.PI / this._period));
        this._inner.update(b)
    },
    reverse: function() {
        return new cc.EaseElasticOut(this._inner.reverse(), this._period)
    },
    clone: function() {
        var a = new cc.EaseElasticIn;
        a.initWithAction(this._inner.clone(), this._period);
        return a
    }
});
cc.EaseElasticIn.create = function(a, b) {
    return new cc.EaseElasticIn(a, b)
};
cc._easeElasticInObj = {
    easing: function(a) {
        if (0 === a || 1 === a) return a;
        a -= 1;
        return -Math.pow(2, 10 * a) * Math.sin(2 * (a - 0.075) * Math.PI / 0.3)
    },
    reverse: function() {
        return cc._easeElasticOutObj
    }
};
cc.easeElasticIn = function(a) {
    return a && 0.3 !== a ? {
        _period: a,
        easing: function(a) {
            if (0 === a || 1 === a) return a;
            a -= 1;
            return -Math.pow(2, 10 * a) * Math.sin(2 * (a - this._period / 4) * Math.PI / this._period)
        },
        reverse: function() {
            return cc.easeElasticOut(this._period)
        }
    } : cc._easeElasticInObj
};
cc.EaseElasticOut = cc.EaseElastic.extend({
    update: function(a) {
        var b = 0;
        0 === a || 1 === a ? b = a : (b = this._period / 4, b = Math.pow(2, -10 * a) * Math.sin(2 * (a - b) * Math.PI / this._period) + 1);
        this._inner.update(b)
    },
    reverse: function() {
        return new cc.EaseElasticIn(this._inner.reverse(), this._period)
    },
    clone: function() {
        var a = new cc.EaseElasticOut;
        a.initWithAction(this._inner.clone(), this._period);
        return a
    }
});
cc.EaseElasticOut.create = function(a, b) {
    return new cc.EaseElasticOut(a, b)
};
cc._easeElasticOutObj = {
    easing: function(a) {
        return 0 === a || 1 === a ? a : Math.pow(2, -10 * a) * Math.sin(2 * (a - 0.075) * Math.PI / 0.3) + 1
    },
    reverse: function() {
        return cc._easeElasticInObj
    }
};
cc.easeElasticOut = function(a) {
    return a && 0.3 !== a ? {
        _period: a,
        easing: function(a) {
            return 0 === a || 1 === a ? a : Math.pow(2, -10 * a) * Math.sin(2 * (a - this._period / 4) * Math.PI / this._period) + 1
        },
        reverse: function() {
            return cc.easeElasticIn(this._period)
        }
    } : cc._easeElasticOutObj
};
cc.EaseElasticInOut = cc.EaseElastic.extend({
    update: function(a) {
        var b = 0,
            b = this._period;
        if (0 === a || 1 === a) b = a;
        else {
            b || (b = this._period = 0.3 * 1.5);
            var d = b / 4;
            a = 2 * a - 1;
            b = 0 > a ? -0.5 * Math.pow(2, 10 * a) * Math.sin(2 * (a - d) * Math.PI / b) : 0.5 * Math.pow(2, -10 * a) * Math.sin(2 * (a - d) * Math.PI / b) + 1
        }
        this._inner.update(b)
    },
    reverse: function() {
        return new cc.EaseElasticInOut(this._inner.reverse(), this._period)
    },
    clone: function() {
        var a = new cc.EaseElasticInOut;
        a.initWithAction(this._inner.clone(), this._period);
        return a
    }
});
cc.EaseElasticInOut.create = function(a, b) {
    return new cc.EaseElasticInOut(a, b)
};
cc.easeElasticInOut = function(a) {
    return {
        _period: a || 0.3,
        easing: function(a) {
            var d = 0,
                d = this._period;
            if (0 === a || 1 === a) d = a;
            else {
                d || (d = this._period = 0.3 * 1.5);
                var e = d / 4;
                a = 2 * a - 1;
                d = 0 > a ? -0.5 * Math.pow(2, 10 * a) * Math.sin(2 * (a - e) * Math.PI / d) : 0.5 * Math.pow(2, -10 * a) * Math.sin(2 * (a - e) * Math.PI / d) + 1
            }
            return d
        },
        reverse: function() {
            return cc.easeElasticInOut(this._period)
        }
    }
};
cc.EaseBounce = cc.ActionEase.extend({
    bounceTime: function(a) {
        if (a < 1 / 2.75) return 7.5625 * a * a;
        if (a < 2 / 2.75) return a -= 1.5 / 2.75, 7.5625 * a * a + 0.75;
        if (a < 2.5 / 2.75) return a -= 2.25 / 2.75, 7.5625 * a * a + 0.9375;
        a -= 2.625 / 2.75;
        return 7.5625 * a * a + 0.984375
    },
    clone: function() {
        var a = new cc.EaseBounce;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseBounce(this._inner.reverse())
    }
});
cc.EaseBounce.create = function(a) {
    return new cc.EaseBounce(a)
};
cc.EaseBounceIn = cc.EaseBounce.extend({
    update: function(a) {
        a = 1 - this.bounceTime(1 - a);
        this._inner.update(a)
    },
    reverse: function() {
        return new cc.EaseBounceOut(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseBounceIn;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseBounceIn.create = function(a) {
    return new cc.EaseBounceIn(a)
};
cc._bounceTime = function(a) {
    if (a < 1 / 2.75) return 7.5625 * a * a;
    if (a < 2 / 2.75) return a -= 1.5 / 2.75, 7.5625 * a * a + 0.75;
    if (a < 2.5 / 2.75) return a -= 2.25 / 2.75, 7.5625 * a * a + 0.9375;
    a -= 2.625 / 2.75;
    return 7.5625 * a * a + 0.984375
};
cc._easeBounceInObj = {
    easing: function(a) {
        return 1 - cc._bounceTime(1 - a)
    },
    reverse: function() {
        return cc._easeBounceOutObj
    }
};
cc.easeBounceIn = function() {
    return cc._easeBounceInObj
};
cc.EaseBounceOut = cc.EaseBounce.extend({
    update: function(a) {
        a = this.bounceTime(a);
        this._inner.update(a)
    },
    reverse: function() {
        return new cc.EaseBounceIn(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseBounceOut;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseBounceOut.create = function(a) {
    return new cc.EaseBounceOut(a)
};
cc._easeBounceOutObj = {
    easing: function(a) {
        return cc._bounceTime(a)
    },
    reverse: function() {
        return cc._easeBounceInObj
    }
};
cc.easeBounceOut = function() {
    return cc._easeBounceOutObj
};
cc.EaseBounceInOut = cc.EaseBounce.extend({
    update: function(a) {
        var b = 0,
            b = 0.5 > a ? 0.5 * (1 - this.bounceTime(1 - 2 * a)) : 0.5 * this.bounceTime(2 * a - 1) + 0.5;
        this._inner.update(b)
    },
    clone: function() {
        var a = new cc.EaseBounceInOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseBounceInOut(this._inner.reverse())
    }
});
cc.EaseBounceInOut.create = function(a) {
    return new cc.EaseBounceInOut(a)
};
cc._easeBounceInOutObj = {
    easing: function(a) {
        return a = 0.5 > a ? 0.5 * (1 - cc._bounceTime(1 - 2 * a)) : 0.5 * cc._bounceTime(2 * a - 1) + 0.5
    },
    reverse: function() {
        return cc._easeBounceInOutObj
    }
};
cc.easeBounceInOut = function() {
    return cc._easeBounceInOutObj
};
cc.EaseBackIn = cc.ActionEase.extend({
    update: function(a) {
        this._inner.update(0 === a || 1 === a ? a : a * a * (2.70158 * a - 1.70158))
    },
    reverse: function() {
        return new cc.EaseBackOut(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseBackIn;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseBackIn.create = function(a) {
    return new cc.EaseBackIn(a)
};
cc._easeBackInObj = {
    easing: function(a) {
        return 0 === a || 1 === a ? a : a * a * (2.70158 * a - 1.70158)
    },
    reverse: function() {
        return cc._easeBackOutObj
    }
};
cc.easeBackIn = function() {
    return cc._easeBackInObj
};
cc.EaseBackOut = cc.ActionEase.extend({
    update: function(a) {
        a -= 1;
        this._inner.update(a * a * (2.70158 * a + 1.70158) + 1)
    },
    reverse: function() {
        return new cc.EaseBackIn(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseBackOut;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseBackOut.create = function(a) {
    return new cc.EaseBackOut(a)
};
cc._easeBackOutObj = {
    easing: function(a) {
        a -= 1;
        return a * a * (2.70158 * a + 1.70158) + 1
    },
    reverse: function() {
        return cc._easeBackInObj
    }
};
cc.easeBackOut = function() {
    return cc._easeBackOutObj
};
cc.EaseBackInOut = cc.ActionEase.extend({
    update: function(a) {
        a *= 2;
        1 > a ? this._inner.update(a * a * (3.5949095 * a - 2.5949095) / 2) : (a -= 2, this._inner.update(a * a * (3.5949095 * a + 2.5949095) / 2 + 1))
    },
    clone: function() {
        var a = new cc.EaseBackInOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseBackInOut(this._inner.reverse())
    }
});
cc.EaseBackInOut.create = function(a) {
    return new cc.EaseBackInOut(a)
};
cc._easeBackInOutObj = {
    easing: function(a) {
        a *= 2;
        if (1 > a) return a * a * (3.5949095 * a - 2.5949095) / 2;
        a -= 2;
        return a * a * (3.5949095 * a + 2.5949095) / 2 + 1
    },
    reverse: function() {
        return cc._easeBackInOutObj
    }
};
cc.easeBackInOut = function() {
    return cc._easeBackInOutObj
};
cc.EaseBezierAction = cc.ActionEase.extend({
    _p0: null,
    _p1: null,
    _p2: null,
    _p3: null,
    ctor: function(a) {
        cc.ActionEase.prototype.ctor.call(this, a)
    },
    _updateTime: function(a, b, d, e, f) {
        return Math.pow(1 - f, 3) * a + 3 * f * Math.pow(1 - f, 2) * b + 3 * Math.pow(f, 2) * (1 - f) * d + Math.pow(f, 3) * e
    },
    update: function(a) {
        a = this._updateTime(this._p0, this._p1, this._p2, this._p3, a);
        this._inner.update(a)
    },
    clone: function() {
        var a = new cc.EaseBezierAction;
        a.initWithAction(this._inner.clone());
        a.setBezierParamer(this._p0, this._p1, this._p2, this._p3);
        return a
    },
    reverse: function() {
        var a = new cc.EaseBezierAction(this._inner.reverse());
        a.setBezierParamer(this._p3, this._p2, this._p1, this._p0);
        return a
    },
    setBezierParamer: function(a, b, d, e) {
        this._p0 = a || 0;
        this._p1 = b || 0;
        this._p2 = d || 0;
        this._p3 = e || 0
    }
});
cc.EaseBezierAction.create = function(a) {
    return new cc.EaseBezierAction(a)
};
cc.easeBezierAction = function(a, b, d, e) {
    return {
        easing: function(f) {
            return cc.EaseBezierAction.prototype._updateTime(a, b, d, e, f)
        },
        reverse: function() {
            return cc.easeBezierAction(e, d, b, a)
        }
    }
};
cc.EaseQuadraticActionIn = cc.ActionEase.extend({
    _updateTime: function(a) {
        return Math.pow(a, 2)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuadraticActionIn;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseQuadraticActionIn(this._inner.reverse())
    }
});
cc.EaseQuadraticActionIn.create = function(a) {
    return new cc.EaseQuadraticActionIn(a)
};
cc._easeQuadraticActionIn = {
    easing: cc.EaseQuadraticActionIn.prototype._updateTime,
    reverse: function() {
        return cc._easeQuadraticActionIn
    }
};
cc.easeQuadraticActionIn = function() {
    return cc._easeQuadraticActionIn
};
cc.EaseQuadraticActionOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        return -a * (a - 2)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuadraticActionOut;
        a.initWithAction();
        return a
    },
    reverse: function() {
        return new cc.EaseQuadraticActionOut(this._inner.reverse())
    }
});
cc.EaseQuadraticActionOut.create = function(a) {
    return new cc.EaseQuadraticActionOut(a)
};
cc._easeQuadraticActionOut = {
    easing: cc.EaseQuadraticActionOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuadraticActionOut
    }
};
cc.easeQuadraticActionOut = function() {
    return cc._easeQuadraticActionOut
};
cc.EaseQuadraticActionInOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        var b = a;
        a *= 2;
        1 > a ? b = 0.5 * a * a : (--a, b = -0.5 * (a * (a - 2) - 1));
        return b
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuadraticActionInOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseQuadraticActionInOut(this._inner.reverse())
    }
});
cc.EaseQuadraticActionInOut.create = function(a) {
    return new cc.EaseQuadraticActionInOut(a)
};
cc._easeQuadraticActionInOut = {
    easing: cc.EaseQuadraticActionInOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuadraticActionInOut
    }
};
cc.easeQuadraticActionInOut = function() {
    return cc._easeQuadraticActionInOut
};
cc.EaseQuarticActionIn = cc.ActionEase.extend({
    _updateTime: function(a) {
        return a * a * a * a
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuarticActionIn;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseQuarticActionIn(this._inner.reverse())
    }
});
cc.EaseQuarticActionIn.create = function(a) {
    return new cc.EaseQuarticActionIn(a)
};
cc._easeQuarticActionIn = {
    easing: cc.EaseQuarticActionIn.prototype._updateTime,
    reverse: function() {
        return cc._easeQuarticActionIn
    }
};
cc.easeQuarticActionIn = function() {
    return cc._easeQuarticActionIn
};
cc.EaseQuarticActionOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        a -= 1;
        return -(a * a * a * a - 1)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuarticActionOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseQuarticActionOut(this._inner.reverse())
    }
});
cc.EaseQuarticActionOut.create = function(a) {
    return new cc.EaseQuarticActionOut(a)
};
cc._easeQuarticActionOut = {
    easing: cc.EaseQuarticActionOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuarticActionOut
    }
};
cc.easeQuarticActionOut = function() {
    return cc._easeQuarticActionOut
};
cc.EaseQuarticActionInOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        a *= 2;
        if (1 > a) return 0.5 * a * a * a * a;
        a -= 2;
        return -0.5 * (a * a * a * a - 2)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuarticActionInOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseQuarticActionInOut(this._inner.reverse())
    }
});
cc.EaseQuarticActionInOut.create = function(a) {
    return new cc.EaseQuarticActionInOut(a)
};
cc._easeQuarticActionInOut = {
    easing: cc.EaseQuarticActionInOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuarticActionInOut
    }
};
cc.easeQuarticActionInOut = function() {
    return cc._easeQuarticActionInOut
};
cc.EaseQuinticActionIn = cc.ActionEase.extend({
    _updateTime: function(a) {
        return a * a * a * a * a
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuinticActionIn;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseQuinticActionIn(this._inner.reverse())
    }
});
cc.EaseQuinticActionIn.create = function(a) {
    return new cc.EaseQuinticActionIn(a)
};
cc._easeQuinticActionIn = {
    easing: cc.EaseQuinticActionIn.prototype._updateTime,
    reverse: function() {
        return cc._easeQuinticActionIn
    }
};
cc.easeQuinticActionIn = function() {
    return cc._easeQuinticActionIn
};
cc.EaseQuinticActionOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        a -= 1;
        return a * a * a * a * a + 1
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuinticActionOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseQuinticActionOut(this._inner.reverse())
    }
});
cc.EaseQuinticActionOut.create = function(a) {
    return new cc.EaseQuinticActionOut(a)
};
cc._easeQuinticActionOut = {
    easing: cc.EaseQuinticActionOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuinticActionOut
    }
};
cc.easeQuinticActionOut = function() {
    return cc._easeQuinticActionOut
};
cc.EaseQuinticActionInOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        a *= 2;
        if (1 > a) return 0.5 * a * a * a * a * a;
        a -= 2;
        return 0.5 * (a * a * a * a * a + 2)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuinticActionInOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseQuinticActionInOut(this._inner.reverse())
    }
});
cc.EaseQuinticActionInOut.create = function(a) {
    return new cc.EaseQuinticActionInOut(a)
};
cc._easeQuinticActionInOut = {
    easing: cc.EaseQuinticActionInOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuinticActionInOut
    }
};
cc.easeQuinticActionInOut = function() {
    return cc._easeQuinticActionInOut
};
cc.EaseCircleActionIn = cc.ActionEase.extend({
    _updateTime: function(a) {
        return -1 * (Math.sqrt(1 - a * a) - 1)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseCircleActionIn;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseCircleActionIn(this._inner.reverse())
    }
});
cc.EaseCircleActionIn.create = function(a) {
    return new cc.EaseCircleActionIn(a)
};
cc._easeCircleActionIn = {
    easing: cc.EaseCircleActionIn.prototype._updateTime,
    reverse: function() {
        return cc._easeCircleActionIn
    }
};
cc.easeCircleActionIn = function() {
    return cc._easeCircleActionIn
};
cc.EaseCircleActionOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        a -= 1;
        return Math.sqrt(1 - a * a)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseCircleActionOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseCircleActionOut(this._inner.reverse())
    }
});
cc.EaseCircleActionOut.create = function(a) {
    return new cc.EaseCircleActionOut(a)
};
cc._easeCircleActionOut = {
    easing: cc.EaseCircleActionOut.prototype._updateTime,
    reverse: function() {
        return cc._easeCircleActionOut
    }
};
cc.easeCircleActionOut = function() {
    return cc._easeCircleActionOut
};
cc.EaseCircleActionInOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        a *= 2;
        if (1 > a) return -0.5 * (Math.sqrt(1 - a * a) - 1);
        a -= 2;
        return 0.5 * (Math.sqrt(1 - a * a) + 1)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseCircleActionInOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseCircleActionInOut(this._inner.reverse())
    }
});
cc.EaseCircleActionInOut.create = function(a) {
    return new cc.EaseCircleActionInOut(a)
};
cc._easeCircleActionInOut = {
    easing: cc.EaseCircleActionInOut.prototype._updateTime,
    reverse: function() {
        return cc._easeCircleActionInOut
    }
};
cc.easeCircleActionInOut = function() {
    return cc._easeCircleActionInOut
};
cc.EaseCubicActionIn = cc.ActionEase.extend({
    _updateTime: function(a) {
        return a * a * a
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseCubicActionIn;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseCubicActionIn(this._inner.reverse())
    }
});
cc.EaseCubicActionIn.create = function(a) {
    return new cc.EaseCubicActionIn(a)
};
cc._easeCubicActionIn = {
    easing: cc.EaseCubicActionIn.prototype._updateTime,
    reverse: function() {
        return cc._easeCubicActionIn
    }
};
cc.easeCubicActionIn = function() {
    return cc._easeCubicActionIn
};
cc.EaseCubicActionOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        a -= 1;
        return a * a * a + 1
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseCubicActionOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseCubicActionOut(this._inner.reverse())
    }
});
cc.EaseCubicActionOut.create = function(a) {
    return new cc.EaseCubicActionOut(a)
};
cc._easeCubicActionOut = {
    easing: cc.EaseCubicActionOut.prototype._updateTime,
    reverse: function() {
        return cc._easeCubicActionOut
    }
};
cc.easeCubicActionOut = function() {
    return cc._easeCubicActionOut
};
cc.EaseCubicActionInOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        a *= 2;
        if (1 > a) return 0.5 * a * a * a;
        a -= 2;
        return 0.5 * (a * a * a + 2)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseCubicActionInOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseCubicActionInOut(this._inner.reverse())
    }
});
cc.EaseCubicActionInOut.create = function(a) {
    return new cc.EaseCubicActionInOut(a)
};
cc._easeCubicActionInOut = {
    easing: cc.EaseCubicActionInOut.prototype._updateTime,
    reverse: function() {
        return cc._easeCubicActionInOut
    }
};
cc.easeCubicActionInOut = function() {
    return cc._easeCubicActionInOut
};
cc.cardinalSplineAt = function(a, b, d, e, f, g) {
    var h = g * g,
        k = h * g,
        m = (1 - f) / 2;
    f = m * (-k + 2 * h - g);
    var n = m * (-k + h) + (2 * k - 3 * h + 1);
    g = m * (k - 2 * h + g) + (-2 * k + 3 * h);
    h = m * (k - h);
    return cc.p(a.x * f + b.x * n + d.x * g + e.x * h, a.y * f + b.y * n + d.y * g + e.y * h)
};
cc.reverseControlPoints = function(a) {
    for (var b = [], d = a.length - 1; 0 <= d; d--) b.push(cc.p(a[d].x, a[d].y));
    return b
};
cc.cloneControlPoints = function(a) {
    for (var b = [], d = 0; d < a.length; d++) b.push(cc.p(a[d].x, a[d].y));
    return b
};
cc.copyControlPoints = cc.cloneControlPoints;
cc.getControlPointAt = function(a, b) {
    var d = Math.min(a.length - 1, Math.max(b, 0));
    return a[d]
};
cc.reverseControlPointsInline = function(a) {
    for (var b = a.length, d = 0 | b / 2, e = 0; e < d; ++e) {
        var f = a[e];
        a[e] = a[b - e - 1];
        a[b - e - 1] = f
    }
};
cc.CardinalSplineTo = cc.ActionInterval.extend({
    _points: null,
    _deltaT: 0,
    _tension: 0,
    _previousPosition: null,
    _accumulatedDiff: null,
    ctor: function(a, b, d) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._points = [];
        void 0 !== d && this.initWithDuration(a, b, d)
    },
    initWithDuration: function(a, b, d) {
        if (!b || 0 === b.length) throw Error("Invalid configuration. It must at least have one control point");
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this.setPoints(b), this._tension = d, !0) : !1
    },
    clone: function() {
        var a =
            new cc.CardinalSplineTo;
        a.initWithDuration(this._duration, cc.copyControlPoints(this._points), this._tension);
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._deltaT = 1 / (this._points.length - 1);
        this._previousPosition = cc.p(this.target.getPositionX(), this.target.getPositionY());
        this._accumulatedDiff = cc.p(0, 0)
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        var b, d = this._points;
        if (1 === a) b = d.length - 1, a = 1;
        else {
            var e = this._deltaT;
            b = 0 | a / e;
            a = (a - e * b) / e
        }
        b = cc.cardinalSplineAt(cc.getControlPointAt(d,
            b - 1), cc.getControlPointAt(d, b - 0), cc.getControlPointAt(d, b + 1), cc.getControlPointAt(d, b + 2), this._tension, a);
        if (cc.ENABLE_STACKABLE_ACTIONS && (d = this.target.getPositionX() - this._previousPosition.x, a = this.target.getPositionY() - this._previousPosition.y, 0 !== d || 0 !== a)) e = this._accumulatedDiff, d = e.x + d, a = e.y + a, e.x = d, e.y = a, b.x += d, b.y += a;
        this.updatePosition(b)
    },
    reverse: function() {
        var a = cc.reverseControlPoints(this._points);
        return cc.cardinalSplineTo(this._duration, a, this._tension)
    },
    updatePosition: function(a) {
        this.target.setPosition(a);
        this._previousPosition = a
    },
    getPoints: function() {
        return this._points
    },
    setPoints: function(a) {
        this._points = a
    }
});
cc.cardinalSplineTo = function(a, b, d) {
    return new cc.CardinalSplineTo(a, b, d)
};
cc.CardinalSplineTo.create = cc.cardinalSplineTo;
cc.CardinalSplineBy = cc.CardinalSplineTo.extend({
    _startPosition: null,
    ctor: function(a, b, d) {
        cc.CardinalSplineTo.prototype.ctor.call(this);
        this._startPosition = cc.p(0, 0);
        void 0 !== d && this.initWithDuration(a, b, d)
    },
    startWithTarget: function(a) {
        cc.CardinalSplineTo.prototype.startWithTarget.call(this, a);
        this._startPosition.x = a.getPositionX();
        this._startPosition.y = a.getPositionY()
    },
    reverse: function() {
        for (var a = this._points.slice(), b, d = a[0], e = 1; e < a.length; ++e) b = a[e], a[e] = cc.pSub(b, d), d = b;
        a = cc.reverseControlPoints(a);
        d = a[a.length - 1];
        a.pop();
        d.x = -d.x;
        d.y = -d.y;
        a.unshift(d);
        for (e = 1; e < a.length; ++e) b = a[e], b.x = -b.x, b.y = -b.y, b.x += d.x, b.y += d.y, d = a[e] = b;
        return cc.cardinalSplineBy(this._duration, a, this._tension)
    },
    updatePosition: function(a) {
        var b = this._startPosition,
            d = a.x + b.x;
        a = a.y + b.y;
        this._previousPosition.x = d;
        this._previousPosition.y = a;
        this.target.setPosition(d, a)
    },
    clone: function() {
        var a = new cc.CardinalSplineBy;
        a.initWithDuration(this._duration, cc.copyControlPoints(this._points), this._tension);
        return a
    }
});
cc.cardinalSplineBy = function(a, b, d) {
    return new cc.CardinalSplineBy(a, b, d)
};
cc.CardinalSplineBy.create = cc.cardinalSplineBy;
cc.CatmullRomTo = cc.CardinalSplineTo.extend({
    ctor: function(a, b) {
        b && this.initWithDuration(a, b)
    },
    initWithDuration: function(a, b) {
        return cc.CardinalSplineTo.prototype.initWithDuration.call(this, a, b, 0.5)
    },
    clone: function() {
        var a = new cc.CatmullRomTo;
        a.initWithDuration(this._duration, cc.copyControlPoints(this._points));
        return a
    }
});
cc.catmullRomTo = function(a, b) {
    return new cc.CatmullRomTo(a, b)
};
cc.CatmullRomTo.create = cc.catmullRomTo;
cc.CatmullRomBy = cc.CardinalSplineBy.extend({
    ctor: function(a, b) {
        cc.CardinalSplineBy.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    initWithDuration: function(a, b) {
        return cc.CardinalSplineTo.prototype.initWithDuration.call(this, a, b, 0.5)
    },
    clone: function() {
        var a = new cc.CatmullRomBy;
        a.initWithDuration(this._duration, cc.copyControlPoints(this._points));
        return a
    }
});
cc.catmullRomBy = function(a, b) {
    return new cc.CatmullRomBy(a, b)
};
cc.CatmullRomBy.create = cc.catmullRomBy;
cc.ActionTweenDelegate = cc.Class.extend({
    updateTweenAction: function(a, b) {}
});
cc.ActionTween = cc.ActionInterval.extend({
    key: "",
    from: 0,
    to: 0,
    delta: 0,
    ctor: function(a, b, d, e) {
        cc.ActionInterval.prototype.ctor.call(this);
        this.key = "";
        void 0 !== e && this.initWithDuration(a, b, d, e)
    },
    initWithDuration: function(a, b, d, e) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this.key = b, this.to = e, this.from = d, !0) : !1
    },
    startWithTarget: function(a) {
        if (!a || !a.updateTweenAction) throw Error("cc.ActionTween.startWithTarget(): target must be non-null, and target must implement updateTweenAction function");
        cc.ActionInterval.prototype.startWithTarget.call(this,
            a);
        this.delta = this.to - this.from
    },
    update: function(a) {
        this.target.updateTweenAction(this.to - this.delta * (1 - a), this.key)
    },
    reverse: function() {
        return new cc.ActionTween(this.duration, this.key, this.to, this.from)
    },
    clone: function() {
        var a = new cc.ActionTween;
        a.initWithDuration(this._duration, this.key, this.from, this.to);
        return a
    }
});
cc.actionTween = function(a, b, d, e) {
    return new cc.ActionTween(a, b, d, e)
};
cc.ActionTween.create = cc.actionTween;
cc.LabelAtlas = cc.AtlasNode.extend({
    _string: null,
    _mapStartChar: null,
    _textureLoaded: !1,
    _className: "LabelAtlas",
    ctor: function(a, b, d, e, f) {
        cc.AtlasNode.prototype.ctor.call(this);
        this._renderCmd.setCascade();
        b && cc.LabelAtlas.prototype.initWithString.call(this, a, b, d, e, f)
    },
    _createRenderCmd: function() {
        return cc._renderType === cc._RENDER_TYPE_WEBGL ? new cc.LabelAtlas.WebGLRenderCmd(this) : new cc.LabelAtlas.CanvasRenderCmd(this)
    },
    textureLoaded: function() {
        return this._textureLoaded
    },
    addLoadedEventListener: function(a,
        b) {
        this.addEventListener("load", a, b)
    },
    initWithString: function(a, b, d, e, f) {
        var g = a + "",
            h, k;
        if (void 0 === d) {
            d = cc.loader.getRes(b);
            if (1 !== parseInt(d.version, 10)) return cc.log("cc.LabelAtlas.initWithString(): Unsupported version. Upgrade cocos2d version"), !1;
            b = cc.path.changeBasename(b, d.textureFilename);
            e = cc.contentScaleFactor();
            h = parseInt(d.itemWidth, 10) / e;
            k = parseInt(d.itemHeight, 10) / e;
            d = String.fromCharCode(parseInt(d.firstChar, 10))
        } else h = d || 0, k = e || 0, d = f || " ";
        var m = null,
            m = b instanceof cc.Texture2D ? b : cc.textureCache.addImage(b);
        this._textureLoaded = b = m.isLoaded();
        b || (this._string = g, m.addEventListener("load", function(a) {
            this.initWithTexture(m, h, k, g.length);
            this.string = this._string;
            this.setColor(this._renderCmd._displayedColor);
            this.dispatchEvent("load")
        }, this));
        return this.initWithTexture(m, h, k, g.length) ? (this._mapStartChar = d, this.string = g, !0) : !1
    },
    setColor: function(a) {
        cc.AtlasNode.prototype.setColor.call(this, a);
        this._renderCmd.updateAtlasValues()
    },
    getString: function() {
        return this._string
    },
    addChild: function(a, b, d) {
        this._renderCmd._addChild(a);
        cc.Node.prototype.addChild.call(this, a, b, d)
    },
    updateAtlasValues: function() {
        this._renderCmd.updateAtlasValues()
    },
    setString: function(a) {
        a = String(a);
        var b = a.length;
        this._string = a;
        this.setContentSize(b * this._itemWidth, this._itemHeight);
        this._renderCmd.setString(a);
        this._renderCmd.updateAtlasValues();
        this.quadsToDraw = b
    }
});
(function() {
    var a = cc.LabelAtlas.prototype;
    cc.defineGetterSetter(a, "opacity", a.getOpacity, a.setOpacity);
    cc.defineGetterSetter(a, "color", a.getColor, a.setColor);
    cc.defineGetterSetter(a, "string", a.getString, a.setString)
})();
cc.LabelAtlas.create = function(a, b, d, e, f) {
    return new cc.LabelAtlas(a, b, d, e, f)
};
(function() {
    cc.LabelAtlas.CanvasRenderCmd = function(a) {
        cc.AtlasNode.CanvasRenderCmd.call(this, a);
        this._needDraw = !1
    };
    var a = cc.LabelAtlas.CanvasRenderCmd.prototype = Object.create(cc.AtlasNode.CanvasRenderCmd.prototype);
    a.constructor = cc.LabelAtlas.CanvasRenderCmd;
    a.setCascade = function() {
        var a = this._node;
        a._cascadeOpacityEnabled = !0;
        a._cascadeColorEnabled = !1
    };
    a.updateAtlasValues = function() {
        for (var a = this._node, d = a._string || "", e = d.length, f = this._texture, g = a._itemWidth, h = a._itemHeight, k = 0, m = -1; k < e; k++) {
            var n =
                d.charCodeAt(k) - a._mapStartChar.charCodeAt(0),
                p = parseInt(n % a._itemsPerRow, 10),
                n = parseInt(n / a._itemsPerRow, 10);
            if (!(0 > p || 0 > n))
                if (p = cc.rect(p * g, n * h, g, h), n = f._contentSize, !(0 > p.x || 0 > p.y || p.x + p.width > n.width || p.y + p.height > n.height)) {
                    m++;
                    var n = d.charCodeAt(k),
                        r = a.getChildByTag(k);
                    r ? 32 === n ? (r.init(), r.setTextureRect(cc.rect(0, 0, 10, 10), !1, cc.size(0, 0))) : (r.initWithTexture(f, p), r.visible = !0) : (r = new cc.Sprite, 32 === n ? (r.init(), r.setTextureRect(cc.rect(0, 0, 10, 10), !1, cc.size(0, 0))) : r.initWithTexture(f, p), cc.Node.prototype.addChild.call(a,
                        r, 0, k));
                    r.setPosition(m * g + g / 2, h / 2)
                }
        }
        this.updateContentSize(k, m + 1)
    };
    a.updateContentSize = function(a, d) {
        var e = this._node,
            f = e._contentSize;
        a !== d && (a * e._itemWidth === f.width && e._itemHeight === f.height) && e.setContentSize(d * e._itemWidth, e._itemHeight)
    };
    a.setString = function(a) {
        a = this._node;
        if (a._children) {
            a = a._children;
            for (var d = a.length, e = 0; e < d; e++) {
                var f = a[e];
                f && !f._lateChild && (f.visible = !1)
            }
        }
    };
    a._addChild = function() {
        child._lateChild = !0
    }
})();
(function() {
    cc.LabelAtlas.WebGLRenderCmd = function(a) {
        cc.AtlasNode.WebGLRenderCmd.call(this, a);
        this._needDraw = !0
    };
    var a = cc.LabelAtlas.WebGLRenderCmd.prototype = Object.create(cc.AtlasNode.WebGLRenderCmd.prototype);
    a.constructor = cc.LabelAtlas.WebGLRenderCmd;
    a.setCascade = function() {
        var a = this._node;
        a._cascadeOpacityEnabled = !0;
        a._cascadeColorEnabled = !0
    };
    a.rendering = function(a) {
        cc.AtlasNode.WebGLRenderCmd.prototype.rendering.call(this, a);
        cc.LABELATLAS_DEBUG_DRAW && (a = this._node.getContentSize(), a = [cc.p(0,
            0), cc.p(a.width, 0), cc.p(a.width, a.height), cc.p(0, a.height)], cc._drawingUtil.drawPoly(a, 4, !0))
    };
    a.updateAtlasValues = function() {
        var a = this._node,
            d = a._string,
            e = d.length,
            f = this._textureAtlas,
            g = f.texture,
            h = g.pixelsWidth,
            g = g.pixelsHeight,
            k = a._itemWidth,
            m = a._itemHeight;
        a._ignoreContentScaleFactor || (k = a._itemWidth * cc.contentScaleFactor(), m = a._itemHeight * cc.contentScaleFactor());
        e > f.getCapacity() && cc.log("cc.LabelAtlas._updateAtlasValues(): Invalid String length");
        for (var n = f.quads, p = this._displayedColor,
            p = {
                r: p.r,
                g: p.g,
                b: p.b,
                a: a._displayedOpacity
            }, r = a._itemWidth, s = a._itemHeight, t = 0, u = -1; t < e; t++) {
            var v = d.charCodeAt(t) - a._mapStartChar.charCodeAt(0),
                w = v % a._itemsPerRow,
                x = 0 | v / a._itemsPerRow;
            if (!(0 > w || 0 > x))
                if (!(w * r + r > h || x * s + s > g)) {
                    u++;
                    var B;
                    cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (w = (2 * w * k + 1) / (2 * h), v = w + (2 * k - 2) / (2 * h), x = (2 * x * m + 1) / (2 * g), B = x + (2 * m - 2) / (2 * g)) : (w = w * k / h, v = w + k / h, x = x * m / g, B = x + m / g);
                    var y = n[t],
                        z = y.tl,
                        A = y.tr,
                        C = y.bl,
                        y = y.br;
                    z.texCoords.u = w;
                    z.texCoords.v = x;
                    A.texCoords.u = v;
                    A.texCoords.v = x;
                    C.texCoords.u = w;
                    C.texCoords.v =
                        B;
                    y.texCoords.u = v;
                    y.texCoords.v = B;
                    C.vertices.x = u * r;
                    C.vertices.y = 0;
                    C.vertices.z = 0;
                    y.vertices.x = u * r + r;
                    y.vertices.y = 0;
                    y.vertices.z = 0;
                    z.vertices.x = u * r;
                    z.vertices.y = a._itemHeight;
                    z.vertices.z = 0;
                    A.vertices.x = u * r + r;
                    A.vertices.y = a._itemHeight;
                    A.vertices.z = 0;
                    z.colors = p;
                    A.colors = p;
                    C.colors = p;
                    y.colors = p
                }
        }
        this.updateContentSize(t, u + 1);
        0 < e && (f.dirty = !0, a = f.totalQuads, e > a && f.increaseTotalQuadsWith(e - a))
    };
    a.updateContentSize = function(a, d) {
        var e = this._node,
            f = e._contentSize;
        a !== d && (a * e._itemWidth === f.width && e._itemHeight ===
            f.height) && e.setContentSize(d * e._itemWidth, e._itemHeight)
    };
    a.setString = function(a) {
        a = a.length;
        a > this._textureAtlas.totalQuads && this._textureAtlas.resizeCapacity(a)
    };
    a._addChild = function() {}
})();
cc.LABEL_AUTOMATIC_WIDTH = -1;
cc.LabelBMFont = cc.SpriteBatchNode.extend({
    _opacityModifyRGB: !1,
    _string: "",
    _config: null,
    _fntFile: "",
    _initialString: "",
    _alignment: cc.TEXT_ALIGNMENT_CENTER,
    _width: -1,
    _lineBreakWithoutSpaces: !1,
    _imageOffset: null,
    _reusedChar: null,
    _textureLoaded: !1,
    _className: "LabelBMFont",
    _createRenderCmd: function() {
        return cc._renderType === cc._RENDER_TYPE_WEBGL ? new cc.LabelBMFont.WebGLRenderCmd(this) : new cc.LabelBMFont.CanvasRenderCmd(this)
    },
    _setString: function(a, b) {
        b ? this._initialString = a : this._string = a;
        var d = this._children;
        if (d)
            for (var e = 0; e < d.length; e++) {
                var f = d[e];
                f && f.setVisible(!1)
            }
        this._textureLoaded && (this.createFontChars(), b && this.updateLabel())
    },
    ctor: function(a, b, d, e, f) {
        cc.SpriteBatchNode.prototype.ctor.call(this);
        this._imageOffset = cc.p(0, 0);
        this._reusedChar = [];
        this._cascadeOpacityEnabled = this._cascadeColorEnabled = !0;
        this.initWithString(a, b, d, e, f)
    },
    textureLoaded: function() {
        return this._textureLoaded
    },
    addLoadedEventListener: function(a, b) {
        this.addEventListener("load", a, b)
    },
    isOpacityModifyRGB: function() {
        return this._opacityModifyRGB
    },
    setOpacityModifyRGB: function(a) {
        this._opacityModifyRGB = a;
        if (a = this._children)
            for (var b = 0; b < a.length; b++) {
                var d = a[b];
                d && (d.opacityModifyRGB = this._opacityModifyRGB)
            }
    },
    _changeTextureColor: function() {
        this._renderCmd._changeTextureColor()
    },
    init: function() {
        return this.initWithString(null, null, null, null, null)
    },
    initWithString: function(a, b, d, e, f) {
        a = a || "";
        this._config && cc.log("cc.LabelBMFont.initWithString(): re-init is no longer supported");
        if (b) {
            var g = cc.loader.getRes(b);
            if (!g) return cc.log("cc.LabelBMFont.initWithString(): Impossible to create font. Please check file"), !1;
            this._config = g;
            this._fntFile = b;
            b = cc.textureCache.addImage(g.atlasName);
            (this._textureLoaded = g = b.isLoaded()) || b.addEventListener("load", function(a) {
                this._textureLoaded = !0;
                this.initWithTexture(a, this._initialString.length);
                this.setString(this._initialString, !0);
                this.dispatchEvent("load")
            }, this)
        } else b = new cc.Texture2D, g = new Image, b.initWithElement(g), this._textureLoaded = !1;
        return this.initWithTexture(b, a.length) ? (this._alignment = e || cc.TEXT_ALIGNMENT_LEFT, this._imageOffset = f || cc.p(0, 0), this._width =
            null == d ? -1 : d, this._realOpacity = 255, this._realColor = cc.color(255, 255, 255, 255), this._contentSize.width = 0, this._contentSize.height = 0, this.setAnchorPoint(0.5, 0.5), this._renderCmd._initBatchTexture(), this.setString(a, !0), !0) : !1
    },
    createFontChars: function() {
        var a = this._renderCmd._texture || this.textureAtlas.texture,
            b = 0,
            d = cc.size(0, 0),
            e = 0,
            f = 1,
            g = this._string,
            h = g ? g.length : 0;
        if (0 !== h) {
            var k, m = this._config,
                n = m.kerningDict,
                p = m.commonHeight,
                r = m.fontDefDictionary;
            for (k = 0; k < h - 1; k++) 10 === g.charCodeAt(k) && f++;
            var s =
                p * f,
                f = -(p - p * f),
                t = -1;
            for (k = 0; k < h; k++)
                if (p = g.charCodeAt(k), 0 !== p)
                    if (10 === p) b = 0, f -= m.commonHeight;
                    else {
                        var t = n[t << 16 | p & 65535] || 0,
                            u = r[p];
                        u || (cc.log("cocos2d: LabelBMFont: character not found " + g[k]), u = {
                            rect: {
                                x: 0,
                                y: 0,
                                width: 0,
                                height: 0
                            },
                            xOffset: 0,
                            yOffset: 0,
                            xAdvance: 0
                        });
                        var v = cc.rect(u.rect.x, u.rect.y, u.rect.width, u.rect.height),
                            v = cc.rectPixelsToPoints(v);
                        v.x += this._imageOffset.x;
                        v.y += this._imageOffset.y;
                        var w = this.getChildByTag(k);
                        w ? this._renderCmd._updateCharTexture(w, v, p) : (w = new cc.Sprite, w.initWithTexture(a,
                            v, !1), w._newTextureWhenChangeColor = !0, this.addChild(w, 0, k));
                        w.opacityModifyRGB = this._opacityModifyRGB;
                        this._renderCmd._updateCharColorAndOpacity(w);
                        v = cc.p(b + u.xOffset + 0.5 * u.rect.width + t, f + (m.commonHeight - u.yOffset) - 0.5 * v.height * cc.contentScaleFactor());
                        w.setPosition(cc.pointPixelsToPoints(v));
                        b += u.xAdvance + t;
                        t = p;
                        e < b && (e = b)
                    }
            d.width = u && u.xAdvance < u.rect.width ? e - u.xAdvance + u.rect.width : e;
            d.height = s;
            this.setContentSize(cc.sizePixelsToPoints(d))
        }
    },
    updateString: function(a) {
        var b = this._children;
        if (b)
            for (var d =
                0, e = b.length; d < e; d++) {
                var f = b[d];
                f && (f.visible = !1)
            }
        this._config && this.createFontChars();
        a || this.updateLabel()
    },
    getString: function() {
        return this._initialString
    },
    setString: function(a, b) {
        a = String(a);
        null == b && (b = !0);
        if (null == a || !cc.isString(a)) a += "";
        this._initialString = a;
        this._setString(a, b)
    },
    _setStringForSetter: function(a) {
        this.setString(a, !1)
    },
    setCString: function(a) {
        this.setString(a, !0)
    },
    _getCharsWidth: function(a, b) {
        if (0 >= b) return 0;
        var d = this.getChildByTag(a),
            e = this.getChildByTag(a + b);
        return this._getLetterPosXLeft(e) -
            this._getLetterPosXLeft(d)
    },
    _checkWarp: function(a, b, d, e) {
        for (var f = a[b], g = 0, h = 0; h < b; h++) g += a[h].length;
        var g = g + b - e,
            k = this._getCharsWidth(g, a[b].length - 1);
        if (k > d && 1 < f.length) {
            e = f.length * (d / k) | 0;
            for (var h = f.substr(e), m = k - this._getCharsWidth(g + e, h.length - 1), n, p = 0, r = 0; m > d && 100 > r++;) e *= d / m, e |= 0, h = f.substr(e), m = k - this._getCharsWidth(g + e, h.length - 1);
            for (r = 0; m < d && 100 > r++;) h && (p = (n = cc.LabelTTF._wordRex.exec(h)) ? n[0].length : 1, n = h), this._lineBreakWithoutSpaces && (p = 0), e += p, h = f.substr(e), m = k - this._getCharsWidth(g +
                e, h.length - 1);
            e -= p;
            0 === e && (e = 1, n = n.substr(1));
            d = f.substr(0, e);
            if (cc.LabelTTF.wrapInspection && cc.LabelTTF._symbolRex.test(n || h)) p = (g = cc.LabelTTF._lastWordRex.exec(d)) ? g[0].length : 0, this._lineBreakWithoutSpaces && (p = 0), e -= p, n = f.substr(e), d = f.substr(0, e);
            if (cc.LabelTTF._firsrEnglish.test(n) && (g = cc.LabelTTF._lastEnglish.exec(d)) && d !== g[0]) p = g[0].length, this._lineBreakWithoutSpaces && (p = 0), e -= p, n = f.substr(e), d = f.substr(0, e);
            a[b] = n || h;
            a.splice(b, 0, d)
        }
    },
    updateLabel: function() {
        this.string = this._initialString;
        var a, b, d;
        if (0 < this._width) {
            var e = this.string.split("\n"),
                f = "",
                g = 0,
                h = 0;
            for (a = 0; a < e.length; a++) h = e.length, this._checkWarp(e, a, this._width * this._scaleX, g), h < e.length && g++, 0 < a && (f += "\n"), f += e[a];
            f += String.fromCharCode(0);
            this._setString(f, !1)
        }
        if (this._alignment !== cc.TEXT_ALIGNMENT_LEFT) {
            e = a = 0;
            f = this._string.length;
            g = [];
            for (h = 0; h < f; h++)
                if (10 === this._string[h].charCodeAt(0) || 0 === this._string[h].charCodeAt(0)) {
                    b = 0;
                    var k = g.length;
                    if (0 === k) e++;
                    else if (d = a + k - 1 + e, !(0 > d)) {
                        var m = this.getChildByTag(d);
                        if (null !=
                            m) {
                            b = m.getPositionX() + m._getWidth() / 2;
                            m = 0;
                            switch (this._alignment) {
                                case cc.TEXT_ALIGNMENT_CENTER:
                                    m = this.width / 2 - b / 2;
                                    break;
                                case cc.TEXT_ALIGNMENT_RIGHT:
                                    m = this.width - b
                            }
                            if (0 !== m)
                                for (b = 0; b < k; b++) d = a + b + e, 0 > d || (d = this.getChildByTag(d)) && (d.x += m);
                            a += k;
                            e++;
                            g.length = 0
                        }
                    }
                } else g.push(this._string[a])
        }
    },
    setAlignment: function(a) {
        this._alignment = a;
        this.updateLabel()
    },
    _getAlignment: function() {
        return this._alignment
    },
    setBoundingWidth: function(a) {
        this._width = a;
        this.updateLabel()
    },
    _getBoundingWidth: function() {
        return this._width
    },
    setLineBreakWithoutSpace: function(a) {
        this._lineBreakWithoutSpaces = a;
        this.updateLabel()
    },
    setScale: function(a, b) {
        cc.Node.prototype.setScale.call(this, a, b);
        this.updateLabel()
    },
    setScaleX: function(a) {
        cc.Node.prototype.setScaleX.call(this, a);
        this.updateLabel()
    },
    setScaleY: function(a) {
        cc.Node.prototype.setScaleY.call(this, a);
        this.updateLabel()
    },
    setFntFile: function(a) {
        if (null != a && a !== this._fntFile) {
            var b = cc.loader.getRes(a);
            b ? (this._fntFile = a, this._config = b, a = cc.textureCache.addImage(b.atlasName), this._textureLoaded =
                b = a.isLoaded(), this.texture = a, this._renderCmd._updateFntFileTexture(), b ? this.createFontChars() : a.addEventListener("load", function(a) {
                    this._textureLoaded = !0;
                    this.texture = a;
                    this.createFontChars();
                    this._changeTextureColor();
                    this.updateLabel();
                    this.dispatchEvent("load")
                }, this)) : cc.log("cc.LabelBMFont.setFntFile() : Impossible to create font. Please check file")
        }
    },
    getFntFile: function() {
        return this._fntFile
    },
    setTexture: function(a) {
        this._renderCmd.setTexture(a)
    },
    setAnchorPoint: function(a, b) {
        cc.Node.prototype.setAnchorPoint.call(this,
            a, b);
        this.updateLabel()
    },
    _setAnchorX: function(a) {
        cc.Node.prototype._setAnchorX.call(this, a);
        this.updateLabel()
    },
    _setAnchorY: function(a) {
        cc.Node.prototype._setAnchorY.call(this, a);
        this.updateLabel()
    },
    _atlasNameFromFntFile: function(a) {},
    _kerningAmountForFirst: function(a, b) {
        var d = 0;
        if (this._configuration.kerningDictionary) {
            var e = this._configuration.kerningDictionary[(a << 16 | b & 65535).toString()];
            e && (d = e.amount)
        }
        return d
    },
    _getLetterPosXLeft: function(a) {
        return a.getPositionX() * this._scaleX - a._getWidth() *
            this._scaleX * a._getAnchorX()
    },
    _getLetterPosXRight: function(a) {
        return a.getPositionX() * this._scaleX + a._getWidth() * this._scaleX * a._getAnchorX()
    },
    _isspace_unicode: function(a) {
        a = a.charCodeAt(0);
        return 9 <= a && 13 >= a || 32 === a || 133 === a || 160 === a || 5760 === a || 8192 <= a && 8202 >= a || 8232 === a || 8233 === a || 8239 === a || 8287 === a || 12288 === a
    },
    _utf8_trim_ws: function(a) {
        var b = a.length;
        if (!(0 >= b) && (b -= 1, this._isspace_unicode(a[b]))) {
            for (var d = b - 1; 0 <= d; --d)
                if (this._isspace_unicode(a[d])) b = d;
                else break;
            this._utf8_trim_from(a, b)
        }
    },
    _utf8_trim_from: function(a, b) {
        var d = a.length;
        b >= d || 0 > b || a.splice(b, d)
    }
});
(function() {
    var a = cc.LabelBMFont.prototype;
    cc.EventHelper.prototype.apply(a);
    cc.defineGetterSetter(a, "string", a.getString, a._setStringForSetter);
    cc.defineGetterSetter(a, "boundingWidth", a._getBoundingWidth, a.setBoundingWidth);
    cc.defineGetterSetter(a, "textAlign", a._getAlignment, a.setAlignment)
})();
cc.LabelBMFont.create = function(a, b, d, e, f) {
    return new cc.LabelBMFont(a, b, d, e, f)
};
cc._fntLoader = {
    INFO_EXP: /info [^\n]*(\n|$)/gi,
    COMMON_EXP: /common [^\n]*(\n|$)/gi,
    PAGE_EXP: /page [^\n]*(\n|$)/gi,
    CHAR_EXP: /char [^\n]*(\n|$)/gi,
    KERNING_EXP: /kerning [^\n]*(\n|$)/gi,
    ITEM_EXP: /\w+=[^ \r\n]+/gi,
    INT_EXP: /^[\-]?\d+$/,
    _parseStrToObj: function(a) {
        a = a.match(this.ITEM_EXP);
        var b = {};
        if (a)
            for (var d = 0, e = a.length; d < e; d++) {
                var f = a[d],
                    g = f.indexOf("\x3d"),
                    h = f.substring(0, g),
                    f = f.substring(g + 1);
                f.match(this.INT_EXP) ? f = parseInt(f) : '"' === f[0] && (f = f.substring(1, f.length - 1));
                b[h] = f
            }
        return b
    },
    parseFnt: function(a,
        b) {
        var d = {},
            e = this._parseStrToObj(a.match(this.INFO_EXP)[0]).padding.split(",");
        parseInt(e[0]);
        parseInt(e[1]);
        parseInt(e[2]);
        parseInt(e[3]);
        e = this._parseStrToObj(a.match(this.COMMON_EXP)[0]);
        d.commonHeight = e.lineHeight;
        if (cc._renderType === cc._RENDER_TYPE_WEBGL) {
            var f = cc.configuration.getMaxTextureSize();
            (e.scaleW > f.width || e.scaleH > f.height) && cc.log("cc.LabelBMFont._parseCommonArguments(): page can't be larger than supported")
        }
        1 !== e.pages && cc.log("cc.LabelBMFont._parseCommonArguments(): only supports 1 page");
        e = this._parseStrToObj(a.match(this.PAGE_EXP)[0]);
        0 !== e.id && cc.log("cc.LabelBMFont._parseImageFileName() : file could not be found");
        d.atlasName = cc.path.changeBasename(b, e.file);
        for (var g = a.match(this.CHAR_EXP), h = d.fontDefDictionary = {}, e = 0, f = g.length; e < f; e++) {
            var k = this._parseStrToObj(g[e]);
            h[k.id] = {
                rect: {
                    x: k.x,
                    y: k.y,
                    width: k.width,
                    height: k.height
                },
                xOffset: k.xoffset,
                yOffset: k.yoffset,
                xAdvance: k.xadvance
            }
        }
        g = d.kerningDict = {};
        if (h = a.match(this.KERNING_EXP)) {
            e = 0;
            for (f = h.length; e < f; e++) k = this._parseStrToObj(h[e]),
                g[k.first << 16 | k.second & 65535] = k.amount
        }
        return d
    },
    load: function(a, b, d, e) {
        var f = this;
        cc.loader.loadTxt(a, function(a, d) {
            if (a) return e(a);
            e(null, f.parseFnt(d, b))
        })
    }
};
cc.loader.register(["fnt"], cc._fntLoader);
(function() {
    cc.LabelBMFont.CanvasRenderCmd = function(a) {
        cc.SpriteBatchNode.CanvasRenderCmd.call(this, a);
        this._needDraw = !0
    };
    var a = cc.LabelBMFont.CanvasRenderCmd.prototype = Object.create(cc.SpriteBatchNode.CanvasRenderCmd.prototype);
    a.constructor = cc.LabelBMFont.CanvasRenderCmd;
    a.rendering = function() {
        void 0
    };
    a._updateCharTexture = function(a, d, e) {
        32 === e ? a.setTextureRect(d, !1, cc.size(0, 0)) : (a.setTextureRect(d, !1), a.visible = !0)
    };
    a._updateCharColorAndOpacity = function(a) {
        a._displayedColor = this._displayedColor;
        a._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty);
        a._displayedOpacity = this._displayedOpacity;
        a._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
    };
    a._updateFntFileTexture = function() {
        var a = this._node;
        a._originalTexture = a.texture
    };
    a.setTexture = function(a) {
        for (var d = this._node._children, e = this._displayedColor, f = 0; f < d.length; f++) {
            var g = d[f],
                h = g._renderCmd,
                k = h._displayedColor;
            this._texture !== h._texture && (k.r !== e.r || k.g !== e.g || k.b !== e.b) || (g.texture = a)
        }
        this._texture = a
    };
    a._changeTextureColor =
        cc.sys._supportCanvasNewBlendModes ? function() {
            var a = this._node,
                d = a.getTexture();
            if (d && 0 < d.getContentSize().width) {
                var e = this._originalTexture.getHtmlElementObj();
                if (e) {
                    var f = d.getHtmlElementObj(),
                        g = cc.rect(0, 0, e.width, e.height);
                    f instanceof HTMLCanvasElement && !a._rectRotated ? cc.Sprite.CanvasRenderCmd._generateTintImageWithMultiply(e, this._displayedColor, g, f) : (f = cc.Sprite.CanvasRenderCmd._generateTintImageWithMultiply(e, this._displayedColor, g), d = new cc.Texture2D, d.initWithElement(f), d.handleLoadedTexture());
                    a.setTexture(d)
                }
            }
        } : function() {
            var a = this._node,
                d, e = a.getTexture();
            if (e && 0 < e.getContentSize().width && (d = e.getHtmlElementObj())) {
                var f = cc.textureCache.getTextureColors(this._originalTexture.getHtmlElementObj());
                f && (d instanceof HTMLCanvasElement && !this._rectRotated ? (cc.Sprite.CanvasRenderCmd._generateTintImage(d, f, this._displayedColor, null, d), this.setTexture(e)) : (d = cc.Sprite.CanvasRenderCmd._generateTintImage(d, f, this._displayedColor), e = new cc.Texture2D, e.initWithElement(d), e.handleLoadedTexture(),
                    a.setTexture(e)))
            }
        };
    a._updateChildrenDisplayedOpacity = function(a) {
        cc.Node.prototype.updateDisplayedOpacity.call(a, this._displayedOpacity)
    };
    a._updateChildrenDisplayedColor = function(a) {
        cc.Node.prototype.updateDisplayedColor.call(a, this._displayedColor)
    };
    a._initBatchTexture = function() {}
})();
(function() {
    cc.LabelBMFont.WebGLRenderCmd = function(a) {
        cc.SpriteBatchNode.WebGLRenderCmd.call(this, a);
        this._needDraw = !0
    };
    var a = cc.LabelBMFont.WebGLRenderCmd.prototype = Object.create(cc.SpriteBatchNode.WebGLRenderCmd.prototype);
    a.constructor = cc.LabelBMFont.WebGLRenderCmd;
    a._updateCharTexture = function(a, d, e) {
        a.setTextureRect(d, !1);
        a.visible = !0
    };
    a._updateFntFileTexture = function() {};
    a._changeTextureColor = function() {};
    a._updateChildrenDisplayedOpacity = function(a) {
        a.updateDisplayedOpacity(this._displayedOpacity)
    };
    a._updateChildrenDisplayedColor = function(a) {
        a.updateDisplayedColor(this._displayedColor)
    };
    a._initBatchTexture = function() {
        var a = this._node,
            d = a.textureAtlas.texture;
        a._opacityModifyRGB = d.hasPremultipliedAlpha();
        var e = a._reusedChar = new cc.Sprite;
        e.initWithTexture(d, cc.rect(0, 0, 0, 0), !1);
        e.batchNode = a
    };
    a.rendering = function(a) {
        cc.SpriteBatchNode.WebGLRenderCmd.prototype.rendering.call(this, a);
        a = this._node;
        if (cc.LABELBMFONT_DEBUG_DRAW) {
            a = a.getContentSize();
            var d = cc.p(0 | -this._anchorPointInPoints.x, 0 | -this._anchorPointInPoints.y);
            a = [cc.p(d.x, d.y), cc.p(d.x + a.width, d.y), cc.p(d.x + a.width, d.y + a.height), cc.p(d.x, d.y + a.height)];
            cc._drawingUtil.setDrawColor(0, 255, 0, 255);
            cc._drawingUtil.drawPoly(a, 4, !0)
        }
    };
    a._updateCharColorAndOpacity = function() {}
})();
cc._globalFontSize = cc.ITEM_SIZE;
cc._globalFontName = "Arial";
cc._globalFontNameRelease = !1;
cc.MenuItem = cc.Node.extend({
    _enabled: !1,
    _target: null,
    _callback: null,
    _isSelected: !1,
    _className: "MenuItem",
    ctor: function(a, b) {
        var d = cc.Node.prototype;
        d.ctor.call(this);
        this._callback = this._target = null;
        this._enabled = this._isSelected = !1;
        d.setAnchorPoint.call(this, 0.5, 0.5);
        this._target = b || null;
        if (this._callback = a || null) this._enabled = !0
    },
    isSelected: function() {
        return this._isSelected
    },
    setOpacityModifyRGB: function(a) {},
    isOpacityModifyRGB: function() {
        return !1
    },
    setTarget: function(a, b) {
        this._target = b;
        this._callback =
            a
    },
    isEnabled: function() {
        return this._enabled
    },
    setEnabled: function(a) {
        this._enabled = a
    },
    initWithCallback: function(a, b) {
        this.anchorY = this.anchorX = 0.5;
        this._target = b;
        this._callback = a;
        this._enabled = !0;
        this._isSelected = !1;
        return !0
    },
    rect: function() {
        var a = this._position,
            b = this._contentSize,
            d = this._anchorPoint;
        return cc.rect(a.x - b.width * d.x, a.y - b.height * d.y, b.width, b.height)
    },
    selected: function() {
        this._isSelected = !0
    },
    unselected: function() {
        this._isSelected = !1
    },
    setCallback: function(a, b) {
        this._target = b;
        this._callback =
            a
    },
    activate: function() {
        if (this._enabled) {
            var a = this._target,
                b = this._callback;
            if (b)
                if (a && cc.isString(b)) a[b](this);
                else a && cc.isFunction(b) ? b.call(a, this) : b(this)
        }
    }
});
_p = cc.MenuItem.prototype;
cc.defineGetterSetter(_p, "enabled", _p.isEnabled, _p.setEnabled);
cc.MenuItem.create = function(a, b) {
    return new cc.MenuItem(a, b)
};
cc.MenuItemLabel = cc.MenuItem.extend({
    _disabledColor: null,
    _label: null,
    _originalScale: 0,
    _colorBackup: null,
    ctor: function(a, b, d) {
        cc.MenuItem.prototype.ctor.call(this, b, d);
        this._colorBackup = this._label = this._disabledColor = null;
        a && (this._originalScale = 1, this._colorBackup = cc.color.WHITE, this._disabledColor = cc.color(126, 126, 126), this.setLabel(a), this.setCascadeColorEnabled(!0), this.setCascadeOpacityEnabled(!0))
    },
    getDisabledColor: function() {
        return this._disabledColor
    },
    setDisabledColor: function(a) {
        this._disabledColor =
            a
    },
    getLabel: function() {
        return this._label
    },
    setLabel: function(a) {
        a && (this.addChild(a), a.anchorX = 0, a.anchorY = 0, this.width = a.width, this.height = a.height, a.setCascadeColorEnabled(!0));
        this._label && this.removeChild(this._label, !0);
        this._label = a
    },
    setEnabled: function(a) {
        this._enabled !== a && (a ? this.setColor(this._colorBackup) : (this._colorBackup = this.color, this.setColor(this._disabledColor)));
        cc.MenuItem.prototype.setEnabled.call(this, a)
    },
    initWithLabel: function(a, b, d) {
        this.initWithCallback(b, d);
        this._originalScale =
            1;
        this._colorBackup = cc.color.WHITE;
        this._disabledColor = cc.color(126, 126, 126);
        this.setLabel(a);
        this.setCascadeColorEnabled(!0);
        this.setCascadeOpacityEnabled(!0);
        return !0
    },
    setString: function(a) {
        this._label.string = a;
        this.width = this._label.width;
        this.height = this._label.height
    },
    getString: function() {
        return this._label.string
    },
    activate: function() {
        this._enabled && (this.stopAllActions(), this.scale = this._originalScale, cc.MenuItem.prototype.activate.call(this))
    },
    selected: function() {
        if (this._enabled) {
            cc.MenuItem.prototype.selected.call(this);
            var a = this.getActionByTag(cc.ZOOM_ACTION_TAG);
            a ? this.stopAction(a) : this._originalScale = this.scale;
            a = cc.scaleTo(0.1, 1.2 * this._originalScale);
            a.setTag(cc.ZOOM_ACTION_TAG);
            this.runAction(a)
        }
    },
    unselected: function() {
        if (this._enabled) {
            cc.MenuItem.prototype.unselected.call(this);
            this.stopActionByTag(cc.ZOOM_ACTION_TAG);
            var a = cc.scaleTo(0.1, this._originalScale);
            a.setTag(cc.ZOOM_ACTION_TAG);
            this.runAction(a)
        }
    }
});
_p = cc.MenuItemLabel.prototype;
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
cc.defineGetterSetter(_p, "disabledColor", _p.getDisabledColor, _p.setDisabledColor);
cc.defineGetterSetter(_p, "label", _p.getLabel, _p.setLabel);
cc.MenuItemLabel.create = function(a, b, d) {
    return new cc.MenuItemLabel(a, b, d)
};
cc.MenuItemAtlasFont = cc.MenuItemLabel.extend({
    ctor: function(a, b, d, e, f, g, h) {
        var k;
        a && 0 < a.length && (k = new cc.LabelAtlas(a, b, d, e, f));
        cc.MenuItemLabel.prototype.ctor.call(this, k, g, h)
    },
    initWithString: function(a, b, d, e, f, g, h) {
        if (!a || 0 === a.length) throw Error("cc.MenuItemAtlasFont.initWithString(): value should be non-null and its length should be greater than 0");
        var k = new cc.LabelAtlas;
        k.initWithString(a, b, d, e, f);
        this.initWithLabel(k, g, h);
        return !0
    }
});
cc.MenuItemAtlasFont.create = function(a, b, d, e, f, g, h) {
    return new cc.MenuItemAtlasFont(a, b, d, e, f, g, h)
};
cc.MenuItemFont = cc.MenuItemLabel.extend({
    _fontSize: null,
    _fontName: null,
    ctor: function(a, b, d) {
        var e;
        a && 0 < a.length ? (this._fontName = cc._globalFontName, this._fontSize = cc._globalFontSize, e = new cc.LabelTTF(a, this._fontName, this._fontSize)) : (this._fontSize = 0, this._fontName = "");
        cc.MenuItemLabel.prototype.ctor.call(this, e, b, d)
    },
    initWithString: function(a, b, d) {
        if (!a || 0 === a.length) throw Error("Value should be non-null and its length should be greater than 0");
        this._fontName = cc._globalFontName;
        this._fontSize = cc._globalFontSize;
        a = new cc.LabelTTF(a, this._fontName, this._fontSize);
        this.initWithLabel(a, b, d);
        return !0
    },
    setFontSize: function(a) {
        this._fontSize = a;
        this._recreateLabel()
    },
    getFontSize: function() {
        return this._fontSize
    },
    setFontName: function(a) {
        this._fontName = a;
        this._recreateLabel()
    },
    getFontName: function() {
        return this._fontName
    },
    _recreateLabel: function() {
        var a = new cc.LabelTTF(this._label.string, this._fontName, this._fontSize);
        this.setLabel(a)
    }
});
cc.MenuItemFont.setFontSize = function(a) {
    cc._globalFontSize = a
};
cc.MenuItemFont.fontSize = function() {
    return cc._globalFontSize
};
cc.MenuItemFont.setFontName = function(a) {
    cc._globalFontNameRelease && (cc._globalFontName = "");
    cc._globalFontName = a;
    cc._globalFontNameRelease = !0
};
_p = cc.MenuItemFont.prototype;
cc.defineGetterSetter(_p, "fontSize", _p.getFontSize, _p.setFontSize);
cc.defineGetterSetter(_p, "fontName", _p.getFontName, _p.setFontName);
cc.MenuItemFont.fontName = function() {
    return cc._globalFontName
};
cc.MenuItemFont.create = function(a, b, d) {
    return new cc.MenuItemFont(a, b, d)
};
cc.MenuItemSprite = cc.MenuItem.extend({
    _normalImage: null,
    _selectedImage: null,
    _disabledImage: null,
    ctor: function(a, b, d, e, f) {
        cc.MenuItem.prototype.ctor.call(this);
        this._disabledImage = this._selectedImage = this._normalImage = null;
        if (void 0 !== b) {
            var g, h, k;
            void 0 !== f ? (g = d, k = e, h = f) : void 0 !== e && cc.isFunction(e) ? (g = d, k = e) : void 0 !== e && cc.isFunction(d) ? (h = e, k = d, g = null) : void 0 === d && (g = null);
            this.initWithNormalSprite(a, b, g, k, h)
        }
    },
    getNormalImage: function() {
        return this._normalImage
    },
    setNormalImage: function(a) {
        this._normalImage !==
            a && (a && (this.addChild(a, 0, cc.NORMAL_TAG), a.anchorX = 0, a.anchorY = 0), this._normalImage && this.removeChild(this._normalImage, !0), this._normalImage = a, this.width = this._normalImage.width, this.height = this._normalImage.height, this._updateImagesVisibility(), a.textureLoaded && !a.textureLoaded() && a.addEventListener("load", function(a) {
                this.width = a.width;
                this.height = a.height
            }, this))
    },
    getSelectedImage: function() {
        return this._selectedImage
    },
    setSelectedImage: function(a) {
        this._selectedImage !== a && (a && (this.addChild(a,
            0, cc.SELECTED_TAG), a.anchorX = 0, a.anchorY = 0), this._selectedImage && this.removeChild(this._selectedImage, !0), this._selectedImage = a, this._updateImagesVisibility())
    },
    getDisabledImage: function() {
        return this._disabledImage
    },
    setDisabledImage: function(a) {
        this._disabledImage !== a && (a && (this.addChild(a, 0, cc.DISABLE_TAG), a.anchorX = 0, a.anchorY = 0), this._disabledImage && this.removeChild(this._disabledImage, !0), this._disabledImage = a, this._updateImagesVisibility())
    },
    initWithNormalSprite: function(a, b, d, e, f) {
        this.initWithCallback(e,
            f);
        this.setNormalImage(a);
        this.setSelectedImage(b);
        this.setDisabledImage(d);
        if (a = this._normalImage) this.width = a.width, this.height = a.height, a.textureLoaded && !a.textureLoaded() && a.addEventListener("load", function(a) {
            this.width = a.width;
            this.height = a.height;
            this.setCascadeColorEnabled(!0);
            this.setCascadeOpacityEnabled(!0)
        }, this);
        this.setCascadeColorEnabled(!0);
        this.setCascadeOpacityEnabled(!0);
        return !0
    },
    selected: function() {
        cc.MenuItem.prototype.selected.call(this);
        this._normalImage && (this._disabledImage &&
            (this._disabledImage.visible = !1), this._selectedImage ? (this._normalImage.visible = !1, this._selectedImage.visible = !0) : this._normalImage.visible = !0)
    },
    unselected: function() {
        cc.MenuItem.prototype.unselected.call(this);
        this._normalImage && (this._normalImage.visible = !0, this._selectedImage && (this._selectedImage.visible = !1), this._disabledImage && (this._disabledImage.visible = !1))
    },
    setEnabled: function(a) {
        this._enabled !== a && (cc.MenuItem.prototype.setEnabled.call(this, a), this._updateImagesVisibility())
    },
    _updateImagesVisibility: function() {
        var a =
            this._normalImage,
            b = this._selectedImage,
            d = this._disabledImage;
        this._enabled ? (a && (a.visible = !0), b && (b.visible = !1), d && (d.visible = !1)) : d ? (a && (a.visible = !1), b && (b.visible = !1), d && (d.visible = !0)) : (a && (a.visible = !0), b && (b.visible = !1))
    }
});
_p = cc.MenuItemSprite.prototype;
cc.defineGetterSetter(_p, "normalImage", _p.getNormalImage, _p.setNormalImage);
cc.defineGetterSetter(_p, "selectedImage", _p.getSelectedImage, _p.setSelectedImage);
cc.defineGetterSetter(_p, "disabledImage", _p.getDisabledImage, _p.setDisabledImage);
cc.MenuItemSprite.create = function(a, b, d, e, f) {
    return new cc.MenuItemSprite(a, b, d, e, f || void 0)
};
cc.MenuItemImage = cc.MenuItemSprite.extend({
    ctor: function(a, b, d, e, f) {
        var g = null,
            h = null,
            k = null,
            m = null,
            n = null;
        void 0 === a ? cc.MenuItemSprite.prototype.ctor.call(this) : (g = new cc.Sprite(a), b && (h = new cc.Sprite(b)), void 0 === e ? m = d : void 0 === f ? (m = d, n = e) : f && (k = new cc.Sprite(d), m = e, n = f), cc.MenuItemSprite.prototype.ctor.call(this, g, h, k, m, n))
    },
    setNormalSpriteFrame: function(a) {
        this.setNormalImage(new cc.Sprite(a))
    },
    setSelectedSpriteFrame: function(a) {
        this.setSelectedImage(new cc.Sprite(a))
    },
    setDisabledSpriteFrame: function(a) {
        this.setDisabledImage(new cc.Sprite(a))
    },
    initWithNormalImage: function(a, b, d, e, f) {
        var g = null,
            h = null,
            k = null;
        a && (g = new cc.Sprite(a));
        b && (h = new cc.Sprite(b));
        d && (k = new cc.Sprite(d));
        return this.initWithNormalSprite(g, h, k, e, f)
    }
});
cc.MenuItemImage.create = function(a, b, d, e, f) {
    return new cc.MenuItemImage(a, b, d, e, f)
};
cc.MenuItemToggle = cc.MenuItem.extend({
    subItems: null,
    _selectedIndex: 0,
    _opacity: null,
    _color: null,
    ctor: function() {
        cc.MenuItem.prototype.ctor.call(this);
        this._selectedIndex = 0;
        this.subItems = [];
        this._opacity = 0;
        this._color = cc.color.WHITE;
        0 < arguments.length && this.initWithItems(Array.prototype.slice.apply(arguments))
    },
    getOpacity: function() {
        return this._opacity
    },
    setOpacity: function(a) {
        this._opacity = a;
        if (this.subItems && 0 < this.subItems.length)
            for (var b = 0; b < this.subItems.length; b++) this.subItems[b].opacity = a;
        this._color.a = a
    },
    getColor: function() {
        var a = this._color;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    setColor: function(a) {
        var b = this._color;
        b.r = a.r;
        b.g = a.g;
        b.b = a.b;
        if (this.subItems && 0 < this.subItems.length)
            for (b = 0; b < this.subItems.length; b++) this.subItems[b].setColor(a);
        void 0 !== a.a && !a.a_undefined && this.setOpacity(a.a)
    },
    getSelectedIndex: function() {
        return this._selectedIndex
    },
    setSelectedIndex: function(a) {
        if (a !== this._selectedIndex) {
            this._selectedIndex = a;
            (a = this.getChildByTag(cc.CURRENT_ITEM)) && a.removeFromParent(!1);
            a = this.subItems[this._selectedIndex];
            this.addChild(a, 0, cc.CURRENT_ITEM);
            var b = a.width,
                d = a.height;
            this.width = b;
            this.height = d;
            a.setPosition(b / 2, d / 2)
        }
    },
    getSubItems: function() {
        return this.subItems
    },
    setSubItems: function(a) {
        this.subItems = a
    },
    initWithItems: function(a) {
        var b = a.length;
        cc.isFunction(a[a.length - 2]) ? (this.initWithCallback(a[a.length - 2], a[a.length - 1]), b -= 2) : cc.isFunction(a[a.length - 1]) ? (this.initWithCallback(a[a.length - 1], null), b -= 1) : this.initWithCallback(null, null);
        for (var d = this.subItems, e = d.length =
            0; e < b; e++) a[e] && d.push(a[e]);
        this._selectedIndex = cc.UINT_MAX;
        this.setSelectedIndex(0);
        this.setCascadeColorEnabled(!0);
        this.setCascadeOpacityEnabled(!0);
        return !0
    },
    addSubItem: function(a) {
        this.subItems.push(a)
    },
    activate: function() {
        this._enabled && this.setSelectedIndex((this._selectedIndex + 1) % this.subItems.length);
        cc.MenuItem.prototype.activate.call(this)
    },
    selected: function() {
        cc.MenuItem.prototype.selected.call(this);
        this.subItems[this._selectedIndex].selected()
    },
    unselected: function() {
        cc.MenuItem.prototype.unselected.call(this);
        this.subItems[this._selectedIndex].unselected()
    },
    setEnabled: function(a) {
        if (this._enabled !== a) {
            cc.MenuItem.prototype.setEnabled.call(this, a);
            var b = this.subItems;
            if (b && 0 < b.length)
                for (var d = 0; d < b.length; d++) b[d].enabled = a
        }
    },
    selectedItem: function() {
        return this.subItems[this._selectedIndex]
    },
    getSelectedItem: function() {
        return this.subItems[this._selectedIndex]
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this);
        this.setSelectedIndex(this._selectedIndex)
    }
});
_p = cc.MenuItemToggle.prototype;
cc.defineGetterSetter(_p, "selectedIndex", _p.getSelectedIndex, _p.setSelectedIndex);
cc.MenuItemToggle.create = function() {
    0 < arguments.length && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
    var a = new cc.MenuItemToggle;
    a.initWithItems(Array.prototype.slice.apply(arguments));
    return a
};
cc.MENU_STATE_WAITING = 0;
cc.MENU_STATE_TRACKING_TOUCH = 1;
cc.MENU_HANDLER_PRIORITY = -128;
cc.DEFAULT_PADDING = 5;
cc.Menu = cc.Layer.extend({
    enabled: !1,
    _selectedItem: null,
    _state: -1,
    _touchListener: null,
    _className: "Menu",
    ctor: function(a) {
        cc.Layer.prototype.ctor.call(this);
        this._color = cc.color.WHITE;
        this.enabled = !1;
        this._opacity = 255;
        this._selectedItem = null;
        this._state = -1;
        this._touchListener = cc.EventListener.create({
            event: cc.EventListener.TOUCH_ONE_BY_ONE,
            swallowTouches: !0,
            onTouchBegan: this._onTouchBegan,
            onTouchMoved: this._onTouchMoved,
            onTouchEnded: this._onTouchEnded,
            onTouchCancelled: this._onTouchCancelled
        });
        0 < arguments.length &&
            null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
        var b = arguments.length,
            d;
        if (0 === b) d = [];
        else if (1 === b) d = a instanceof Array ? a : [a];
        else if (1 < b) {
            d = [];
            for (var e = 0; e < b; e++) arguments[e] && d.push(arguments[e])
        }
        this.initWithArray(d)
    },
    onEnter: function() {
        var a = this._touchListener;
        a._isRegistered() || cc.eventManager.addListener(a, this);
        cc.Node.prototype.onEnter.call(this)
    },
    isEnabled: function() {
        return this.enabled
    },
    setEnabled: function(a) {
        this.enabled = a
    },
    initWithItems: function(a) {
        var b = [];
        if (a)
            for (var d = 0; d < a.length; d++) a[d] && b.push(a[d]);
        return this.initWithArray(b)
    },
    initWithArray: function(a) {
        if (cc.Layer.prototype.init.call(this)) {
            this.enabled = !0;
            var b = cc.winSize;
            this.setPosition(b.width / 2, b.height / 2);
            this.setContentSize(b);
            this.setAnchorPoint(0.5, 0.5);
            this.ignoreAnchorPointForPosition(!0);
            if (a)
                for (b = 0; b < a.length; b++) this.addChild(a[b], b);
            this._selectedItem = null;
            this._state = cc.MENU_STATE_WAITING;
            return this.cascadeOpacity = this.cascadeColor = !0
        }
        return !1
    },
    addChild: function(a, b, d) {
        if (!(a instanceof cc.MenuItem)) throw Error("cc.Menu.addChild() : Menu only supports MenuItem objects as children");
        cc.Layer.prototype.addChild.call(this, a, b, d)
    },
    alignItemsVertically: function() {
        this.alignItemsVerticallyWithPadding(cc.DEFAULT_PADDING)
    },
    alignItemsVerticallyWithPadding: function(a) {
        var b = -a,
            d = this._children,
            e, f, g, h;
        if (d && 0 < d.length) {
            f = 0;
            for (e = d.length; f < e; f++) b += d[f].height * d[f].scaleY + a;
            var k = b / 2;
            f = 0;
            for (e = d.length; f < e; f++) h = d[f], g = h.height, b = h.scaleY, h.setPosition(0, k - g * b / 2), k -= g * b + a
        }
    },
    alignItemsHorizontally: function() {
        this.alignItemsHorizontallyWithPadding(cc.DEFAULT_PADDING)
    },
    alignItemsHorizontallyWithPadding: function(a) {
        var b = -a,
            d = this._children,
            e, f, g, h;
        if (d && 0 < d.length) {
            e = 0;
            for (f = d.length; e < f; e++) b += d[e].width * d[e].scaleX + a;
            var k = -b / 2;
            e = 0;
            for (f = d.length; e < f; e++) h = d[e], b = h.scaleX, g = d[e].width, h.setPosition(k + g * b / 2, 0), k += g * b + a
        }
    },
    alignItemsInColumns: function() {
        0 < arguments.length && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
        for (var a = [], b = 0; b < arguments.length; b++) a.push(arguments[b]);
        var d = -5,
            e = 0,
            f = 0,
            g = 0,
            h, k, m, n =
            this._children;
        if (n && 0 < n.length) {
            b = 0;
            for (m = n.length; b < m; b++)
                if (!(e >= a.length) && (h = a[e])) k = n[b].height, f = f >= k || isNaN(k) ? f : k, ++g, g >= h && (d += f + 5, f = g = 0, ++e)
        }
        var p = cc.director.getWinSize(),
            r = h = f = e = 0,
            s = 0,
            d = d / 2;
        if (n && 0 < n.length) {
            b = 0;
            for (m = n.length; b < m; b++) {
                var t = n[b];
                0 === h && (h = a[e], s = r = p.width / (1 + h));
                k = t._getHeight();
                f = f >= k || isNaN(k) ? f : k;
                t.setPosition(s - p.width / 2, d - k / 2);
                s += r;
                ++g;
                g >= h && (d -= f + 5, f = h = g = 0, ++e)
            }
        }
    },
    alignItemsInRows: function() {
        0 < arguments.length && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
        var a = [],
            b;
        for (b = 0; b < arguments.length; b++) a.push(arguments[b]);
        var d = [],
            e = [],
            f = -10,
            g = -5,
            h = 0,
            k = 0,
            m = 0,
            n, p, r, s, t = this._children;
        if (t && 0 < t.length) {
            b = 0;
            for (r = t.length; b < r; b++)
                if (p = t[b], !(h >= a.length) && (n = a[h])) s = p.width, k = k >= s || isNaN(s) ? k : s, g += p.height + 5, ++m, m >= n && (d.push(k), e.push(g), f += k + 10, k = m = 0, g = -5, ++h)
        }
        g = cc.director.getWinSize();
        n = k = h = 0;
        var f = -f / 2,
            u = 0;
        if (t && 0 < t.length) {
            b = 0;
            for (r = t.length; b < r; b++) p = t[b], 0 === n && (n = a[h], u = e[h]), s = p._getWidth(), k = k >= s || isNaN(s) ? k : s, p.setPosition(f + d[h] / 2, u - g.height /
                2), u -= p.height + 10, ++m, m >= n && (f += k + 5, k = n = m = 0, ++h)
        }
    },
    removeChild: function(a, b) {
        null != a && (a instanceof cc.MenuItem ? (this._selectedItem === a && (this._selectedItem = null), cc.Node.prototype.removeChild.call(this, a, b)) : cc.log("cc.Menu.removeChild():Menu only supports MenuItem objects as children"))
    },
    _onTouchBegan: function(a, b) {
        var d = b.getCurrentTarget();
        if (d._state !== cc.MENU_STATE_WAITING || !d._visible || !d.enabled) return !1;
        for (var e = d.parent; null != e; e = e.parent)
            if (!e.isVisible()) return !1;
        d._selectedItem = d._itemForTouch(a);
        return d._selectedItem ? (d._state = cc.MENU_STATE_TRACKING_TOUCH, d._selectedItem.selected(), d._selectedItem.setNodeDirty(), !0) : !1
    },
    _onTouchEnded: function(a, b) {
        var d = b.getCurrentTarget();
        d._state !== cc.MENU_STATE_TRACKING_TOUCH ? cc.log("cc.Menu.onTouchEnded(): invalid state") : (d._selectedItem && (d._selectedItem.unselected(), d._selectedItem.setNodeDirty(), d._selectedItem.activate()), d._state = cc.MENU_STATE_WAITING)
    },
    _onTouchCancelled: function(a, b) {
        var d = b.getCurrentTarget();
        d._state !== cc.MENU_STATE_TRACKING_TOUCH ?
            cc.log("cc.Menu.onTouchCancelled(): invalid state") : (this._selectedItem && (d._selectedItem.unselected(), d._selectedItem.setNodeDirty()), d._state = cc.MENU_STATE_WAITING)
    },
    _onTouchMoved: function(a, b) {
        var d = b.getCurrentTarget();
        if (d._state !== cc.MENU_STATE_TRACKING_TOUCH) cc.log("cc.Menu.onTouchMoved(): invalid state");
        else {
            var e = d._itemForTouch(a);
            e !== d._selectedItem && (d._selectedItem && (d._selectedItem.unselected(), d._selectedItem.setNodeDirty()), d._selectedItem = e, d._selectedItem && (d._selectedItem.selected(),
                d._selectedItem.setNodeDirty()))
        }
    },
    onExit: function() {
        this._state === cc.MENU_STATE_TRACKING_TOUCH && (this._selectedItem && (this._selectedItem.unselected(), this._selectedItem = null), this._state = cc.MENU_STATE_WAITING);
        cc.Node.prototype.onExit.call(this)
    },
    setOpacityModifyRGB: function(a) {},
    isOpacityModifyRGB: function() {
        return !1
    },
    _itemForTouch: function(a) {
        a = a.getLocation();
        var b = this._children,
            d;
        if (b && 0 < b.length)
            for (var e = b.length - 1; 0 <= e; e--)
                if (d = b[e], d.isVisible() && d.isEnabled()) {
                    var f = d.convertToNodeSpace(a),
                        g = d.rect();
                    g.x = 0;
                    g.y = 0;
                    if (cc.rectContainsPoint(g, f)) return d
                }
        return null
    }
});
_p = cc.Menu.prototype;
cc.Menu.create = function(a) {
    var b = arguments.length;
    0 < b && null == arguments[b - 1] && cc.log("parameters should not be ending with null in Javascript");
    return 0 === b ? new cc.Menu : 1 === b ? new cc.Menu(a) : new cc.Menu(Array.prototype.slice.call(arguments, 0))
};
var game = game || {};
game.aListZhu = [];

var res = {
        UiPlist: "static/UiPlist.plist",
        UiPlist_png: "static/UiPlist.png",
        startBg_png: "static/startBg.jpg",
        startBtn_png: "static/startBtn.png",
        playBg_png: "static/bg1.jpg",
        playBg2_png: "static/bg2.jpg",
        overBg_png: "static/overBg.png",
        guid_png: "static/guid.png",
        fint5050_png: "static/fint5050.png",
        logo_png: "static/logo.png"
    },
    g_resources = [],
    i;
for (i in res) g_resources.push(res[i]);
game.StartScene = cc.Scene.extend({
    ctor: function() {
        this._super();

        cc.spriteFrameCache.addSpriteFrames(res.UiPlist, res.UiPlist_png);
        var a = new cc.Sprite(res.startBg_png);
        a.setPosition(cc.p(240, 400));
        this.addChild(a);
        a = new cc.Sprite(res.startBtn_png);
        a = new cc.MenuItemSprite(a, null, function() {
            cc.director.runScene(new game.PlayScene)
        }, this);
        a.attr({
            x: 240,
            y: 150,
            anchorX: 0.5,
            anchorY: 0.5
        });
        a = new cc.Menu(a, null);
        a.x = 0;
        a.y = 0;
        this.addChild(a);
        return !0
    }
});
game.NewGuider = cc.LayerColor.extend({
    touchNum: null,
    ctor: function() {
        this._super(cc.color(10, 10, 10, 90));
        this.touchNum = 1;
        this.size = cc.winSize;
        cc.director.pause();
        var a = cc.spriteFrameCache.getSpriteFrame("offBtn.png"),
            b = cc.spriteFrameCache.getSpriteFrame("right.png"),
            d = new cc.Sprite(res.guid_png);
        d.setPosition(cc.p(this.size.width / 2, this.size.height / 2));
        this.addChild(d, 1);
        a = new cc.Sprite(a);
        b = new cc.Sprite(b);
        a = new cc.MenuItemSprite(a, null, function() {
            this.close()
        }, this);
        a.attr({
            x: d.width - 20,
            y: d.height -
                20,
            anchorX: 0.5,
            anchorY: 0.5
        });
        this.startItem2 = new cc.MenuItemSprite(b, null, function() {
            this.selectedStateEvent()
        }, this);
        this.startItem2.attr({
            x: 55,
            y: 20,
            anchorX: 0.5,
            anchorY: 0.5
        });
        b = new cc.Menu(a, this.startItem2, null);
        b.x = 0;
        b.y = 0;
        d.addChild(b);
        this.startItem2.setOpacity(0.0010);
        return !0
    },
    selectedStateEvent: function() {
        this.touchNum = 2 > this.touchNum ? this.touchNum + 1 : 1;
        switch (this.touchNum) {
            case 1:
                this.startItem2.setOpacity(0.0010);
                cc.sys.localStorage.setItem("CheckBox", "show");
                break;
            case 2:
                this.startItem2.setOpacity(255),
                    cc.sys.localStorage.setItem("CheckBox", "notShow")
        }
    },
    close: function() {
        this.removeFromParent();
        cc.director.resume()
    }
});
game.MenuOverLayer = cc.Layer.extend({
    ctor: function() {
        this._super();
        // ggay();
        this.size = cc.winSize;
        var a = cc.spriteFrameCache.getSpriteFrame("shareBtn.png"),
            b = cc.spriteFrameCache.getSpriteFrame("reStartBtn.png"),
            d = new cc.Sprite(res.overBg_png);
        d.setPosition(cc.p(240, 400));
        this.addChild(d);
        b = new cc.Sprite(b);
        a = new cc.Sprite(a);
        b = new cc.MenuItemSprite(b, null, function() {
            cc.director.runScene(new game.PlayScene)
        }, this);
        b.attr({
            x: 340,
            y: 150,
            anchorX: 0.5,
            anchorY: 0.5
        });
        a = new cc.MenuItemSprite(a, null, function() {
            // window.location.href =
            //     "/"
        }, this);
        a.attr({
            x: 140,
            y: 150,
            anchorX: 0.5,
            anchorY: 0.5
        });
        a = new cc.Menu(b, a, null);
        a.x = 0;
        a.y = 0;
        this.addChild(a);
        this.labelScore = new cc.LabelAtlas("0", res.fint5050_png, 50, 50, "0");
        this.labelScore.setAnchorPoint(cc.p(0.5, 0.5));
        this.labelScore.setPosition(cc.p(0.5 * this.size.width, 0.58 * this.size.height));
        this.labelScore.setString(game.scoreM);
        this.addChild(this.labelScore, 10);
        cc.sys.localStorage.getItem("MaxScore_qz") || cc.sys.localStorage.setItem("MaxScore_qz", 0);
        a = JSON.parse(cc.sys.localStorage.getItem("MaxScore_qz"));
        a <= game.scoreM && (a = game.scoreM, cc.sys.localStorage.setItem("MaxScore_qz", a));
        this.labelMaxScore = new cc.LabelAtlas("0", res.fint5050_png, 50, 50, "0");
        this.labelMaxScore.setAnchorPoint(cc.p(0.5, 0.5));
        this.labelMaxScore.setPosition(cc.p(0.5 * this.size.width, 0.4 * this.size.height));
        this.labelMaxScore.setString(a);
        this.addChild(this.labelMaxScore, 1);
        return !0
    },
    moveTo: function() {
        var a = new cc.moveTo(0.25, cc.p(30, 0)),
            b = new cc.moveTo(0.1, cc.p(-20, 0)),
            d = new cc.moveTo(0.1, cc.p(0, 0)),
            a = new cc.Sequence(a, b, d);
        this.runAction(a)
    },
    returnHome: function() {
        // window.location.href = "/"
    }
});
game.ShareGuidLayer = cc.Layer.extend({
    ctor: function() {
        this._super();
        var a = new cc.Sprite(res.shareLayer_png);
        a.setPosition(cc.p(240, 400));
        this.addChild(a);
        a = cc.spriteFrameCache.getSpriteFrame("offBtn.png");
        a = new cc.Sprite(a);
        a = new cc.MenuItemSprite(a, null, function() {
            this.removeFromParent()
        }, this);
        a.attr({
            x: 390,
            y: 592,
            anchorX: 0.5,
            anchorY: 0.5
        });
        a = new cc.Menu(a, null);
        a.x = 0;
        a.y = 0;
        this.addChild(a);
        this.touchListener = cc.EventListener.create({
            event: cc.EventListener.TOUCH_ONE_BY_ONE,
            swallowTouches: !0,
            onTouchBegan: function(a,
                d) {
                return !0
            }
        });
        cc.eventManager.addListener(this.touchListener, this);
        return !0
    }
});
game.PlayLayer = cc.Layer.extend({
    currentZhu: null,
    endZhuSp: null,
    limit: null,
    limitH: null,
    canMoveZhu: null,
    xSpeed: null,
    countZhuNum: null,
    ctor: function() {
        this._super();
        this.size = cc.winSize;
        this.playBg1 = new cc.Sprite(res.playBg_png);
        this.playBg1.setPosition(cc.p(240, 400));
        this.addChild(this.playBg1);
        this.countZhuNum = 0;
        this.playBg2 = new cc.Sprite(res.playBg2_png);
        this.playBg2.setPosition(cc.p(this.playBg1.x + this.playBg1.width / 2 + this.playBg2.width / 2, 400));
        this.addChild(this.playBg2);
        this.canMoveZhu = !1;
        this.xSpeed =
            1E3;
        var a = new cc.Sprite(cc.spriteFrameCache.getSpriteFrame("bland.png"));
        a.setPosition(cc.p(240, a.height / 2));
        this.addChild(a, 2);
        this.limit = 150;
        this.limitH = 156;
        this.maxPointY = 226;
        this.minPointY = 66;
        a = new game.ZhuSprite.create(2);
        game.aListZhu.push(a);
        a.countNum = this.countZhuNum;
        a.setPosition(cc.p(this.limit, this.limitH + a.height / 2 - 80));
        this.addChild(a);
        this.endZhuSp = this.currentZhu = a;
        this.fAddZhu();
        this.fAddZhu();
        this.bunnySp = new game.BunnySprite;
        this.bunnySp.setPosition(cc.p(this.limit, a.y + a.height /
            2 + this.bunnySp.height / 2));
        this.addChild(this.bunnySp, 1);
        this.arrowSp = new game.ArrowSprite;
        this.arrowSp.setPosition(this.bunnySp.getPosition());
        this.addChild(this.arrowSp);
        game.scoreM = 0;
        this.labelScore = new cc.LabelAtlas("0", res.fint5050_png, 50, 50, "0");
        this.labelScore.setAnchorPoint(cc.p(0.5, 0.5));
        this.labelScore.setPosition(cc.p(0.5 * this.size.width, this.size.height - 80));
        this.addChild(this.labelScore);
        var b = this;
        this.touchListener = cc.EventListener.create({
            event: cc.EventListener.TOUCH_ONE_BY_ONE,
            swallowTouches: !0,
            onTouchBegan: function(a, e) {
                if (b.bunnySp.canJump) return !1;
                this.tPoint = a.getLocation();
                b.arrowSp.setPosition(b.bunnySp.getPosition());
                return b.arrowSp.visible = !0
            },
            onTouchMoved: function(a, e) {
                var f = a.getLocation(),
                    g = cc.p(f.x - this.tPoint.x, f.y - this.tPoint.y),
                    h = Math.atan(g.x / g.y);
                b.mDegree = 180 * h / Math.PI;
                0 <= g.x && 0 <= g.y || (b.mDegree = 0 <= g.x && 0 >= g.y ? b.mDegree + 180 : 0 >= g.x && 0 >= g.y ? b.mDegree + 180 : b.mDegree + 360);
                0 > b.mDegree && (b.mDegree = 0);
                360 < b.mDegree && (b.mDegree = 0);
                0 != g.y && (g = b.mDegree + 180, 360 < g && (g -= 360), b.arrowSp.rotation =
                    g);
                b.arrowSp.fScaleAc(b.getDistance(this.tPoint, f))
            },
            onTouchEnded: function(a, e) {
                b.arrowSp.visible = !1;
                80 <= b.arrowSp.rotation && 280 >= b.arrowSp.rotation || b.bunnySp.canJump || b.bunnySp.fBeginJump(b.arrowSp.rotation, b.arrowSp.scaleY);
                b.arrowSp.fResetSelf()
            }
        });
        cc.eventManager.addListener(this.touchListener, this);
        this.scheduleUpdate();
        return !0
    },
    fGameOver: function() {
        mobConfig.stop();
        this.unscheduleUpdate();
        var a = cc.sequence(cc.moveBy(0.01, 3, 0), cc.moveBy(0.01, 0, 3), cc.moveBy(0.02, -6, 0), cc.moveBy(0.02, 0, -6), cc.moveBy(0.01, 3, 0),
            cc.moveBy(0.01, 0, 3));
        this.runAction(cc.sequence(a, a, cc.callFunc(function() {
            var a = new game.MenuOverLayer;
            a.x = -240;
            this.addChild(a, 10);
            a.moveTo();
            game.aListZhu = []
        }, this)))
    },
    update: function(a) {
        this.bunnySp.fJump(a);
        if (this.canMoveZhu) {
            this.bunnySp.x -= a * this.xSpeed;
            this.endZhuSp.x <= 480 - this.endZhuSp.width && this.fAddZhu();
            for (var b = 0; b < game.aListZhu.length; b++) {
                var d = game.aListZhu[b];
                d.x -= this.xSpeed * a;
                if (this.currentZhu.x <= this.limit) {
                    this.currentZhu.x = this.limit;
                    this.canMoveZhu = !1;
                    this.bunnySp.x = this.currentZhu.x +
                        this.bunnySp.dataX;
                    break
                }
                d.x < -d.width / 2 + 2 && (d.canDelete = !0)
            }
            for (b = 0; b < game.aListZhu.length; b++) game.aListZhu[b].canDelete && (game.aListZhu[b].removeFromParent(), game.aListZhu[b] = void 0, game.aListZhu.splice(b, 1), b--);
            b = Math.abs(this.playBg1.x - this.playBg2.x) - 480;
            0 <= b && (this.playBg1.x > this.playBg2.x ? this.playBg1.x -= b : this.playBg1.x < this.playBg2.x && (this.playBg2.x -= b));
            this.playBg1.x <= -this.playBg1.width / 2 ? this.playBg1.setPositionX(this.playBg2.x + this.playBg2.width) : this.playBg1.x -= a * this.xSpeed;
            this.playBg2.x <=
                -this.playBg2.width / 2 ? this.playBg2.setPositionX(this.playBg1.x + this.playBg1.width) : this.playBg2.x -= a * this.xSpeed
        }
    },
    getDistance: function(a, b) {
        return Math.sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y))
    },
    fAddZhu: function() {
        var a = Math.floor(3 * Math.random() + 1),
            a = new game.ZhuSprite.create(a);
        this.countZhuNum += 1;
        a.countNum = this.countZhuNum;
        var b = this.endZhuSp.x + (100 + 100 * Math.random());
        a.setPosition(cc.p(b, this.minPointY + Math.random() * (this.maxPointY - this.minPointY)));
        this.addChild(a);
        this.endZhuSp = a;
        game.aListZhu.push(a)
    },
    fChickBound: function() {}
});
game.PlayScene = cc.Scene.extend({
    onEnter: function() {
        this._super();
        var a = new game.PlayLayer;
        this.addChild(a);
        cc.sys.localStorage.getItem("CheckBox") || cc.sys.localStorage.setItem("CheckBox", "show");
        "show" == cc.sys.localStorage.getItem("CheckBox") && (a = new game.NewGuider, this.addChild(a, 9))
    }
});
game.BunnySprite = cc.Sprite.extend({
    speed: null,
    xSpeed: null,
    cutX: null,
    cutY: null,
    Ratio: null,
    canJump: null,
    state: null,
    dataX: null,
    ctor: function() {
        this._super(cc.spriteFrameCache.getSpriteFrame("role1.png"));
        this.canJump = !1;
        this.state = "normal";
        this.speed = 600;
        return !0
    },
    fBeginJump: function(a, b) {
        this.speed = 600;
        this.xSpeed = this.speed *= Math.abs(b);
        this.Ratio = 500;
        var d = a * Math.PI / 180;
        this.cutY = Math.sqrt(1 / (Math.tan(d) * Math.tan(d) + 1));
        this.cutX = Math.tan(d) * this.cutY;
        0 > this.cutX && (this.scaleX = -1);
        this.canJump = !0
    },
    fJump: function(a) {
        this.canJump && (this.speed -= this.Ratio * a, this.y += this.cutY * this.speed * a, this.x += this.cutX * this.xSpeed * a, 0 < this.speed ? "jump" != this.state && (this.state = "jump", this.setSpriteFrame("role2.png")) : 0 > this.speed && "down" != this.state && (this.state = "down", this.setSpriteFrame("role3.png")), this.fChickBound(), (-40 > this.y || 580 < this.x) && this.parent.fGameOver())
    },
    fResetSelf: function(a) {
        this.scaleX = 1;
        this.setSpriteFrame("role1.png");
        this.y = a + 32
    },
    fChickBound: function() {
        for (var a = 0; a < game.aListZhu.length; a++) {
            var b =
                game.aListZhu[a];
            if (b.x - b.width / 2 < this.x + 10 && this.x - 10 < b.x + b.width / 2)
                if (this.y - this.height / 2 <= b.y + b.height / 2 && this.y - this.height / 2 + 10 >= b.y + b.height / 2 - 10) {
                    this.canJump = !1;
                    this.fResetSelf(b.y + b.height / 2);
                    b.x > this.parent.limit && (a = b.countNum - this.parent.currentZhu.countNum, this.dataX = this.x - b.x, this.parent.currentZhu = b, this.parent.canMoveZhu = !0, game.scoreM += a, this.parent.labelScore.setString(game.scoreM));
                    break
                } else this.y - this.height / 2 < b.y + b.height / 2 - 10 && this.y - this.height / 2 + 10 > b.y - b.height / 2 && (this.cutX =
                    0, this.x = b.x - b.width / 2 - 18)
        }
    }
});
game.ArrowSprite = cc.Sprite.extend({
    dataH: null,
    ctor: function() {
        this._super(cc.spriteFrameCache.getSpriteFrame("arrow.png"));
        this.dataH = 30;
        this.scaleY = 1 / this.dataH;
        this.setAnchorPoint(cc.p(0.5, 0));
        return !0
    },
    fScaleAc: function(a) {
        a >= this.dataH && (a = this.dataH);
        this.scaleY = a * (1 / this.dataH)
    },
    fResetSelf: function() {
        this.scaleY = 1 / this.dataH
    }
});
game.ZhuSprite = cc.Sprite.extend({
    ctor: function(a) {
        this._super(cc.spriteFrameCache.getSpriteFrame("obs" + a + ".png"));
        return !0
    },
    monster1: function() {}
});
game.ZhuSprite.create = function(a) {
    return new game.ZhuSprite(a)
};
cc.game.onStart = function() {
    !cc.sys.isNative && document.getElementById("cocosLoading") && document.body.removeChild(document.getElementById("cocosLoading"));
    "iOS" == cc.sys.os ? cc.view.enableRetina(!0) : cc.view.enableRetina(!1);
    cc.view.adjustViewPort(!0);
    cc.view.setDesignResolutionSize(480, 800, cc.ResolutionPolicy.SHOW_ALL);
    cc.view.resizeWithBrowserSize(!0);
    cc.LoaderScene.preload(g_resources, function() {
       cc.director.runScene(new game.StartScene);
    }, this)
};
cc.game.run();